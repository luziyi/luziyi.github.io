<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPP set集合容器自定义比较函数</title>
    <url>//posts/3508812232.html</url>
    <content><![CDATA[<p>set中自定义比较函数</p>
<p>使用insert()将元素插入到集合中去的时候，集合会根据设定的比较函数将该元素放到该放的节点上去。在定义集合的时候，如果没有</p>
<p>指定比较函数，那么采用默认的比较函数(按键值又小到大的顺序插入元素)。</p>
<p>编写比较函数的两张方法：</p>
<p>1.如果元素不是结构体，那么可以编写比较函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义比较函数myComp，重载操作符 ()</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myComp</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b;	<span class="comment">//从大到小排序</span></span><br><span class="line">		<span class="comment">//return a &lt; b;	//从小到大排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>, myComp&gt; s1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		s<span class="number">1.</span><span class="built_in">insert</span>(i*i);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="comment">//ostream_iterator&lt;int&gt; output(cout, &quot; &quot;);</span></span><br><span class="line">	set&lt;<span class="type">int</span>, myComp&gt;::iterator it = s<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span>(; it != s<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.如果元素是结构体，那么可以直接把比较函数写在结构体内。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="comment">//重载操作符&lt;,自定义排序规则</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Info &amp;a)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//return a.score &lt; score;	//按score由大到小排列</span></span><br><span class="line">		<span class="keyword">return</span> a.score &gt; score;	<span class="comment">//由小到大排列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Info&gt; s;</span><br><span class="line">	Info info;</span><br><span class="line">	info.name = <span class="string">&quot;Messi&quot;</span>;</span><br><span class="line">	info.score = <span class="number">8.5</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(info);</span><br><span class="line">	info.name = <span class="string">&quot;Ronae&quot;</span>;</span><br><span class="line">	info.score = <span class="number">9.0</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(info);</span><br><span class="line">	info.name = <span class="string">&quot;My&quot;</span>;</span><br><span class="line">	info.score = <span class="number">7.0</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(info);</span><br><span class="line">	info.name = <span class="string">&quot;Perno&quot;</span>;</span><br><span class="line">	info.score = <span class="number">8.0</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(info);</span><br><span class="line">	info.name = <span class="string">&quot;Arzar&quot;</span>;</span><br><span class="line">	info.score = <span class="number">8.5</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(info);</span><br><span class="line">	set&lt;Info&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span>(it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;it-&gt;name&lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">		cout&lt;&lt;(*it).score&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP STL 容器介绍</title>
    <url>//posts/2449392461.html</url>
    <content><![CDATA[<p>C++ STL（Standard Template
Library）是C++标准库中的一个重要组成部分，提供了丰富的通用数据结构和算法。STL旨在提供高效、可复用和可移植的编程工具，帮助开发人员更轻松地实现各种应用。</p>
<p>STL包含以下几种主要组件：</p>
<ol type="1">
<li><p>容器（Containers）：STL提供了多种容器类型，如向量（vector）、链表（list）、栈（stack）、队列（queue）、集合（set）和映射（map）等。这些容器提供不同的数据存储方式和操作方法，使其适用于各种场景。本篇主要介绍的就是STL中的容器。</p></li>
<li><p>算法（Algorithms）：STL包含了大量的算法实现，如排序、查找、合并、变换等。这些算法可以直接应用于各种容器，提供了一致且高效的处理数据的方式。</p></li>
<li><p>迭代器（Iterators）：迭代器是STL的基本概念，用于遍历和访问容器中的元素。STL提供了多种迭代器类型，如输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器，每种迭代器都有自己的特性和限制。</p></li>
<li><p>函数对象（Function
Objects）：函数对象是一种行为类似函数的对象，可以被算法使用。STL中提供了一些常用的函数对象，如比较器、谓词和哈希函数等。</p></li>
<li><p>适配器（Adapters）：STL还提供了一些容器适配器，如栈适配器（stack）和队列适配器（queue），以提供特定功能的接口和行为。</p></li>
</ol>
<p>STL的设计思想是基于泛型编程和模板元编程，使得它能够适应各种数据类型，并提供高度灵活性和可扩展性。通过使用STL，可以简化代码、提高开发效率，并减少错误的可能性。</p>
<p>C++
STL提供了多种容器类型，每种容器都有自己的特点和适用场景。本篇将对STL中的各类容器进行详细讲解：</p>
<h3 id="向量vector">1.向量（vector）：</h3>
<p>向量是一种动态数组，可以在尾部高效地插入和删除元素。它支持随机访问，在任意位置进行元素插入和删除可能会导致较高的时间复杂度。</p>
<p>vector是C++ STL中的一种容器，它是一个动态数组（Dynamic
Array）类型。下面是对vector的详细解释：</p>
<p>特点：</p>
<p>动态大小：vector可以根据需要动态地调整自身的大小，可以在尾部高效地插入和删除元素。
连续存储：vector中的元素在内存中是连续存储的，这使得随机访问元素变得非常高效。
头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>声明和初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Type&gt; vec; <span class="comment">// 声明一个空的vector，元素类型为Type</span></span><br><span class="line"><span class="function">std::vector&lt;Type&gt; <span class="title">vec</span><span class="params">(size)</span></span>; <span class="comment">// 声明一个包含size个默认初始化元素的vector</span></span><br><span class="line"><span class="function">std::vector&lt;Type&gt; <span class="title">vec</span><span class="params">(size, value)</span></span>; <span class="comment">// 声明一个包含size个value作为初始值的vector</span></span><br><span class="line"><span class="function">std::vector&lt;Type&gt; <span class="title">vec</span><span class="params">(other_vec)</span></span>; <span class="comment">// 声明一个与other_vec相同的vector</span></span><br></pre></td></tr></table></figure>
<p>常用操作： 插入和删除元素： <code>push_back(value)</code>:
在vector的尾部插入一个元素。 <code>pop_back()</code>:
删除vector的尾部元素。 <code>insert(iterator, value)</code>:
在指定位置前插入一个元素。 <code>erase(iterator)</code>:
删除指定位置的元素。 <code>erase(first, last)</code>: 删除区间[first,
last)内的元素。 访问元素：
<code>vec[index]</code>：通过下标访问vector中的元素。
<code>vec.at(index)</code>:
安全地通过下标访问vector中的元素，会进行边界检查。
<code>vec.front()</code>: 返回vector的第一个元素。
<code>vec.back()</code>: 返回vector的最后一个元素。 大小和容量：
<code>vec.size()</code>: 返回vector中元素的个数。
<code>vec.empty()</code>: 判断vector是否为空。
<code>vec.resize(new_size)</code>: 修改vector的大小为new_size。
<code>vec.reserve(new_capacity)</code>: 修改vector的容量为new_capacity。
清空和重置： <code>vec.clear()</code>: 清空vector中的所有元素。
<code>vec.swap(other_vec)</code>: 交换两个vector的内容。 迭代器：
vector提供了迭代器以便对元素进行遍历。常用的迭代器有：
<code>vec.begin()</code>: 返回指向vector第一个元素的迭代器。
<code>vec.end()</code>:
返回指向vector末尾（最后一个元素的下一个）的迭代器。 示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">vec[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector是一个强大且常用的容器，它提供了高效的动态数组操作和灵活的内存管理。通过使用vector，我们可以方便地操作和管理一组数据。</p>
<h3 id="链表list">2.链表（list）：</h3>
<p>链表是一个双向链表结构，可以在任意位置高效地插入和删除元素。然而，链表不支持随机访问，只能通过遍历来访问元素。</p>
<p>特点：</p>
<p>双向链接：list中的元素以双向链接的方式存储，每个元素都包含指向前一个和后一个元素的指针。
动态大小：list可以根据需要动态地调整自身的大小，可以在任意位置高效地插入和删除元素。
头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>声明和初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list&lt;Type&gt; lst; <span class="comment">// 声明一个空的list，元素类型为Type</span></span><br><span class="line"><span class="function">std::list&lt;Type&gt; <span class="title">lst</span><span class="params">(size)</span></span>; <span class="comment">// 声明一个包含size个默认初始化元素的list</span></span><br><span class="line"><span class="function">std::list&lt;Type&gt; <span class="title">lst</span><span class="params">(size, value)</span></span>; <span class="comment">// 声明一个包含size个value作为初始值的list</span></span><br><span class="line"><span class="function">std::list&lt;Type&gt; <span class="title">lst</span><span class="params">(other_lst)</span></span>; <span class="comment">// 声明一个与other_lst相同的list</span></span><br></pre></td></tr></table></figure>
<p>常用操作：</p>
<p>插入和删除元素： <code>push_back(value)</code>:
在list的尾部插入一个元素。 <code>push_front(value)</code>:
在list的头部插入一个元素。 <code>pop_back()</code>: 删除list的尾部元素。
<code>pop_front()</code>: 删除list的头部元素。
<code>insert(iterator, value)</code>: 在指定位置前插入一个元素。
<code>erase(iterator)</code>: 删除指定位置的元素。
<code>erase(first, last)</code>: 删除区间[first, last)内的元素。
访问元素：
由于list是一个链表结构，不能通过下标直接访问元素。可以使用迭代器进行遍历和访问。
大小和容量： <code>lst.size()</code>: 返回list中元素的个数。
<code>lst.empty()</code>: 判断list是否为空。 清空和重置：
<code>lst.clear()</code>: 清空list中的所有元素。
<code>lst.swap(other_lst)</code>: 交换两个list的内容。 迭代器：
list提供了迭代器以便对元素进行遍历。常用的迭代器有：</p>
<p><code>lst.begin()</code>: 返回指向list第一个元素的迭代器。
<code>lst.end()</code>:
返回指向list末尾（最后一个元素的下一个）的迭代器。 示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">lst.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">20</span>);</span><br><span class="line">lst.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>(); it != lst.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line"><span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line">++it;</span><br><span class="line">*it = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">lst.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; lst.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list是一个灵活且常用的容器，它适合在任意位置高效地插入和删除元素。由于其双向链表的特性，list可以提供较快的插入和删除操作，并且不需要进行内存的动态分配和复制。通过使用list，您可以方便地操作和管理一组数据，尤其是在插入和删除操作频繁的情况下。</p>
<h3 id="双端队列deque">3.双端队列（deque）：</h3>
<p>双端队列是一种两端都可以高效插入和删除元素的数据结构。它既支持随机访问，也支持在头部和尾部插入和删除操作。它的名称deque是"double-ended
queue"的缩写。</p>
<p>双端队列可以在队列的前端和后端同时进行插入和删除操作，因此它既可以作为栈使用，也可以作为队列使用。这使得双端队列非常灵活，并且适用于各种场景。</p>
<p>在实现上，双端队列通常使用动态数组或链表来存储元素。无论是使用数组还是链表，双端队列都可以高效地进行插入和删除操作。</p>
<p>以下是双端队列的基本操作：</p>
<ol type="1">
<li>push_front(item): 在队列的前端插入一个元素。</li>
<li>push_back(item): 在队列的后端插入一个元素。</li>
<li>pop_front(): 删除并返回队列的第一个元素。</li>
<li>pop_back(): 删除并返回队列的最后一个元素。</li>
<li>front(): 返回队列的第一个元素，但不删除它。</li>
<li>back(): 返回队列的最后一个元素，但不删除它。</li>
<li>size(): 返回队列中元素的个数。</li>
<li>empty(): 检查队列是否为空。</li>
</ol>
<p>通过双端队列的特性，我们可以灵活地在两端进行插入和删除操作，使其更加适应实际问题的需求。在算法和数据结构中，双端队列是一个非常有用的工具，可以提高程序的效率和可读性。</p>
<h3 id="栈stack">4.栈（stack）：</h3>
<p>栈（Stack）是一种基于后进先出（LIFO，Last-In-First-Out）原则的线性数据结构。它可以看作是一种受限制的线性表，只允许在表的一端进行插入和删除操作，该端被称为栈顶（top）。</p>
<p>栈的特点使得它非常适合用于临时存储需要反序处理的数据，比如函数调用、表达式求值、括号匹配等场景。</p>
<p>栈的基本操作包括：</p>
<ol type="1">
<li>Push：将元素压入栈顶，即将元素插入到栈中。</li>
<li>Pop：从栈顶弹出一个元素，并返回弹出的元素。</li>
<li>Top（或Peek）：获取栈顶的元素，但不对栈进行修改。</li>
<li>Size：返回栈中元素的个数。</li>
<li>Empty：检查栈是否为空。</li>
</ol>
<p>由于栈的特性，只有栈顶元素是可见的，因此在插入和删除元素时不需要移动其他元素，使得操作效率非常高。</p>
<p>栈可以使用数组或链表实现。使用数组实现的栈被称为顺序栈，使用链表实现的栈被称为链式栈。</p>
<p>栈具有一些重要的应用，例如：</p>
<ol type="1">
<li>函数调用：函数调用时，需要保存局部变量、返回地址等信息，这些信息通常使用栈来保存。</li>
<li>表达式求值：中缀表达式转换为后缀表达式，并使用栈进行运算。</li>
<li>括号匹配：使用栈来检查括号是否匹配。</li>
<li>浏览器历史记录：浏览器使用栈来实现前进和后退功能。</li>
</ol>
<p>总而言之，栈是一种非常有用的数据结构，在许多算法和应用中发挥着重要作用。</p>
<h3 id="队列queue">5.队列（queue）：</h3>
<p>队列（Queue）是一种基于先进先出（FIFO，First-In-First-Out）原则的线性数据结构。它和栈一样也可以看作是一种受限制的线性表，只允许在表的一端（称为队尾back/rear）插入元素，而在另一端（称为队头front）删除元素。</p>
<p>队列的特点使得它非常适合用于按照顺序处理数据的场景，例如任务调度、消息传递等。</p>
<p>队列的基本操作包括：</p>
<ol type="1">
<li>Enqueue（或Push）：将元素插入到队尾。</li>
<li>Dequeue（或Pop）：从队头删除一个元素，并返回被删除的元素。</li>
<li>Front：获取队头的元素，但不对队列进行修改。</li>
<li>Rear（或Back）：获取队尾的元素，但不对队列进行修改。</li>
<li>Size：返回队列中元素的个数。</li>
<li>Empty：检查队列是否为空。</li>
</ol>
<p>由于队列的特性，新元素总是被插入到队尾，而删除元素总是发生在队头，保持了元素的顺序不变。</p>
<p>队列可以使用数组或链表实现。使用数组实现的队列被称为顺序队列，使用链表实现的队列被称为链式队列。</p>
<p>队列具有一些重要的应用，例如：</p>
<ol type="1">
<li>算法设计：广度优先搜索（BFS）和树的层次遍历等算法中常用到队列。</li>
<li>缓存管理：缓存中的数据通常使用队列来管理，保持最新的数据在队尾，而最旧的数据在队头。</li>
<li>系统调度：任务调度器可以使用队列来管理待执行的任务。</li>
</ol>
<p>总之，队列是一种常见且重要的数据结构，在许多算法中发挥着关键作用。</p>
<h3 id="优先队列priority_queue">6.优先队列（priority_queue）：</h3>
<p>优先队列是一种按照特定排序规则进行插入和删除操作的数据结构。它内部使用堆实现，可以高效地获取最大或最小值。它的元素按照一定的优先级进行排序。</p>
<p>默认情况下，优先队列中的元素按照从大到小的顺序进行排列，也可以通过自定义比较器来改变排序顺序。
优先队列的常见操作包括：</p>
<p>1. Push：将元素插入到优先队列中。</p>
<p>2. Pop：删除优先队列中的顶部元素。</p>
<p>3. Top：获取优先队列的顶部元素，但不对队列进行修改。</p>
<p>4. Size：返回优先队列中元素的个数。</p>
<p>5. Empty：检查优先队列是否为空。</p>
<p>优先队列的实现通常使用堆（Heap）数据结构。堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都小于或等于其子节点的值（最小堆）。</p>
<p>C++的标准库提供了一个名为priority_queue的优先队列容器，位于<queue>头文件中。默认情况下，priority_queue使用std::less作为比较器，即按照从大到小的顺序进行排序。也可以使用自定义的比较器来指定元素的排序方式。</p>
<p>以下是使用优先队列的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个最大堆的优先队列</span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问顶部元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除顶部元素</span></span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并输出队列中的元素</span></span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个最大堆的优先队列，并演示了插入、访问和删除操作。输出结果为50、30、10，按照从大到小的顺序排列。</p>
<p>总之，C++中的优先队列是一种非常有用的数据结构，可以方便地实现按照优先级排序的功能。 </p>
<h3 id="集合set">7.集合（set）：</h3>
<p>集合是一种无序、不可重复的容器，其中的元素按照特定的排序规则进行存储。由于采用红黑树等底层数据结构实现，查找和插入操作都具有较高的效率，std::set是一种基于红黑树（Red-Black
Tree）实现的有序容器。它存储唯一的元素，并按照元素的值进行自动排序。</p>
<p>std::set的特点如下：</p>
<ol type="1">
<li>唯一性：std::set中不允许重复的元素。每个元素都是唯一的，当插入重复元素时会被忽略。</li>
<li>自动排序：std::set会根据元素的值进行自动排序，默认使用std::less作为比较函数。可以通过自定义比较函数来改变排序规则。</li>
<li>动态插入和删除：可以通过insert()函数向std::set中插入元素，通过erase()函数删除元素。</li>
<li>快速查找：std::set提供了高效的查找操作。find()函数用于判断元素是否存在，lower_bound()和upper_bound()函数用于查找范围。</li>
</ol>
<p>std::set常用的操作包括：</p>
<ol type="1">
<li>insert(val)：向std::set中插入元素val。</li>
<li>erase(val)：从std::set中删除指定元素val。</li>
<li>find(val)：查找std::set中是否存在指定元素val，返回指向该元素的迭代器，如果不存在则返回end()迭代器。</li>
<li>lower_bound(val)：返回一个迭代器，指向第一个不小于val的元素。</li>
<li>upper_bound(val)：返回一个迭代器，指向第一个大于val的元素。</li>
<li>size()：返回std::set中元素的数量。</li>
<li>empty()：检查std::set是否为空。</li>
</ol>
<p>以下是使用std::set的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并输出std::set中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : mySet) &#123;</span><br><span class="line">std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element not found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出std::set的大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of set: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码演示了插入、查找和删除操作，并输出std::set的元素及大小。</p>
<p>std::set是C++中常用的有序容器，它提供了自动排序和唯一性的特性，适用于需要按值排序并且不允许重复元素的场景。</p>
<h3 id="映射map">8.映射（map）：</h3>
<p>映射是一种键值对存储的容器，其中的元素按照键的排序进行存储。类似于集合，映射也采用红黑树等底层数据结构实现，具有高效的查找和插入操作。</p>
<p>C++中的<code>std::map</code>是一个关联容器，它将键值对存储为有序的集合。每个键值对被称为一个元素，其中键是唯一的，用于索引值。<code>std::map也是</code>使用红黑树数据结构来实现，这种底层数据结构保证了快速的插入、删除和查找操作。</p>
<p>主要特点：</p>
<ol type="1">
<li>有序性：<code>std::map</code>按照键的顺序进行排序，默认使用<code>std::less</code>作为比较函数，也可以自定义比较函数。</li>
<li>唯一性：每个键都是唯一的，相同键的插入操作会被忽略。</li>
<li>动态插入和删除：可以使用<code>insert()</code>函数向<code>std::map</code>中插入元素，并使用<code>erase()</code>函数删除指定的元素。</li>
<li>查找操作：通过<code>find()</code>函数可以在<code>std::map</code>中查找指定的键，返回一个指向该键值对的迭代器。</li>
<li>迭代器与范围遍历：可以使用迭代器来遍历<code>std::map</code>中的键值对，也可以使用范围遍历（range-based
for loop）来遍历整个<code>std::map</code>。</li>
<li>元素访问：通过<code>[]</code>运算符可以直接访问指定键对应的值。</li>
<li>大小和空判断：使用<code>size()</code>函数可以获取<code>std::map</code>中键值对的数量，使用<code>empty()</code>函数可以检查<code>std::map</code>是否为空。</li>
</ol>
<p>常用操作：</p>
<ol type="1">
<li>插入元素：使用<code>insert()</code>函数插入键值对到<code>std::map</code>中。</li>
<li>删除元素：使用<code>erase()</code>函数删除指定键的键值对。</li>
<li>查找元素：使用<code>find()</code>函数查找指定键的迭代器，若存在则返回指向该键值对的迭代器，否则返回指向结尾的迭代器。</li>
<li>访问元素：通过<code>[]</code>运算符访问指定键对应的值。</li>
<li>迭代器遍历：使用迭代器进行遍历，并通过<code>first</code>和<code>second</code>成员来访问键和值。</li>
<li>范围遍历：使用范围遍历（range-based for
loop）遍历整个<code>std::map</code>中的键值对。</li>
<li>自定义比较器：除了默认的排序方式外，您可以通过传递自定义的比较函数给<code>std::map</code>来定义自己的排序规则。比较函数应该是一个可调用对象，接受两个参数，并返回一个布尔值来表示比较结果。例如，如果您想按照键的降序进行排序，可以使用<code>std::greater</code>作为比较函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string, std::greater&lt;<span class="type">int</span>&gt;&gt; myMap;</span><br></pre></td></tr></table></figure>
<ol start="8" type="1">
<li>键值对的操作：通过<code>[]</code>运算符可以直接访问指定键对应的值。如果键不存在，则会插入一个新的键值对，值为默认构造的值类型。需要注意的是，在使用<code>[]</code>运算符访问不存在的键时，会插入一个新的键值对到<code>std::map</code>中。因此，在访问前最好先判断键是否存在，以避免不必要的插入操作。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap[<span class="number">1</span>] = <span class="string">&quot;apple&quot;</span>; <span class="comment">// 插入键值对 &#123;1, &quot;apple&quot;&#125;</span></span><br><span class="line">std::cout &lt;&lt; myMap[<span class="number">1</span>] &lt;&lt; std::endl; <span class="comment">// 输出 &quot;apple&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="9" type="1">
<li>迭代器遍历：可以使用迭代器来遍历<code>std::map</code>中的键值对。迭代器类似于指针，它指向容器中的某个元素，可以通过解引用操作符<code>*</code>来获取元素本身，或者使用成员访问操作符<code>.</code>来访问键和值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"><span class="comment">// 插入元素...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历并输出std::map中的键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10" type="1">
<li>范围遍历：C++11引入了范围遍历（range-based for
loop），可以更简洁地遍历整个<code>std::map</code>中的键值对。范围遍历会自动推导出迭代器类型，并以只读方式进行遍历。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"><span class="comment">// 插入元素...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范围遍历遍历并输出std::map中的键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11" type="1">
<li>时间复杂度：<code>std::map</code>上的插入、删除和查找操作的时间复杂度为对数级别O(logN)。由于底层使用红黑树作为数据结构，它能够保持平衡并保证这些操作的高效执行。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">myMap[<span class="number">3</span>] = <span class="string">&quot;cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并输出std::map中的键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element found in map: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出std::map的大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of map: &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码演示了插入、查找和删除操作，并输出<code>std::map</code>中的键值对及大小。 </p>
]]></content>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C可变参数函数</title>
    <url>//posts/2618594765.html</url>
    <content><![CDATA[<h1 id="c可变参数函数">C可变参数函数</h1>
<p>在做操作系统原理的实验时，发现了Linux
Manual中有函数的原型定义是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>可以接受任意个参数，其中 <span class="math inline">\(\cdots\)</span>
表示可变参数列表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, ... )</span>  &#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 func()
最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数是
int，代表了要传递的可变参数的总数。</p>
<p>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h
头文件中定义的。 使用 int 参数和 va_start() 宏来初始化 va_list
变量为一个参数列表。宏 va_start() 是在 stdarg.h 头文件中定义的。 使用
va_arg() 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end()
来清理赋予 va_list 变量的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>va_start(ap, last_arg)：初始化可变参数列表。ap 是一个 va_list
类型的变量，last_arg
是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap
指向可变参数列表中的第一个参数。</li>
<li>va_arg(ap, type)：获取可变参数列表中的下一个参数。ap 是一个 va_list
类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap
指向下一个参数。</li>
<li>va_end(ap)：结束可变参数列表的访问。ap 是一个 va_list
类型的变量。该宏将 ap 置为 NULL。</li>
</ul>
<p>没用过，你们下次试试。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git回退版本</title>
    <url>//posts/1452544539.html</url>
    <content><![CDATA[<h2 id="git回退版本的几种操作">Git回退版本的几种操作</h2>
<h3
id="场景当我们在使用git进行版本控制时可能会遇到以下几种需要回退版本的场景">场景：当我们在使用Git进行版本控制时，可能会遇到以下几种需要回退版本的场景：</h3>
<h4
id="场景一如果想将代码恢复到之前某个提交的版本且那个版本之后提交的版本都不要了这种场景常发生在合并分支时合并结果不符合预期就可以使用-git-rest恢复到一个旧版本并且旧版本后的都不要">场景一：如果想将代码恢复到之前某个提交的版本，且那个版本之后提交的版本都不要了，这种场景常发生在合并分支时合并结果不符合预期，就可以使用
git rest（恢复到一个旧版本并且旧版本后的都不要）</h4>
<ul>
<li>原理：git reset
--hard命令会将HEAD指针、当前分支指针和索引区都移动到指定的commit
ID，从而重置工作区为该版本。</li>
<li>操作：<br />
1、查看版本号：<code>git log</code>查找历史或使用<code>git reflog</code>命令查找合并操作的commit
ID，也可以上代码托管网页上查看history，找到需要回滚的目标版本号<br />
2、
使用<code>git reset --hard 版本名</code>命令将版本回退。此命令会将HEAD指针、当前分支指针和索引区都指向指定的commit
ID，并重置工作区为该版本。<br />
3、使用<code>git push -f</code>提交更改，此时如果用“git
push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧，用“git push
-f”强制推上去。</li>
</ul>
<h4
id="场景二如果我们想撤销之前的某一版本但是又想保留该目标版本后面的版本记录下这整个版本变动流程就可以用这种方法恢复到一个旧版本并且旧版本后的都保留">场景二：如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。（恢复到一个旧版本并且旧版本后的都保留）</h4>
<p>我们commit了三个版本，突然发现版本2有bug，想要撤销版本2，但又不想影响版本3的提交，就可以用
git revert
命令来反做版本2，生成新的版本4，这个版本4里会保留版本3的东西，但撤销了版本2的东西。</p>
<ul>
<li>原理：git
revert命令会生成一个新的提交，该提交会包含撤销指定提交的更改，从而达到回退版本的效果。</li>
<li>操作：<br />
1、查看版本号：<code>git log</code>查找历史或使用<code>git reflog</code>命令查找合并操作的commit
ID，也可以上代码托管网页上查看history，找到需要回滚的目标版本号<br />
2、<br />
（1） 使用<code>git revert -n 版本号</code>反做<br />
注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add
文件名<br />
（2）提交，使用<code>git commit -m 版本名</code>提交<br />
（3） 使用<code>git push</code>推上远程库：</li>
</ul>
]]></content>
      <tags>
        <tag>工具使用</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法详解</title>
    <url>//posts/1170831533.html</url>
    <content><![CDATA[<p><strong>KMP 解法</strong> KMP
算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「<strong>原字符串</strong>」中找到「<strong>匹配字符串</strong>」。
在朴素解法中，不考虑剪枝的话复杂度是 O(m∗n) 的，而 KMP 算法的复杂度为
O(m+n)。 KMP 之所以能够在O(m+n)
复杂度内完成查找，是因为其能在「<strong>非完全匹配</strong>」的过程中提取到有效信息进行复用，以减少「<strong>重复匹配</strong>」的消耗。
你可能不太理解，没关系，我们可以通过举个例子来理解 KMP。</p>
<span id="more"></span>
<h1 id="匹配过程">1. 匹配过程</h1>
<p>在模拟 KMP 匹配过程之前，我们先建立两个概念：</p>
<p>前缀：对于字符串 abcxxxxefg，我们称 abc 属于 abcxxxxefg 的某个前缀。
后缀：对于字符串 abcxxxxefg，我们称 efg 属于 abcxxxxefg 的某个后缀。
然后我们假设原串为 abeababeabf，匹配串为 abeabf： <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820185990.png" />
我们可以先看看如果不使用 KMP，会如何进行匹配（不使用 substring
函数的情况下）。
首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。
首次匹配的「发起点」是第一个字符 a。显然，后面的 abeab
都是匹配的，两个指针会同时往右移动（黑标）。 在都能匹配上 abeab
的部分，「朴素匹配」和「KMP」并无不同。 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820206345.png" />
直到出现第一个不同的位置（红标）：</p>
<p><strong>接下来，正是「朴素匹配」和「KMP」出现不同的地方：</strong></p>
<p>先看下「朴素匹配」逻辑：</p>
<ul>
<li>将原串的指针移动至本次「发起点」的下一个位置（b
字符处）；匹配串的指针移动至起始位置。</li>
<li>尝试匹配，发现对不上，原串的指针会一直往后移动，直到能够与匹配串对上位置。
如图： <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820227329.png" />
也就是说，对于「朴素匹配」而言，一旦匹配失败，将会将原串指针调整至下一个「发起点」，匹配串的指针调整至起始位置，然后重新尝试匹配。
这也就不难理解为什么「朴素匹配」的复杂度是O(m∗n) 了。</li>
</ul>
<p>然后我们再看看「<strong>KMP 匹配</strong>」过程： <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820242235.png" />
首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820263085.png" />
跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始。</p>
<p>到这里，你应该清楚 KMP 为什么相比于朴素解法更快：</p>
<ul>
<li>因为 KMP
利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。</li>
<li>因为 KMP
的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）。</li>
</ul>
<p>第一点很直观，也很好理解。
我们可以把重点放在第二点上，原串不回溯至「发起点」意味着什么？
其实是意味着：随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在<strong>否决一些「不可能」的方案</strong>。当我们的原串指针从
i 位置后移到 j 位置，不仅仅代表着「原串」下标范围为 [i,j)
的字符与「匹配串」匹配或者不匹配，更是在否决那些以「原串」下标范围为
[i,j)为「匹配发起点」的子集。</p>
<h1 id="分析实现">2. 分析实现</h1>
<p>我们分析一下复杂度。如果严格按照上述解法的话，最坏情况下我们需要扫描整个原串，复杂度为
O(n)。同时在每一次匹配失败时，去检查已匹配部分的相同「前缀」和「后缀」，跳转到相应的位置，如果不匹配则再检查前面部分是否有相同「前缀」和「后缀」，再跳转到相应的位置
… 这部分的复杂度是 O(m^2)，因此整体的复杂度是 O(n *
m^2)，而我们的朴素解法是 O(m * n)O(m∗n) 的。</p>
<p>说明还有一些性质我们没有利用到。</p>
<p>显然，扫描完整原串操作这一操作是不可避免的，我们可以优化的只能是「检查已匹配部分的相同前缀和后缀」这一过程。
再进一步，我们检查「前缀」和「后缀」的目的其实是「为了确定匹配串中的下一段开始匹配的位置」。
同时我们发现，对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。
举个🌰例子，对于匹配串 abcabd 的字符 d
而言，由它发起的下一个匹配点跳转必然是字符 c 的位置。因为字符 d
位置的相同「前缀」和「后缀」字符 ab 的下一位置就是字符 c。</p>
<p>可见从匹配串某个位置跳转下一个匹配位置这一过程是与原串无关的，我们将这一过程称为找
next 点。</p>
<p>显然我们可以预处理出 next
数组，数组中每个位置的值就是该下标应该跳转的目标位置（ next 点）。</p>
<p>当我们进行了这一步优化之后，复杂度是多少呢？</p>
<p>预处理 next 数组的复杂度未知，匹配过程最多扫描完整个原串，复杂度为
O(n)。</p>
<p>因此如果我们希望整个 KMP 过程是 O(m + n)的话，那么我们需要在
O(m)的复杂度内预处理出 next数组。</p>
<p>所以我们的重点在于如何在 O(m)复杂度内处理处 next 数组。</p>
<h1 id="next-数组的构建">3. next 数组的构建</h1>
<p>接下来，我们看看 next 数组是如何在 O(m)的复杂度内被预处理出来的。</p>
<p>假设有匹配串 aaabbab，我们来看看对应的 next 是如何被构建出来的。 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820293368.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820303193.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820313925.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/KMP算法详解/1682820328878.png" />
这就是整个 next 数组的构建过程，时空复杂度均为 O(m)。</p>
<p>至此整个 KMP 匹配过程复杂度是 O(m + n)的。</p>
<h1 id="算法实现">4.算法实现</h1>
<p>用KMP算法实现查找子串在原串中第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// KMP</span></span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = needle.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// next数组,pi[j - 1]为当i与j不匹配时j应该指向的位置</span></span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// needle内部构建next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        	<span class="comment">// 这里当i与j对应的值不相等时，通过next数组将j回滚，与暴力（直接将j = 0）不同</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; needle.<span class="built_in">charAt</span>(i) != needle.<span class="built_in">charAt</span>(j))</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 这里注意：当i与j匹配时，j应该+1然后赋值给pi[i]</span></span><br><span class="line">            <span class="keyword">if</span>(needle.<span class="built_in">charAt</span>(i) == needle.<span class="built_in">charAt</span>(j))</span><br><span class="line">                j++;</span><br><span class="line">           	<span class="comment">// 当i与j不匹配时，直接将j赋值给pi[i]</span></span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// haystack与needle之间进行判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack.<span class="built_in">charAt</span>(i) != needle.<span class="built_in">charAt</span>(j))&#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.<span class="built_in">charAt</span>(i) == needle.<span class="built_in">charAt</span>(j))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m)</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Leetcode 1668. 最大重复子字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRepeating</span><span class="params">(string sequence, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = sequence.<span class="built_in">size</span>(), m = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// next 数组，pi[j - 1]为当i与j不匹配时j应该指向的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; word[i] != word[j])</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(word[i] == word[j])</span><br><span class="line">                j++;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>; </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; sequence[i] != word[j])&#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] == word[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">                    f[i] = (i &gt;= m ? f[i - m] : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 这里将j指向pi[j - 1]，不影响i的遍历</span></span><br><span class="line">                    j = pi[j - <span class="number">1</span>];</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX数学公式的输入</title>
    <url>//posts/1573833940.html</url>
    <content><![CDATA[<h2 id="行内公式">行内公式</h2>
<p>行内公式通常使用<code>$..$</code>来输入，这通常被称为公式环境，例如：若<span
class="math inline">\(a&gt;0\)</span>,<span
class="math inline">\(b&gt;0\)</span>，则<span
class="math inline">\(a+b&gt;0\)</span>. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若$a&gt;0$,$b&gt;0$，则$a+b&gt;0$.</span><br></pre></td></tr></table></figure>
公式环境通常使用特殊字体，并且默认为斜体。需要注意的是，只要是公式，就需要放入公式环境中。如果需要在行内公式中展现出行间公式的效果，可以在前面加入<code>\displaystyle</code>，例如：设<span
class="math inline">\(\displaystyle\lim_{n\to\infty}x_n=x\)</span>.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设$\displaystyle\lim_&#123;n\to\infty&#125;x_n=x$.</span><br></pre></td></tr></table></figure> ## 行间公式 行间公式需要用<span
class="math display">\[..\]</span>来输入，笔者习惯的输入方式如下：若<span
class="math inline">\(a&gt;0\)</span>, <span
class="math inline">\(b&gt;0\)</span>, 则 <span class="math display">\[
a+b&gt;0.
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若$a&gt;0$, $b&gt;0$, 则</span><br><span class="line">$$</span><br><span class="line">a+b&gt;0.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
这种输入方式的一个好处是，这同时也是Markdown的语法。需要注意的是，行间公式也是正文的一部分，需要与正文连贯，并且加入标点符号。
关于具体的输入方式，可以参考<a
href="https://latexlive.com">在线LaTeX公式编辑器-编辑器
(latexlive.com)</a>，在这里只列举一些需要注意的。</p>
<h3 id="上下标">上下标</h3>
<p>上标可以用^输入，例如<code>a^n</code>，效果为 <span
class="math inline">\(a^n\)</span>；
下标可以用_来输入，例如<code>a_1</code>，效果为 <span
class="math inline">\(a_1\)</span>;
上下标只会读取第一个字符，如果上下标的内容较多的话，需要改成<code>^&#123;&#125;</code>或<code>_&#123;&#125;</code>。</p>
<h3 id="分式">分式</h3>
<p>分式可以用来输入，例如<code>\dfrac&#123;a&#125;&#123;b&#125;</code>，效果为 <span
class="math inline">\(\dfrac{a}{b}\)</span>
为了在行间、分子、分母或者指数上输入较小的分式，可以改用<code>\frac&#123;&#125;&#123;&#125;</code>，例如<code>a^\frac&#123;1&#125;&#123;n&#125;</code>，效果为
<span class="math inline">\(a^\frac{1}{n}\)</span></p>
<h3 id="括号">括号</h3>
<p>括号可以直接用(..)输入，但是需要注意的是，有时候括号内的内容高度较大，需要改用<code>\left(..\right)</code>。例如<code>\left(1+\dfrac&#123;1&#125;&#123;n&#125;\right)^n</code>，效果是
<span class="math display">\[\left(1+\dfrac{1}{n}\right)^n\]</span></p>
<p>在中间需要隔开时，可以用<code>\left(..\middle|..\right)</code>。</p>
<p>另外，输入大括号<code>&#123;&#125;</code>时需要用<code>\&#123;..\&#125;</code>，其中。</p>
<h3 id="加粗">加粗</h3>
<p>对于加粗的公式，建议使用bm宏包，并且用命令来加粗，这可以保留公式的斜体。</p>
<h3 id="大括号">大括号</h3>
<p>在这里可以使用cases环境，可以用于分段函数或者方程组，例如 <span
class="math display">\[
f(x)=\begin{cases}
    x, &amp; x&gt;0, \\
    -x, &amp; x\leq 0.
\end{cases}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">f(x)=\begin&#123;cases&#125;</span><br><span class="line">    x, &amp; x&gt;0, \\</span><br><span class="line">    -x, &amp; x\leq 0.</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<h2 id="多行公式">多行公式</h2>
<p>多行公式通常使用aligned环境，例如 <span class="math display">\[
\begin{aligned}
a &amp; =b+c \\
&amp; =d+e
\end{aligned}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp; =b+c \\</span><br><span class="line">&amp; =d+e</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵和行列式">矩阵和行列式</h2>
<p>矩阵可以用bmatrix环境和pmatrix环境，分别为方括号和圆括号，例如 <span
class="math display">\[
\begin{bmatrix}
    a &amp; b \\
    c &amp; d
\end{bmatrix}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">    a &amp; b \\</span><br><span class="line">    c &amp; d</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
如果要输入行列式的话，可以使用vmatrix环境，用法同上。 <span
class="math display">\[
\begin{vmatrix}
    a &amp; b \\
    c &amp; d
\end{vmatrix}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">    a &amp; b \\</span><br><span class="line">    c &amp; d</span><br><span class="line">\end&#123;vmatrix</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>LaTeX的使用还需要一定的熟练度，仍有时间的读者还可以考虑：</p>
<ul>
<li>试着用LaTeX抄几页书籍或者写几页文章，增加熟练度；</li>
<li>配置Visual Studio Code上的LaTeX，探索效率更高的编辑器；</li>
<li>研究如何美化排版，或是使用网络上的精美模板，让排版的效果更好。</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题</title>
    <url>//posts/269057526.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="96127a1fe6ed3353a5ae487b1d8655b057baae3b18eeff5bc804ed58428fecc7">4ddc16f5a2dfffa938af489a2218ca07a5c6eeb9357d0e277f3e803b9f324d919c5fa380256a4cbfcd915bf9b3fceb43e7b2469140abcd3ff6ddaca1e4e827b0d8a9877ada1a61fcb492863b9c2d785e362b283c563b96bd4b47adfaf9bf5dcaf4ed6ee1dbc11793ffba9e69db26449c358d08c38a58409c772a50c8fabb7e27a4c6d84338c1e65c30b2a79e9c9a249ec862c2d70859fc92335d7c9301e4acf7e9dbce6036b7403800e5d656adba0ee5b48077f28a80e841cac0912f50856ed6680eb146a2969069791a1ac828b6ed514cd96702348f8d82b1885ffcb56f12800dbdd502bac59fcf0897b1bf807f1455c7ccff9d4167f033cee1e2fe399e4552ec83f56aa87069d13f9738c2213622fc46ca7c14879336a8938c5445e31bcad26e65e69ccf5c4bc63f300544adfa9babf02b501cc9c4af7d5a02cb10381f60e9a0017e179810030c478694da64f242136c7bbaea5f24fb76a7d7945e12a2a35801f5be6d4e73afbedee9f81efd4139fdd06788cf7522692cb95d4a3c3962525fe86598799a82c8c2b0c219e9835dc782a3e16f05e64ebb408170ed5f1d2da8591e26eaa897d8c63c26a06fcf2264e22517d6b7376179cb9e0756471beafe831c26f14f5118aa1b5fbd050efa92624bb37afc63690376d7111dd488cb2877c5ae41195b67572bf17a93ac9baa1563ebc1f433763ac1737248a4f9718d3b9be391b3a3c826f57c348ca8320cbaa928cd1bcfb6ff3474aa02c7fdb09fdcc6bb99993aac918b8a346edb6a2c68b33380cdc4c75a88be87c8c0336f1204b299786cae8962c7c6fb8cfe7f08ca5405f09f2d5c09fc58804a8008ed070937063fc42c751a0ec13b49ffe48c9292d5d4517dc0c0e492cf138911415b8565b9cd29f7836d831b2c716b9fb407ee62d5460c122baa610b0c49b5aa6c4b3d650141c19662af36f339dd880dfd9eb19c77f3bc71a0820ba8c25d224dcec9b421f409de1473ef0a0deea1d7ea53d2347fff820da6c55f70bfea2b52a201228df66a5209a943aecfc9b9652e535ede60bb5add4bb256f3afc4b07a04f889459e89d16f7f9e10576479e6ef8ed30acc89259bd4c9b603da2a3693f2dbb00e8ba18fff4124d5b5cd6a671985a820c648188eee711d2115fd42fdb039bcd549fc69cbf4418445a7897d4639b9a741c01d054ca7b87c930467791423ba7744f95baf3ab8940d43879d23ddd86ebc3b1b03c9d328334de5eb75174357430b35c449f2bdc6793ca584b4447238bd3d790c03a4a70a281e5cef1d8c88f9ea60346c1122b7a0f50967ca6054944d57c596607d36701ee839805ac639b8918114ad8c2d7ba9d599289e734fec80be1ddc38c5cf3b31f1011b1d5d169e21b14bceb4d5fe064e48207ab5abe91d9c06e04da1bcfcfb2e6482b19f6d4155d53aed8476c44c45e4036091cc2231ae6c044e1608a98b9c537b7fd4ea08e2cd08030c51313dbc25e82690640851f01234739ba6e53f3bfcaec4da9d61a976d777a9260560808bbca90c755dec00473a5c8ecdf424620cf3bc0ac6de0fb2fbbb782d9557df26813bfe11537c2ca8b4832b3406010336789a061bcde6385f9be985d87d22fc5dd3f15651f1868832191184caca14d5c88b42a065be6edd31bd8816cd2a84ceb4407a0a89e9022709d404887c40af4a2b62c2cbd578a06e68881166c16b6a77640101706a3d56e46b81ef195ba30a37adc1e16fe40a643bc37edd97c776e4f71f808ad4a8903b84726a414c9c400b09b65a5ca400164bfaf8fe287e26cf9a84b53049320915260a62359b6a4dda9fd9ede151b40481c5ddfbf0f6b6bb3b64b4066b9837faa96628a28edb38187af6e0f1201d8a87d9f07504503113e7f1a43ac3037f625c3722f2bfe873d41d282a6f89a524bb4b8ea5a8a7a3818e186445ed11c12e35099056aec469b0f8771119726579bf512d954f91ba755f817dd5da18923e1a04a081b6e06292c0d39e3b4e3dcd0f419e8fdaad493a60d4b4959f2d01329e0065615d9bd207f783ce44d127b637b60555371bb9c18fb3ea4d85274025527944cc147a3dfb23e2a3e142154de4358bc065c9107472d0aecf230e4ec00fb5e847e126cdf5c65aebf27c49c21c5e2849d0aee3718ab13aecc4a35c3b2445e0851903cbdba48847ae7b1ad7e7098a9a02dfe0c615b169c20e58ce17ce5a05d97f5c19878cf1f20cc4726e97be91ee4c5ce8dcc7f9bdd7eb3fd9d032b38e7dd089858fc06e7d97c0e4e68205223db21bd55f292cb735b0b961274979aa6fed9333b354f1f8494325b290da640d1922cb7b0b61e013b167784f50cf53eac3f3f3ce4e7361f3e17b0fed90d0c3b8c85445fb09a7862fd9809ccea597aa575d982f9d8b32aa0d6634a40392ba7bf9ef1c037a082509b82afb87a359334a33945e00b35ebbff438047d054248c45d87114e6695fdc7c67c54a6d56ef548bb184f3f0d7ec7aac1f484e065c44a8a63e12c0583191edc3b84821dbbf04b457e1e2a148356f7dc3ce17e7b37e2623a073708ced335d07edb98f1bbb68c6f1146f5c50855ae889cc4c2f9684ad402d9194269208a321f45eab818d6edaa1786c97c614294894fe118439a864b05ac54ef8eee8deb77907909eafacc6511b7bbc446b3ac803af5a9a0e52d170ce555080183ad0672ddc485c505e9bf5340354f7f6338340d87ae95441b8816eec2cf97e4822cfeaf6b5c9a31e47f3a1ed09e3312535629be0c741f82f98b06f373a12481453853d6008bbbe2d11204b2a6a46b84369815a33d61c8a9e74d1d8615505b6c827c36b2c1e9a305ccf4ba3fbb9dce2865be95e63de4b0b940ea49d9e7d26e321e93eb718c808831f8cb67a48d92d5aac00e0ae5b1d0728e84bd572864ad436deef3383848a24fde812e30c450b11278ccda4cf938a7623a16cdd54a01629b44cc38858a65f0d049187014e3092e9e8490cbcf84f2145aefc510eb339e311cca689d4c20cd22319c12aed97de78e5685eba58205defd226d39c0e1a924d871f9b8c0d12aa7ae3879639b9255f915745220844a7608d70ce725f208018de2b7c1a954d217f9f690ebfaf131304be903566ab6934d8290eb06482912ceccd80732aa183fdb85846c7aaa454f516e872b3046d98874c0618f1d8ac4d6ea04b362becd858c49d58376622c2472249949e76a44d3ba64cf947853cb97ca1ac1103c64940294dc8a0308f0f9f9f3d65daffca9ff1b4fa0e5acf6658ae7c33ae9950157ae007a2e1b7ecd25cb180990a7d8006995feb180094098ad598f4480ff4a9d7f270c653da4e4bb30a26213e42f0ded0d4a40750b45e4392e4af33d298d7aaa4923f17f49b618215eaadb8a514418bc21f1e3c9053db309b56ed1fac48c60f8527f1740450908a804d6ba1414ca9fca7e8f296084b27e30a2c9ffe72d3780953df9e30c04e708efdfb6d9aff7add549c25e32fd3980cb6e173b55f170398a637321532bff2982c63b43ab39b4cd2ad8b03f4dcfc3d62e9ae410751d802076d08b4b09df0fb21785f6b9156803a5136d0415353d1917a2aef8fec28caa50f66c569dc08aab5c0f4a3131f0cfeb4d2baa9e97575568fead9d3cdf3516b5ca5dc8ae99df832f902ef8ed79ce115919be614c00dd65c017bb73d39afbd2db2d73d2143f9071db8bbd733abe7302c532b2df830aeb721d84627d3ada5d2cb07755a156b4891e4de02d546d9ed599ed98c512d94fa269fd4e2bc46599c7c574aa65443cd4dac1830f20168581bd6b6f00cb08c6361f6bf1fae5d5cec3548533d41b64f41d2af2338db4a43431b4480aad9400b8df013e4d712ecc147433c70453df8f4b183ffdf71294542934720af0d39171e4b00eb9122c1d91a16c4a29c17f1cef829154b222a4e3b8a0b37ce6d69af0c318a6854e56cd8c860f6526095ab7bcefaefdd8c3e2bf7e968c641c328e6343aefd6e5f9c114e9c3fee47dd5066a487f151122e9af3d46733013c7feeeff4b356bb8af1650e7c7c23b1448c3f18f28051402caa18cf1c6ce0628f684ce28d7c988f48e040530befc3e93f12a6e80dd3cec4bfae8dc3b86de03e187ec15b1d84f8cefaf249cc2e12e39ff5a6378486108aa50e9f91cee98159bdcb03814f2e5939e7d24695b5fe0d1e550f5df1aef92c323d93c3c6ad52e31d56eb3d4bcd56f83a51c43ed4e1dbbf0c26bb8f085659c374b29c581777e55198c56ac8d9c478f3e33a77bea01384c0b6abb5c9cb6f692f40dd96eef29bc2e5cfd9e3d4c194bbe4a816cb785b1d6d5f7055572cdd612e7393b8b8f2597dc5d8aaae5e7498be48e0c2f553dc8775a38d20e965ee11ebafa043332221df48ebc1c1aa212dafe33fb7cc3c8f2b583b0ec14a8f657b10fe198c2ab4b53d6ae290abcb100cfc0c022b98f70532ccdf5906f3587cc19f5c99726ca0c263cf3fc48698c0b3dd026e3487fc1445f9e7912fd9c9a1847239eb7f9dcb14811c3223d6129cae099d9e47483369b590905bcef2b1c65455a142430e602100c837850bc421a3536519fd27e57e0c5ed7881f69b46361af54acce1122d2febcf10fc7ea8d3e26cab526401eeee3a36275910145d29994ab138d452c6e550ff19c4d5cfc2e170ec641287034e7778492cb96c23831476256d2ec2703ecfc3138b082b7274d512cb86f05d6c9acb876dfc03e4856a37fd44122fd73333b3eddee5364fabb693d9da403f36031cfa9de80c8a2f597f3901e709ab734a7387f645b5f52c210718e2f2d6349ee3350c7646ad6d5893c6966946462265349875f6c0c61c0be84315a97f8ef59ce403cf2fb8319ef6642f758982af10bceb05482698bad056d741b6bdcddb0f1035a716bbf1dc4427e804f4fad96242a92f1f7afefc896aaf6edd0f1e012a3b3b3f76dc5a893210882c8bee38f1391da8a2307dc5a4f59bcc7ddd778a9125afd98320f6fd0689273e9edced397c645273fb428365f7f9886bf71eda74ed017e7e1f4c5bdc5e8f345c5c6a6addc9387e57831d6188c903cb7c2e831281aaa61dfa64f5e2d7859eb77308db12fd8ae1587965e8ed810ad1dc12d4783db83d92e6fb436e8d37d5779ce4b97c5573badeb9f495045ba75d36b8ab15ddfb18fdf3b29093424971a931bb9b3151a601764fe9a9e975a6868f54885aaa49410cff56e8ba46fd37a01da3c67c267e7a0ae59cc6fb8a3ebc2422921072241a427f08aab4642dd308ab282007d4fc319da7a39a0c9dad211b15858d07fcfd303220814c48c9af938f01b1d7811883af1089407bcf48f222426398f9c53424348815d0ab950bcb2a483b4538e251f3f760506343af21caa61408b72d322343e78ec37c1214b794173dbf378d92ca434c8108584812d75a293c6b3467accafc24263db19365dd7b91d04a5083f115185b5fb68f2b42aab8631847ab1daede7c670b1aa2301e7dac3c9ad21c83a961602826882bc4cb2e274f38489cb2306c686adc4488050ac41e8711355458b9672a89369b426b84798a715fc4762748483f3496f828266c9b7519fa966500a8201c9ff59d52f1126f52bb9366100e6eecb07805e52ece63836aa5c46e09b293ad28f45fa33b07bfcef5b5a8aa4a1920ba6a8d967864e0ab5003f38aef239c7664fa32174db13fdba5607df87ade5eae34e1f2017a2e6ed8e0916d2ef967054d3ed4d575f13e550f2fb109d8b2f4f460abdda78492f3f3bd5300437d2249bd7b8546acceadba5728a60c46a48c67062b8d719d434111a3143fa11a5905c0147bb01f18613abfbc55e37d7d699ef90b465295c269f541f9fe25b14eda5ccc01b1a61f6efb67bf9d0aec365820d20ad3274d598cb079c254a1d81fd6c6e38e9f9a78fecbd7c23aa7fe1840ae151f1d60394b685591b563989b227a555408a7c523212be724cb2f7fd1a5fef17f1083f3a2b2d53a4858f98b47d208717dad8bffa33e7a4cda2fbf96619d55c2cad26677100c6002d5bab5cce9c9378a006254da82afbb78b1aa9254f2786e48f75d0a2eeb7394dc3a1fc90daa9424172326087f9cb24f27b1e4b82ce8978adb42a3df45bddad6d13e75ae2164dc7730b11fb14b283fec23841c69fa3f612c998ee7e55c3740e486699f0647740b5ae9ebd82311a095ecb6478ed33a00d32d846347d52905880dea094f4ab3481e96adcfb5e422c9cf2da3900d5cd5e334d27d48309de07cdab38909f36ebca5e6b1674b1cd734a341b7dc34407adf7edd29e55a46372b1fc84c01f87ef121fd71522fadea7d392fe9d56ce8beb6326bca6fa5c4f6c668660b8265c157a9f1f0149ef27669ac7ed43c0d956d98bf7edc0bc4c40b9c8ee51a5d5ea8049c1a4daa23a979ac18905733cfafca2d807358ac9c6307ce54631cd4a38babb9ba30a778dd8da54d6c873e7c0bfae525f314a7abc109c2690ce2172dc796f10ba7b64b7b92d13b9c9555548ea2cc3c53c2c922f03c3f6dbf305948e8bf44f782a1660f35188cb541e975104abd529e52e82b6d5a564c0f76b697c20ab075d470610c8496073e812116d6d9886537edc19ed3202f19f6d67ed9d4b90d92b190fd044b1576faf4bd501dcc2500899d4e17cb0238bab8bdfcbe877e96a8db8a2358d5e0dd34fdd39137f8eb7395241987db7c2caad3fd7064ecbdbf710df7610d3c51038945d8d6ee07ac062a96fb3e4460efb35b4f1e0afd0458e8d371f225d6cd3f66cb56495fb35704fd6949a86c26aeeaa00aeacce21946dbe3372fd14b1aaf1f1fb671220de0883d938799c299c01f89fffd48e1ed1c03e2f90a4990dd26096ed89aa09be7512e9d8ef00039953ae0c3c4ee89f9eae15db2c31d795ca1e2c17b9f54f754b5e79325a3350a60d32e549565cf4117c4525634751dad8bf69716da778fcc9cebaf25d0b43466f6b1d12c63168d484ee32c40ba2afd00c84433cb88092241e77c476ba3b5303697dca396a22b0912c6e93d852d14410547149692e7dbc60bcdc50a069663bcefcb7bccce1fbf60df17ca713b0f87bc48e6b89b58e1a374f9b1737cf6102218d21e88ecf79526ca698fb1d5b0799c7382b0636875bbb3acc27aaa85c08fbd3286b8fc9822a71db50337dfb8d691ada8cebab73841991bc695a7a40d7b3aef4d2b334ef055436f718e936e92969bd9065f99da6f3d2d3b86aaaa9c368c41eb7cd13aa6d1f557fa49fea7185c00c43104bdf6e3405fe4b87279bc06f8ca2e1ec6ac12308a4cbdd8e936d3c4508d8a0c0e94bb0a8ef390c198f1a6cfc02fabf6b18fde983596584b13a6cbd8d884d6dbfa6036b37a896092c7a3c5c9c51ea5ed960428974618b1ffa3d196cbee91e003949787b5376fddc1f9237d6a378865b9f0615c40204d1c5ec1a3604ae690dd6bd1833a32b2685fc95fb6247a022070085f91aa26f06b5d2fd736f064c685a6f4055eea0a42ac1dceadeb23bd817bf5bcd46eddd727e2e78035747da22405ec651c4546ebf002fa676e8a5722e0d22992cae6bc4a00a3d969956f7fd913203e33295d4a49ce83fa544108ba21416b88b3f09ad59a93cadcc1478a44e79f255c18bb5c8854a6eb6880cd2e091c9dd822f54b060ef81a9b0d22cda1c557d52aae2cdaa3c71fe18f52b6929dbe0b2e26aab9c8e454bc965c144eecbf0ade598a0e5af9d3f5315b8668154ebba4ec4d39e251c2f466d78c8c1b7989ff029b81d8e562801a739edf03cc40ed93b8e8e3ae0867a6ef7935620b2e92edf8b8f6bde1909eb4274b80bc44c4468f0e0396e4f91a631c20b10e8ae6f908feb8d16a894793ab25e3262d641dd7129bfb37eaecf68d7f21cfa1623337c29175a91ccdfd55ec05aec73416ca968bcc8494d15dea2c4861f56a3088cb65096848323b9205ed785433fb67c30127abb1ab5494a2ed3c449f079a3de3bd297dbf9fb3be9bd06a65e47e187c25b9581520d7e581ae243a56984551359cc68d1631e90a926a9419bbac74d0ea4fb47d8bc6a3d944b44c36af1cebce29497c2744804ade2d57fe9d5555437404f9a1084357012542425e5c27b95af3b569d20d48b11725a8f0036f6c493d2063ea2d9119be7c24e34d054b8ef1d5347ccca6dd3c9bfa7a087fdd9e52368f289517594223b3dffc6468f7892f52c95000de180a6e153bd9c6840d26a0e259ce29140de8bd91618b749aa5881bb3b604ccbea986bb9285453e2e61ed6f460dd397f605462c45db7ee4e48c1f76bafab3efb9b50415f6e02ba0ebb86346d6a0a3fb99cac9f1e7820804a61f3adc17d7420bc713cb51abdb936b6c5a95693e229a53726dd7eebdd33310fd7e7c4040cc72a2fd6c240bae154f8c50d788032ba41efc1e47c97d67e560b49c7b3c459e6e818230aca80d1e0fd18ab1d8bfab1c93eb4ed559ca253dfff192410a7fbde0285cc442e121c7b5ad83ca69acf6dc15832909271da010387a6a8a3814ac54a58f289ae44ff6f0f5573f1fdc73d3cf2ad28116472683efe56ede78e0d5512a6e776f71f68da81798b6d02e7f9d7099fdc0404f6d9330883ff9b7c23f516eaf16cf59cbfeda54873fc9b056a414e5074886c9af8fbc052168d7ee67045ab1aa53474c1ba8be0032c1e0c55de12451794fc57fad05004d429ae6b2f9ac5f454f576600d9f9a85b7d1640bc92b5a3594ecf04b045b0d16eb615ad76488bdb413a660aadde37875062daf40f4f020b8b7b74b7c3281c0d1d9b3e54101e6c44b5ef75d3e5cb2cbfaafd617f8e3413b7b138b420bf0a9c8519937874491a27d4a9abaa54bb12e2d5ae2d592d9167a2f38b5226495336395fe746b5d025b99f12e21479bb63fd82c07feeb8c3523aba778048c0b50b6d35fcc85d21e11cccebf2922fe373d246b20140ddc0d9d54b94773032415978a58bafc2fdf70cf85816e742c8a56c9c2779b73aa92f6f943a49bd5c5549b838dc377c10e75c7565a4d5b19ae0b4c72141ec7e3aebd17250590f3871df334e14ed12bac778288ea6f030951c4ce25ae265b8a75e086f4a9bcd39527453a43994cf05585324ca9f29b72f4dd3e0a183ca408cb17fd4d96de3f102727ae926c89727af0d5a4dd1d9edda98ac09341266265dac574b4bc3051f45febcea5131264f6a7f958461cac4f9247a787e0d9f03593067228524972c4a1ae00f700d861801edc4c23ea1deaa1850e2d02f94439602c4bdd7cd2abc23d80825e31231f1697c6899149268c8f33e99ac97473a73dc95e3714cc8d631e334d3022b9ce4f803644c80599a91f1b17df1b9ddf80043101240952b8cae605e2f0aa10968b0989ebce90d1a298e3566d6c422cd5df05c9689fd377e3beb6f586783b713bd9452b2da15325757903f1a604cb097023ff70b8f0cba988d684a88e676019b6b45b57552bf04bb4ff843c798c63eed896d3568d6a090a10b8157408aed33918247cd80cb51d66bc7b08652bcb27270d8443894ca26410ec9fb187d926960f6044a6474a98772887b059b63a4166e181e45eeaf412397657fe1eb591f3fde9bbcbab4d500bf91c7832c935598f927fb586e844c87241422007d22ed749faf4f2a50851d9ef5b6a63546e786075a750a938436c53ef0ffd92a6f80449615f6c573d398e853c63af6e196d6ed63758859c32bd6a5de5c281a28e7f14c34171ffd6cb187e1f5e6591def5164ea0d1410582e0958d22e5b9f52c734a7aab2c717d9bb0e52783fde64d6831604f12c064704ae33209c5dec20290bba9f386f8788a2d60eb4046f7b347167e6a8d86fe0a03d1592c596bc9051196274af02ab060c04725f678b891eecea8864f9dff3395c42945518453dd845c73d0adf629ffbd4b9995d78295a630dd556b0be680ff2d0107e211724fe2ff17d9b4b766a0e1e74accbf048fc7b3780587645b4b6303839b0f6fafa90dee2e69cd472cbd5066d188ab8359f4a4f9073f65865216b814a53e4eca11f9104066418005f0546181685c969778575ee1da635eb8bb6c52497cc95c0a39c219867293619400a02eedafccc2a50236e4e8d2a76b8c2552123ef2da9ac982a1691cb8bf2a6878e9bdfb5ac31ff88f6de03cec4e8ce5db3ee97af78b7000101defcba041a08d6ebbd05141d5f04cc57aef43adb66b0d38601559471e30cff43322dc2cd619030c21839c37293a019d1a88ee2cfee77630df3677b591ae3f307537d748cb8fac7aa2be9c6b122c01b27d2fa0eb8e1ae459a1929e7c1184bee79e1723193d32bff073d1baf6d048f800b285c49b67de9b50fa8eb4b645a6cccc0ce0abc3576d55aea9c05d8aee83ea13e4dc6bf3fb40a70e9003a3509735e1287f2250cef831b341671c1b1d23ba761ed0e5dc3de82cee4754ad48372c0219c62a7ce321c80c821de1b3e0944bc1516610eebebe1ba7c42ab1dfd36f8560c0a037272bf574bc1bf784b6eccdccd72939881375f35ffcdd677d6abb7472d8957aecaafd9fef8befebf92d570b194d7633245e2cd5c6e79b450efa7c76708590ec0b82ed53a860fb3ae6fb4077105fd4cb129283355b39b1e3c747bb8f94226da1466b548aaac8073ad9c4bbde2bf7fb4bcd4754df454d6fdb99630cc88857a39b02d2f127ba4cce793422e22e7c1677d6c1126113df60b46388fa924bccc4f23c37ff136e7ac8c0d51a9924c0f97b84f67c10114ffb85daec440d59aad93cc3660a18adf917a5d1ac81f4fe560e5d43b966afe78e37ad15e89e981b1ff0061b39e404c44442c6884cdd183cfb2527c3aefffd9988acab1e41bcc32988131a8d456fbfb1bed4aa9726f0be4fefc6bc5f90217f570050ddfe2db09a79c7c6774442830dadfef1c66fa0f184557933bfdb6f3875e16e07370ffa252287d55e7489545951a6e9208fc51e409d2a4ba4e29438d2cba742341258c836c00a8b5c07298c83588af2490911b0a351a11d0645dae9ec0aa83b982857dbe68a0f812317b4f7acc99a20eb0e23f5eb41e10e49101023e0f159d239c77335c5dea21a0e0957b50fc3128a261384ba91fdd0d911b9da8124f5fbd5b04fcf67828b57d3921ce5406b88b81b5e48ee5675c76e6bb4856befd3faf1f1d3d00bb5045a7042ee998ec03d8927097efc67852227b8cec370a7f90360a0a7f2be1f2b7deea80a6b5d00a1f0924a7f5549a9c1b0d795b3059cbff7d2389330344b31c93eec45f438c148bf4907de6924588fabc5ccd6afab2cf4e024cf9464bd4d4eba24c6378ae1abb7809e003dbe8148d223ea17a4f2b20313542d4e5cde5c7d5a591b52156c5c5e7fdb3a84dfc308a96c306123dde726ee01e8a391ed187203679024048cc87489182e07a1015a3c159ec76dcc6b7c2a6eb0cb40619ab96eb82b3d0586ed78e207a4732761093f2983f609792ee70924bd2020a94ea7f776f01aeb6300a60ca7db23e46f6d9c74ee70685cb25da1cdaddd12420a2c4179e227bd19552e4c665ae985772e9d4ed7e0b88e33c3c792babfd497512c93c1f78b1bec81958318263a9ac37c0c1adfdf29df74de3a20993deca3bba8912458be3f7763de45990306fec2d040d89d410c25daf7686d71ba9772519dfacee2f89e1c01dd86faa99a59228c534ed114425ab9db5558e3f8dd2ae547de06cc1cd5e88a10e9f0a5c6df947d8bbed5d13725231da43e9b214bd3a002e0af234375063ef86c4479418fb2edaa2f94cb9c5097652ebcad846f6542fbd43c7a3a25cf8cbf1569cc62b7ebbfd8a721de09190a6c94a8ffdfe251e34cfbdedfd4065ba5ecbe83c55c663a101f455357cdc4812f69bd84b2accbe6bf7afda59495cc91d23382286bc021efa5ed470067ebfe93e2ad10ab245137a8479974221cfc830321b6df80c88cb53f720fdcda579410c83861e69c1b0b8509c5a99247629567ba10a43b437d962c15b7dd166ac061227e7a27135bb6a2426d9dda4959c69044e8230b68008ddc5b29b2684f5f55c967a5ed84f7b8a586db37c696770f44879cb02d26f7fd4e0dedf3fd6ea80ca292f45cf72e11eeacfcfc86a441aae9cb435c0374da8ac380e076117de6f3c440b463777c604f118cf4851bcb0c9cf1c7065ce2e6870d397cdbc0136603cec03329fbad5e269b8f79b678c5c61a04c4f8110ec38a41dbd0e6a94a005bce0bd5f372e7cdb096cb3bee8991585991bc42b1d3d2802b1e0ec5287ab077e2bb7c7ddb580c7e329225a17b055cf69a9b96e0658e921400b3430755da3cea500f6f5618a2dc6cbec16ac38868dddaf75c9c3c09a1fbbd84669915f2e8d715db047fa588a0cdb402766141dc12229a22c2fda9f4285a921ffb546ce764169c31c2a442150a1e6a12276675202894467136c415e51ca68a5a67cc2bfbb511f663dbbbda176395731fa16e0a493761fa5bbacdd9d04608e3bef0631edf2665273cdb24f5162880ddbac91b24e79cde82c7c5fc21894e56ff4eefdee8be59b61d59958d98bde4b0fefc4b957547b4036337fc3a3482fcd3032e87f95a1c87e416f243c4ddd0dad29cba4f5b5fe180041eda709aa9a6c945b6587f3b53e4aaed7d07a31c9436281b8cab63435862a7e372462c54623ca93e2f89bd843d8092ceae9771e8fec69aae2fbe3eefa4cad9f998a53390136b0eda8d84fa338e46ff712724e0c2ee12b4fd124d750cf69f1f1e54bc09495d59d129d5dcbbd3aa51a28480db04f95abc7b3b949deaa17f1f75b80ba694db6ab63359b01851291586e050334cdfa5fd3cfe3fc933793f14cb04cdc0a6125f9fb53b3cddc2af97f9051d315a844766d8595582fe0716c4a1b971bab9a076130ee3de9224d9cbf1793533afe3746fec665a0ba5a9367a3d8eae5eee93d78c5fec1d403cc95cf43cfb108ee5c66677faffff3c29a544ceb6950be3c30f0cf94d1af1ca933e543ad9c6c7b2f4fcaf02893fedf91ac52dd94dba33609644b43c2cdd7bc90775d0a57e768e9dd16ecc0709faee7c950ffaaa1d66a3cde11512654da2ebc6ab4edb24ec585165370b8ee7dbc5b4ff0ee06beaecb2d3fe48db66d40c1f22895cc0e0d48273c16a38027f49b193faf3a135dceda99cf8d0a031eb1d65a2136c92872e1b3a0069c27d4c1bfd9079e2f3c7ed3326c96a11360ac1540a8dffeef6103565683415595e11e49f3eb4061317a239268fc3d17b428a32be4c730630fbf75d8cf0da4b243c104b2cc9a1d90fd534e950814ad09527318a9efe80cb660883a92e01ca0516a9ffafc9b9f405cd222198a7926c9a56ca6594c2c6c06e6e27a496ab64bd5a68b4166d9a372d7b54b0f82e1649d00dc046a3eb059b1381454437ac11e4f9842b68c120082e63a512c3813af5cc5a8d2cb749c7505ac53ccb3a9d57676b5f1ef8f581b6cb05ae675ce1efdb726ae8f310dcc44883917f6cf952d7be816e4bf2b410daa23792fedbaa7062d7e3218d8e57c23e4b3d8c257590e6f45763e2264d19f47696b25c7a2875c82a9f5397abc68da6cddd5b8944311a1a2a39c56a1a07bae6f2671ae1e2a00a66edf4b1cb888122f9e3cd8a7e9664b585f301de7d5326b7a6a1f8be0f4949aa938d2d7107124e53410a69974eae55f6f07bd3ba4d9d94c7703ac02b675413307cbca38ed6cb01d64ebc57bcce1d599fb33c16e050c1d39ab53a73b92e84539f3022d6330afc4a7f925b16857133f9d1c61c7e3ae6fa62cf523a595d276f71ab2edc58d4ef60e05f9d47c6c7f9f72a586db2871c2bf289d2aa5ac37b490aff316cc2cb9acbe0dc0808c9431f28674f4302db4d2f4574e4399a8538c08c6cedf4437c67155e155df6bd53072a3c1d19dc4866ad9788d67b33d86c71cd057f1632bed523fe5f5a912f1e4e9f24e9645acc84dd7317bc5df47afdf2005e7b061f6979a9a99375e27f95c0a5dc69f5d794216ac86ab1c2b850901f88d12e221a86b993c1ebc94670f98a21032cac0eccb7485e916509fd8ac9b294286763c46925d6ba414ec056f27d649595681eae7a457d9c4a6cf18de7b0b863e2bcd9f5384bd5653ab376ab44f491c5d5bf80daef7724642eccf85b097e85f6cb34748c6c107428092ed844ed881f823dad61fbaca80edfc9f44c269f10f5e6db3b3d90b3189ddcd46c80545eab72b76d05f00fa75859cb197d89cb5161b89c41800ae2126711d18dd88b6fc0cc26b2931d20a730357f70061df4e2cce7b4d456042feec3a1bc3d37dd7368d950afa793fae5faf1e1038dacf19d922ac97db37a7dccc19ba7a60540d982a64b0b1b9a15399d4d85e55a81d41cbf9c72d491d590a3116a9cdb4d7a3eb9277f0e68cc350585b69484188cd1002c26e032b0c3204328417808ef9f97344a9a50782fbde0e6a9a40f736cccbbfd58d79b6824fff8789c362323c1652483b6a958c4f0fa0eff3f3a0cde566053889025823206370fd2a9c40f0c0d86d3a1e1c32ffd961ad63426cb1655b7e267f3a2eeb1488e92aa8908aa23d9ed079ec088ce6356cfc40478ddd5e3583edd8c51efc719b325d6cf8b390dc7ba01809f5482782c9e4034b77064efdb4aa2fcebf261711bca7c993b2e191cfee6f38c02af8c287247d06b076fe8cf2a0686672d592ca176e4fcfb6f59fc6ee423319d4dad3d425365f70c0591c638577cd41c8ca665107cded07407f78f28e31a4147a14f66aa13d87c195f8b3f1fa53cc69d44281f6a2edb9e16e047310d21e3f4d5b195c3d6c3b0d419ecdd6b9a5c968715fceaed71dfd2e9527e99d692a5aa7d921a4e84bc2cd03604645a3c9c30b4af1058c15b4fa06c8dde5daf6bf8f89e6495365bbd1adb33440aea4b3ec6f83ead882e33c920fd034c92ebcb13bbb3e203c2552ba28c7337b1ec12d626bff904b2bc145dcb5f818ac3b0f91443d810bedf4555dac1921dd2f92605eb5e8eb623a6e1330103e78a0382fb1e5c95c11ccced2d2f028aa2b2d4e8e0a594570f36c3a74d9b23d400231db3fc906c96f18e8fed7245af6a85c20166f30790277b5126d175a9487894e6335d800760433c4ebd6892bccfc40a9608e0c38c1f0122e6032a75f5cc91ee986253efbd20ed323addee8d621e34ff961cca36e2eac43ae045326a8cdb3d34a7412efe93289af8bff7d51e1921fd2bb881737b6c770ff66c952725ca05c1b393ea6503865906f17c5eda486f0ea1f5a231c464c79f6ae3a0ee7787dadf7424bf15e28ad73a7176f88605b797eaa13c12c9aab0f0f4613f3a185833f3f88a3521e89c57848d894dec083dce469340bbd7849d2ad19ed3c8664da9813d9a6a5202af968baee096c632e977360b2f9323cf65b91769f6b4f84c0dc0ea6791e486cf4b0f2f8e3df431e21cf28de98e2c01aa584bd44f13f834c3ee3e90b1f2495639ef00c3ba291d698adabb54a4fb22a506169bbd5f7595678b4c2bdefac7c98c8580e09ee3a7c8ba89c3e7ebabb42c65244aff53b3a99f6f3e9c7d65d9b712fdd134a2b9a00768f26a27c640dcb9de13b5cca877c97e99cff5450e6d906e44d333bd7f4668d38f642978f2024164a49fe0e48dd49e48d4528c06632b3b4bacabebb8dc64479f1194cee25922fc50ce6a2e771307d571493d67d153413164580a5e701ac00f76c3c2c65ad147b57c748ad10657bfe97481ba1c95487577f166871c0bdad170cb39ffff387444e64d878559d0663b319e20ad2aa6d11958f572a17609a1cf554dc9978d099cf528f9a2343a495d107b74a3b98ff655d8def566ba81aedc85638782330c13eb40e9918d01e809e881b8b33c28ba695dab5bc5a1c7792105d83a6e9ee02e3e1aae7af9ec19ff32a7d56f89063d430f8a72893faac9c7e5010a11bc551272723983d4322b6c6d4882b79763cd2563ed4c2b80f09a6d95907c46e7c026bc1dec04fa9b6c081cfde4ea4051082b2f5b6eb0a6790ab92fda3e3359661db56a93c55fbb1a0c22f698d7b84ba9f1243a498c8d836c3dfec9441d3f18d3bcf0eb714d8708df1f948380231f025331259909332d88f1406b5e38127fccf72ec1b0507e35d520c71d2b6b9235bbc9eac96d782fbe06fcd46c91054cb51cbde77c04e703a92ac1a86562e765afb827b104df993303bda3fdac35c1d5a9623d21165dca4d4d159ae45f2cc13ff3d06ff75a4c99ae0d460f1c17e4ce321b7be6a96600a4582cbd3d77ce1c68a7219e40b3a3db5eba71fa1ee9fe455239f9dec5b16eb33e39d58d309828052e0ab5606d886ab7db9f1df95f3e5bd184aae115b60766f1a31297ef5b6b4502c7daf7ffd3e3408ad5e55d8e5e40afd27672ab56f966d8e7117ee9e37e868fbf4036908ecc152b6a4cb4741cd9226432b27156652b2f2f5ce95620fb6b2d48ac87291325d2b1895d27fbe6364128f2e11fd1456dcd9a8427395b38dc2bfb5b309d1afeeb14efa7eec575c90e2a779bbaa1c97ea059a9a45fa892364621ef7c92719f588bcbdc0b43a7fdbd8a1a64b19608caa731efa805246e3764bd1a4fcd1d505182dcf74039fcbbcefd8a81bdfe208f567203b2f1bcbcc7ef19c905f996e25728d692eb03eccbe30bdb1d86c6365ef198b57fbf4d9a682a9f8007e6bb933bbc11118ae98e80e0560596887c426032997a1cecb94107a12c6a0fda7203b99149a175377de41db1bd582c1325245c939acdb343845e4749175751f4be9d5618246d9e71f4632038d7aa6471ddb60f628ad229af6afe2b9e3c35387b3002969551ebb664354cbf0629c909f0c6305a4f924946716bf8528b8849bd5b7feb99f5a3e9a5745e42f15d66b7a70ab25266df952b55c63c4e81d20497c2f8df3066bbe46fd7515a916f88da79d9fa16e93b6f8151ba3125a53a179985fe2aecbf72425e1916a852dfa1f81204e85ea0c6ad28bc1c42c9d4fa1d3cfe531a388c1916ffb8db4f03ab4aacf122fb27b636fd23e4ac4dded47583b44bd479fb95893272e5040c3dbf25835b7a6eb787ed46cdba13666d993df337a9dc9d95189e42636081219d42008ae3cdd01bf2832e8d1e096839b672b8a0ee9f36dc53515e5ecc99320f37888449e1b596a4568457f4e39caa170d27d1049056d8093937d4b96cd336626e22df8f8e104f5d44f567b0632ac79d915e68b18dca35024657cb32c0c3c97856c24b831037ac6bcf3534a3a3cf8fac40dda8d953654ecbfc3cc2bd56eaa0222525cc384e19a7b9786fd8c5def346d2350212df17237707c7d75be281352c13ce9efe991df400ceb4e974949dc4bf7dedddde7199afdf3967033b725fe8b32017235cae88bb82500bffb5ea7313414024150345098a9a0f5372049e4b740d2c21957c71d1754784269004c5fe379b603bd7d77f20e169ee448182e744e06012077bcb0956cb2e14527be5f17c29829391141d0ff754a78cf577338e7f0c702391e55248907581027fe019b761b2fa6743b8042cdb9bab1bdd737d275ea0bc202467671a0f4b1e305de20e5a7bf377c22344ddd34d0c3c13e75be412fbaf289305a839b3a3c2c26130e53ec61a7ed06b6eec44f021a49920f1c4b418226c513d34a8a98ae517d16abdfc1e7dec3bcae06d68c225ff1e2b1776729dac4501d9aec83ede0a67636fb878d7115ab5f3cd4e9a655d6d613273f51d31258621c99ab8996281585908e4510672b5c0560f1a8955e36a6f57b155f177f3f3b03fe56774ef3cc0ef48afaa3ad09da8cdd541ea256d15696e6acf9c4b96f769ba5cc676772eb61f04c39b341b4c8931122d3445bd3c92ca66e81db59b09acaf8b1ba90621edd8be0d8f722a3c0558c418ff093ee40b7b580d3a90f267b5b3269b30ad73760ccadec10f58f012ce83eb576b1da077e5632a9f83672dae408a9f9165dfeddc191e2a88b5e48202fe674d825594c4568711640253e1d30f5a74e92f0ce0b29cb45723784c3b9988af909548674e2224d099918a189e8d3beb94ed070e8e642492e91a553c565f73434591af264080d529e15d82943eeacffc1868c19e2d7a2d2fed1a8edf85e7a001fa10607b1d45364a070ca7aa388e90301e11b66c48b298eda5615e46a793dc124a7ea38bc2b73b2a4972b79d83b5fe2a589a621ef71b9b3233f14bfd417f4e013d26babdc4ab9c91ae2ad00f2080013e5084bc005eb5cad7cc5f5c9958ff2c5af028fee4347cd70d0b982fc4c1650fb30033c715db86ae8d215d6bcb9b2e8332f0d85ba6a50c6a15c298cd429cb7630988ecd190c7c82c749c8b6ba48189fc03e8fc4d924d5122863da6a5507142c718634e1e9ef78c98730cfacc3612b7bc24969ed4cd93b046c7b7158b67784667b3c32ef5aebc19148622106fd945b48e9b4ad958e9cdebf84ed475f3930c6f6058f96ae03152ef4f49ca52abf2ff6943d5775fdf0ab7aa604b35458a7b1d96d98d303f19f142325c047d8365c7fa79e78504574141cdef9452fcb4577f2bfe38c0f45d35823af298e7315736d40085be5ea18af3e66d562bc63ee30674325d053fb90cec88e7d9897625fc79bbfa562f04db775668de30ae91b32697773b54bbf2cca055d7b7de53f6c79cc0e528e38b44e892d6c12d2a80ed4178cb2bf01b666eea3f73d4430304e87e120a62eb9997132970afdbe357594e912d86c601ae93e95667d72b1fac42ca2bcd43d53e269e9e1eebd3da0c0426af07b29073569d7781f1446e08efaf5515beb9a868e01098b14f005802c0e5544b2b342c3cc05a5471e695f1cdfb6c2a0ba2d1c77d279421eb2baf678423044ce65c82ae1980d8f687ee5ffaa8e66228339ecebb34be44ab68492e9668da37516ac8ca71f352f68a6aeb06fc81982bd74625872bb6c28afc2bcdea343d138339323229c345077b029b2a6318ee5aff490e4a585ca1c9df67568f3a4cadc97749750e8c67b29731b345c43dbe4a822fd17e8561f50f69a241a930e7759a2411b70d3c4f0658a4a030b6d23795ffd536b05582e2bffcaea981007e39305c1ff6c99b23b306920888addf098ed222e0e5ff5a0349258c6518fb04201b27673aae7d20e65581f6dfde0ddc2ad3258ab0e7834757c91e2d5bef579e531d4e19eb0e15b8cf9f5bfce7e272b905de7f4d4e01cd380678165ca16d2e498871fb0d316442ed870c31179a74cccc25ffd555a3e071c6a5eb02cb1fcdd24bf464828df03590e8d79629a46d9efd151db3555f019324ab878d4158aeb39018655606f7842749ba68c009ea4de4ef1769da29290dc9cc95423a74dfbd967cf15e478bf5c8e47ea8ef5ed7fe7dbc79de3790b27b9db0fa3fa42e4be6cf0b8617f0aedbb281fd4b198168f3d42ec7bea31caaba82022875eb7688d8ed4527d8fafffd03934b7ebc8e319d7f41a51081a01704306edc42f5b7d5c02c12c863291a6922f886fb8dafcf68d13d91fbc5fa8ee7b56061fafd1057ad71ae396394218d786d055a54bc454a2596db45e9877f16e1576631a5e73e84a1d3ee7a60aa90563dc3cc2321e0e8fe644a28b175c1d3a7a7900e8e425c48c5587144fdff054d049b6a06efc01bef3b32174b17bbc84cb2bd0fca5864b9897f64d659b5a4f679b84c6dd7d5c575c40f519a2459142c4d9aa0639320c0a9fed955504c24684f009cc8f73e800ffcae4fd91ec2ff987e48c5e1d638ed7f6ee4c0e9deaa415f4fb90f7f3065fbdec5e085daa300a6577a8f2b539372d814bcbe7d77a976c5d7bb06b68f43616aca611e64e4b21a1b84df01b6120a93f4b48cd8a9abedf795441c544dfd666d09ee17cfc0a4cf404d6efb225ee476e733f6ae1d91b479adccaa12eaf21aa15ec97648e3ac6576a05f0083881840d3f84864d8b926b0735c9baec11d1c7faba67645a8beca923d45e44d87a5d7570f458bb737b5d04a451e7c694cabeb24b44822b7277eccb7b518986881e9d50e4457c19b764b1febc90824757ffbea3c1dfe00d0ba3563d93b950dbcee4bf666d6b965502f57eb868a903de2b105e5a8e304b5f211e86ee4ddf222898d7d2534d3d45283fcecdf688a314576e7e453bd62cc1381fe88688538c7e32244548a2c9b6ee6858abc238fb75e7aa8a72dca9ad9bb3a2751a796a2d2f90ae845691cd33c6ca10563a92a3be406b94d63922890973fd40c20bf511eb17ef4f2707b223ae53348edb72353e0b7ba15a21dc5866b635dc08717b997b5bd615ffd373bf851dbf2ca814a05d25779b5e85e6a0a1f83d78514e274f9105f46459a4392f7d3b652dfea148d3789cda10564837f69c62e26a5d815cd469cfb8ec1fdc34f30c354b9d13316ffa6524f4d12048b839f34fba6999cafc3bb0341598a8cfe0645236f891fc2827b102229c9da5063011fe98d7841cd5a04a9bfea4265923733617955cbd846c7fc9d3457ea5afa60a4e5dcb6b0306566508b3f69b12050b14623fec8b08ce4d7fb78baf1464cf8fddadced175e08d9ed369b16db82c2393c2b0f87a386e5b87a9bde820b95f42d5b5511787c434bc3eaf640adad31ed3700d350920225e9cc7e137776fd9b505046b971a5824d8d471ad4f1ed2c39000b0fec2b659474611ae2ed56d650c0a63ab2b7741a972192f1b30c12a322b46104afb9cd570b1a97a7d521c73800dd737d6e78f4a608aabe544c7d9e6c832450952f7cf8b8aa2b24203f4a2bd5b53f7f8a6f2ea38c29138bda5e5082ba728b2fecbb356b6fd114d5a3b8ab9021340dd1a77b034d4dbe564e6b48c4fb6dddc6cf375f396ad7f21338ad972306be0dc8351c10720739b05ce537a77c8002e15ba24ea0f667bd29d7ef39b8c4d646e02cf34715bc51324077cc76f3688a4a097909528c693624c9ed75d8d022b4e1f6142e972bc2bcaa02e735ec642c8c2175b0ccb51a136aa4c3e4bc9f7de301b8250cb11001e230896887ef443339a4d9e7b221a65488c20589565cc4ac8a12f08d46699f743b4789291d62c4bc1874a155c61e28cc7ae91f8fee5f8f45e1ba3648d7c2ece9825470dbe756a6d7d8dcfd7ad1021071650d164fda59d6b0a7eea16b84ae852f1a5d408693cd0935fc06e4850f61657b2241ef4bd77546d8a62e1d51c33f23c11031878ee9e7f0798af5b191c9d3d777cb7fb4ce077b744082b9f9c64b76a83296b6aeb829bb83e927771733cb6e6f0f1ecc0224d963a12810e52acb55dc5a0de5378b260893b609b49db3c78ab86c5f629b6a9ae87a2b097ce70c5dbf6fe8e85f1087a45e2e6d9d645c8ab0915648d4974daa10ebf805443123939705cf7294e982b722ac6ebedf128510221f55bf29da9693e7eb79fae1016513f7462d0e23cfb6c1c8046856f231ad1f28744315c2f12e5232fadebaa82ee03da823d6e878d199be2371ade935271029276f0995c8e42fd360cfa9f812bb38e249fba06e1038413da143357614c0699633b414cbe0b42fc1f3bf7d7f00b25426af20f5d797671dad405b912d5891f8775bf9035fe835ccf56a7f748e0cb949e3d8ca889765e5b9a459de8d249f1aef35cd3b6649240897c8ac8ebee7da88b7e659db1a9b9bbe50365caa332e080608b48cafa366e030ac93cd36be960242066f9abd73205c1821f848c34701bae29878a6e91950ebc59725fa73edac58bf4e6fc1fe0f2b5302a4f52d94f854dbb528d6567ebfd16466373b93169d52aadc410209d958d4df30f8553735a26ee42053101eabcbdd58c0c37e5a050207b07181badf8418c05a7548eaef081f6e309b898bcfe957932ed65b952a685b425fee775501572f6ffd96e643638d7aba4288092a8cd1e1fc3b5ed56e15c8c2b4e67f5a74861a46a5ed867432f425685ae75232f8018830cddd4ec95c1f8c556294f86e4f982019e05bdac4be32edfd9f7ecd40dcfdaecc169004f271984e2c170b371398557ae08b2d453ab72ee8990bb239309b779792fd931bc5b40bb2d1b6ad2d1c62ccb8463c95fd84cd11cc853eb67ed05bd52ea9c31a497ee1dbdea05943d09893c8d3238c7420f15e681c9abb61e55d667c1c59488c110d9a94c8f17615ee7f95a3c9ab29688293f34333b99306778bea8a99f77e0b3ea2781529ae94c34c2c131c3891aa0d7a87e3666bc72f6146e7d216a07c9e91b673deddd1ce222f6b0db541285390c5f7deb430a14110ba9bb2c4947d2dc4f8041c94efa59570cdfd20de40420b5a9ef8b3009ba942fbb4698ffc6a71f56d008386f99629b0ac4dde17bbbb0b92f92cffcc66912936a0158e0173350267f389f9d17d4408192f66d17c507b07f2f87cc546f967119055859db7d0e4c0093f864ad23b1e10dbaa13743581f592d0d511bae1cb52b8daacbd2526993673e39f461ef7740bce0e3171d586873dffab559dcb7d9a926c43b3c319f31adb924e05ca7d3c65a362a6bd9a43feaab724ad21db468ec8a4d9308cac381e718c20c011c0cc6ec7f3bb2f03a30fc63641aff41a7d6be0f1dae44459636531c5d0c7cc6a1b30b2d9f9f9d4ccb163234a6b956ce8533a7bdb209797ec7142a278a9fbfe109ecbf284daaa19fb6ba066230953b0a8a96c349ea814da8d9935bab3b1b27f940919b76672a08d4bc2053858cdf35248ed74d60b5bbd35545259e96735a8d5f75790a066d7af35ff9517f1a869c4e92f8b93a173443c65979b2a35eb38fd24a893f6e426611b5bf10dadb54343b2de51863198d6c90eecf28dbcffd42726d9488f29c3890db77e422d693485f16f3fa3f6fab0e27f747fa0d7749324132f0297eff6aea8fd90d5a37dbdaa1903baa1c04cf073c924bc9168a7aa602ee81e1814c8b8323223b6c83f52627213245d9004a7942ebde45a6425068a47f9b63815e3308dac7c0548819be2197b2ec4c2843e5f40e6b83ac7bd226ec74f3a60131d8ec07fdebbf03d13119b7b9fc2647952d137ea68c438c8f945c280252305a91dad904c2fa023c76daad7d8147b680e24d8f1aa29b336ed409cd1354b6a9c2bf60c2f89bd39609d2a2fc48ba1d3f59d08b2d2b525240089eddb0764d3d7be4c68138239d3396781ec5f07b54166a2c38629a5d888d056aa18614b5f73a1da1d7d51a88419c60f46bc23f77ccfbab113ad62d515bf0c0d4a8d6cee0cdc2d88ac9c9025c6ae794c3e03216f4b5843f07c407845fc29e9ac28d75908f1ffca74dbb1e3dec9bcf3e80fae1c916f99db99b480f680557503343790b936852644a0b9eb24cd4d4b2f6f8fd239004e190955dfcf8e57abe9268e7dd2f6bebde1e8856014c652bbf1151ed964bc66c2fcf3bde3a08151eb73b77617c84685ecd92eb8b356a63aa2ea892d5450ed06e47c9b64ccf9bd2512d1a9b89f94b181c5e5cb5041983cdad0d8621db60ec065664ab799d3c78f51621bafb596398e73b06a16504244231550d28af15d32aff809356640520d044f6e755e470e234ce3d63e24903128af4d4a7aeca3002c8dc5dedda3b232db543e6b561e9b13afa7521bb5742cf4593a54377c4f9924de78016e98f64676b8fa6545532abd5bc92f44f791a4e5b1c6f02a8f0dd3873af78ab70e442e0fb396aa915833e7f0571c4d3a46f51cd09f8cd728cc747079625ed029d2501020656a061d007069f990109258c20fc135fd80a431f25958198ca0150becdf0ec4b9f381dc799f927bec0549a167ca2e4817834fde50958b6bfe6ff4a40207fb57c71014122ccb0b6225a480c1100702371681aab12d56bcc86fc58051601f9cdf91af7918c4ae6184c153ad7bd7e1da1d5d12c88f3e0701490ea38f56eff729cf7695bc8ff2df08a910cd50d1a0a18d67462147cc752c54c2e1663d864026d34ae3c8333eb05dd1101f68ef6e7c430fa5dce6f4aaa0d1e20c49f2989a399bafad933cc3b0eaac4138bd306c97ac1dbfca6181b5a63c252622d5ac22fc64dadb2aa9764da5b6d68688b36e601c3bd5e306c51c715f25436e4ca50961cac5b027de63b124d854986115868d696d7d3ccd6be08d411e08b8963efd797228c0fdb37af41c36eb5fb037503769c5273dec44600305c5e02e8e4a70ace5b4daa01d119e20d5f6e36b4253416d8bb32ac8d31782eb87bb9561cf90d6cd2d1aafb38ca11ef7663d7e08101623ffa9937f8e8aaf0bd40b414788ba814207923ce7cc2cc4e633a9ca8c3d3431c7d6e71ab233525f833bc8a43dd94b435a818de33b1edf8a1b6c4dd331f83768f12919d72f6c6e4a35101e6f1d6c2a54a4b95233282048aaad61c44f7b3dda08e1800cc038aec0e8571db5c226ed6128c56dd3f290048b19ce7e7f36f6ee07d5bb86ca21a223c39fbf37421ffa5f7c3d5e2f2574dd8316bdca9ac6b754a3952d494eead4b949889e7725b1e8fa2049ca070d79e8745a577a52c414f5331502558a40028040434b38c9aa57b581a20340121f7c997e0a3093bb05c953254fd4e3e4d124661bac9da28597c007cad3b4c1e7341ee6622e887daff8154b028cec3623250886492827ed6a530066103b630d16d7c8ce7bc20a5ee68cd450662a3ac15b309186bb599ba16597b6038308ee3c384802a766958d3212bffc18edbae4caa11875bfcae6234dfe574b9052435fa6649c5841dea7f096ee24dd7cec5b2ea40a775bf44ce2767085cd08cb4e32346436aec683575b50d79aa6fb6e91bcc52502f273e40288655f0b8161e5a8b81a4597b46a37425f2485271319112b0dd61098187229fd50b220cf65e5ecf4e08cdcd160873ae4385228585998c16e012425d787b3088c00be95466f1afa19b3f182153ee9eb5ffa5c3c44c2837395b90ac5a1cf9407bcb13b1ad83499852375fae92a8214e565b73bc274489ac23ddb914c01409481c0960fc41dd6c0d7a4fe58a1e4863beeaa1ca66ef04eb3223a1d1a67975300ee9906b62c79f88e4f5d16d8b1eb16490f4517753249404392eac95c9d9b0e4d0cdb58d7012242b7ca9f303508099a2243cb09a9dfa469d3b998f98c012be642fb7bdaa56130d332341c80ec78c17bb5448fc80774ab2e28101a8bd9e60c3579202ece9be001e29c457e492f21648a3d58e64b6d6dd26f96d9b1d96570acc2d88ff5961660ba6724427043865d79576f79a9090d85a3eca14de4b7c90ace4a39f4110f86c619c223709250479fac1cc04a39ff5fc289f409a6d36d43a9828b0bb115e3076fb420aa5a62900a1b04f80c91bfdc70f556bae88d23c812a03477670e07fe7e961df17b05aa674e31e370b0f13451db071c06cbe0695de8806d4d153c016f30b55a425c47199f4fea0300c7c944f4d8ca1f454d88303d0fbafed98527f2582037a4588508fbca5c97bdc30e79857d4a7aa464690da8f65b5c7d00c058376d90c674e9f006456336ccf2bbf35110bd475adb98140bd2fd461fd54924b231a81ece7d35292e6236ce21b3397ed40037fabe6911b182297bdb8021b0fe8a266b677386537c5ba709f65b8ec20a0260b476aa533dc95c5a79a9e9b7de95fabdda3f6f425aae1ae9d7b0a07b9bd6e8dc0c676c6c70331231992512fbb45b824addc80ceca7c6bd5f7aae0cd73c517c4c9c48dda42f0c81c9c13691fd591a099925fa2ad56cffddcda8bc2f4920578582e08e000830a841da462c700371038762d4b9e073cfbef2366f35381d25c8f44f90b076f3aaeb4416bb857bd46969fb679d96b1d622584229ce96fda9779eecec0d5ffcbec49339819e349d35a2ab4cef7569f7fcc30c1c992a8d15fbe08a453a062f5fa8fb20f7f1a6983f0e28ae4b6afcd7d79375097e7c56cca9bc822376e33395cc3efe25d942b9d277f66028791a7ee49c71afb7cc53f40656f1b1313108005f2dece5cfc6992887bbf0bd932c0d072b20b0f1e865b6ddd7ff9987d7de92562ea47262c87eb01889555848c69168047936b70f1ae75397d9fca9336ceacb2d08f012ddc42f20d120ff2e465389a84da0140d56b5031ef1e291638a0bcead0bdcbadee4bf538b8686a4124a6b8b0ab1b3df022e7e7031f3cdf67d378022ad96fea1353aaf8229ba38a1a1c81fc43af81c5237c29355bc1b4787f05dbfa8f60bf10f659a38981de87e6b70effc808824e44a399470e161524f4bdc746c965765a1b12ed05944b85bce808970b87ab778359c540da162dbc4d9df667496e06675f78cdd1515c934bf17099a26003eb07c5f8fe148e23f02c50fe849d96e93b70fad0b2cb7090f9b4a2d8b9679237227f54caeaaa4c9c745f0df11482a1a281586206d794055b6c43a7f99a00e15b05cf85b62226f93cf98119ac36e7fc127843cdeb6eabcb6c37935dda3e02887f1e75c7fa5a0343ea87799ee5d887e072b7e72841393a5a53b93a1f5abdea2d0fc352f85951b93b871592c58a6c9ec8512396d8e77e5483207f1cd638bde1c8e01b3d025904f0b8374a8eed62a761aed4da53ceafd99b46dfb75d49ea180a677fbd6dc525f691285629545219e65adf2fa0b04c19d9df0975ab52f216b5fdd9af8fbb7cafe5ae42c14549b6a05e9e1d61b72daf3f5311ede5064c27335583ff18a4d03edff888230a9adba2596c0fa63f516e21d5c983914de23aaa5b6a1a2387b1a1e0c34710f8a6fe18344b0204da197ab687208c2c427c3426052d294988f22591538dda1610743ffa215ec71ee8850d60f53f31f7457075b88b026aeb4d528dfb85d9f121e37e8289ae983c25771c4f8c01f70100d8e8ef63d98a31c1fb3d874a27443022c9c66f08f62cfb793491ff8e863dce5421661bce82ac05a0c1d58bcbaa7279c18121f872e79d7c651794aade515e5f15e4541c604080ecd23ee94b1c0480d4b578ace80d57b30370ecf764b234c1c5576130b45277c061aa092e55f77ff4c385d72e36e1f1929642f614303e8360cda4a0ef92536a0b95cdc318503dc4b6d94b7b1d058202c4f872fac75846f79469ffb86786cea9952651207fb7cc260a09f5dd5525ea8624fec6dc2a4d08209ac5134a9efee9ee6021b8c9d7c013d68913333190be9f7c04b0ffc73a7500fbe2ee3ee49b30038764c9437dff077dfdae5d675a9b8d0c729aa116819bd62b966065ef01a9f5ade0d231e2d9e67ad865101d7abde441ff6cee0317f6475935c379341a890b6783ce46a1c55cee793b7a626e12ee40cde45892ceca33b8d71831b4ba1d09a3f9f64a9bf82886c267ca32e6e9929b1c90ce1abd5daaeb7cbbb4a587298c6a5c72ee3579b331e6592028cd6abdd93eb46bd92402950ab7ff1a835d9a9e134b39b10f0d2ed8ffa5191f61bd8162ea9d5e9f1293dfa2140bc380de02ab9da4dd791256d4fab7fe019e5e7442b729a057c3bf8e0d60004274077e4f3fcb7774c1a679ff3ab54e987236774c3ef9b2749336eb3640f6b9b582c3153c2de6262f1055fddad33cf7721633fcca506ca3732dc4e8a3c6ce74ac5ee9f9c9103415c182ffb37af192c8c122ef230fc7dd783c15a3773c22b95cf46d5e0e4be9352d3ec108ed9937395ccd22f52e9c1ee9d6b76521dc9067010fce4c8d1513e79c195752ad5b8d23c7148d9e8459372800ea6c7d60d8bf3f032bea8c0e4f6200288eb2302eca48a7eb97156f1fd405a2a884d2b5691e4320855e1c43864677f4a92dba621168c9f022d5cb837ba0653d5088eaa47a5c7c1671f1b1745020d9b6afeb3b20c6ebb77bb1c983bd26e5be57caa8ffab01585ecc06cc0664c40c1e84afdae9e5e53faaeee30e67a889dad7aaef366de033f5b48b45000bd8605eb71f1196203e7fd744420dfa5a6e319edb138dbbad574a13d44085e19c7db45e11a372ceb8f745ae066fb4f16d8b8d25199bd433e39ece066f70d953f838bad102d49b0c1045252d59c09c1bb86ad6f9fc364ce6807747c75f5d5e7301ce3619dccad2dc3480341bd73d18c8c111e77ccf889f3ed5eaaea31740832dc553b4da49762e91c7397ebbeff3850c0e0c30eee69e00496b3ff2b01d543bb1aa3d1c53dade84310ef351aaa7be671a2a638be0e2025832fdc9b045d59c0eaa10a3e1b99ef83c6e09e7d440c8775251e12c8f073af947db10d5788d7d1aced47a564f3ba326d384e2883b36e42f578dd122d7e7945852cb4bfd28dad90b9fd341335b888d7c9c66ac475d72b3036430ef89147e0ab4b1177c86c5ded6167190e049f11c1fe4d34c17a32ac34ff9b239b6bc73428cf453222798599219e6afbfd876d8d7907f56ad51bb9da2e9d9a2fb39e91d7baf74c42969e4168939dd8252e6aade54b9a1240a53b964e9eac669ff3e2c42fa9b11b88fae0a45feba5a2728bd619ad5c3f76d28581d6d996bf18223b35fc29fee3986d34df812b55d4dd931d15d3df9602a66c8d434c35491744ac8ff5c4a64078b3e342d7db3cce1362e6249dc17a01065865b405460027486197dde9d542455b6b0c1c3593fc794aff1e5a63a6d16eb790458730b58eb31b7b93dbe672e1246554a4eec73ab3a86971e160e042f1c8d9615cf74a004a4a786cedca54463b521bea375b46a9e918cbd3a15cdfdf7b8479c80e0d917394f47af0bafdef85c9f08a017030e542afdefbb4d02bf18cbc47007c9d41e665c78c4784c78bb8731dde7445ece4dc240427c827fb6c5618b8d2b16b5d6134e85b5724bf5f27e0ec244c88f940d90c421beb5654e06b3cc31049541f24e93b6f5141bc1545a8a3abbbda18cb8e0ecc6fa01933101acaba99d66df4d6fa8fbc89cda6b4341ad762e43c73e9dc991e95fb2e57e0d72a32cf204a683d0fd23db127355ef2dfa09c78b09b002e13970512748a26765e6bddea9ac1850f21de2bef48345130427a1efbb2fb398d0cf619c3add2349648082fdb624c9ab1844aadc4a025fb490ec6440b54ee0a17b8acc860676b42e1a712ce6982834e4ae222ca72564d108414e4c6c6da1d30a66687f90d05272596f8a5f14230a6bedc3eea53ea42bd3117a4151ce5b84012be2b6914dbc2a70cdbba37d7fd8c1e67c9b1f14973edea4dacbcfad4e7a68a1e1330fdab304d41cf5782015110437ffaafea9f6a6138bc9914b83681eb7cc0ba76d23dde6b60ffc400f79ef5d54bdd9fe5e2a8b34f9de9bc16603c562517169092751d24d72bda932eef9635a3ebadc79516c2a8f5d30988af7a5e30deb0c420b07a410e7aa74604e54145db3fafae86c4fd891d957365ad81b393348e80051da6ed2e53583723daeed5f39f7e4afa6908cb09e298b067ffd8d8a918c6a65ac79f91b1d6fb2a202f3cc8bd4240a99ca5fd3693bb5bc867a5586e78805ef5a69fda199e926f69c0d555c5e7fb75e4a97d26fb58c5bd2b61d81cbeacb84c917e5117a968633b25443fa315d78aaba78f185e27e698500e260b2184a98463b9137d1776900b8091cb2a821e8aa63533912409be7bea6f539fcf1ca5f2f637467ef870892803fa50116731b0427903d99b27a2ba6d970859e6fa91fc43eeb99f918e83eb51cc3a2f6c9b97adc9dc37ebf304b22f26a496706c3cb64f55c64027543f54a7af674e1fd4e1e2fec6baa0cdc6d74042217b463dd89de3bb576b637be3e5cdcbae92efd32edf3bff22ec45e0ea7d11f7a33548a37c4256dd01d6fa2e72888b7f143dc781f5f9807dc4cfd6561a9f64351b78da65a814a98d940f9e7bf2f6f583525f146f7764967c83bb9c5e90675c4006208a9374e29ad360ab77eba1fa9f4f66354f56c14697cead2b33aa6273c1490e4f7a9ee96bbc13a10edf4848e646ddd3b6b6c6ea4b7fb12f5bb9a889642c69e0011e3b6bcfcd4d809b96429054f37dad3a74d5426e4e6ff74384db94d0f9ac4a8dc8ded3c7762431291d61fcb04054a2a61a949fb1f7c7655717cdb12a6fa5f8e635f6fc4ea38cdf3da82c78090224bc8cdbabf3c5bd158b2e5757e288a4495fa90410e25d04ff921b2592f9e90f5e08e0b27f1866fd2117d4bacd3d821ba343133b0c6301bcb3f05d07d576e6cd7ca34172b6655da79a6e331db51622957107f93546a368c360f666db143da3775abc2380af0eed1fa046d7b932365e0d8caa5c89da56a6fb401dd2655c9e903b14d20e3a5d59f9ea6bbd9a3ede67cca9df32d1ade8b4cdd289f7d1eec6025083da6502538ebcef7028c724c91a82fbca2b92e0d77aab54502c27dc7c9154c8a744f6c340b52c0a12c08c50a596e4d76bf19ce27a19408af05a0d415e9367808ccc711af842e17d1e4bc9a3eb808b7bed8f33109460f374d11337980526115ba35dce0614ccde2a6c0a2b7c9c8b9a744b8ea9b609c4e1003bb4ba3fc67bd4beb9648a5482663be3c816c8cd02bf65626b80e4d5c2a0724020a8503364642df024e241dc2871be0aa7e99a3929c2c820b000901c1bd4ac52d38a8efbb73d052f38b7ffd1446514a2976f5d8dfabb28c47b610650f332db457d6ebcb0eee9c26c3c3f0985d74ad92d1458060d1675e710fc7a502a63e345ed4462de5c643dbd152db7672e1a22440bf6a09cf501db0f1014d782309cac99cd50db6018665a3407b4694adb2df5a5da9fc46d280bd76804a44a9596f2b7671531b316e7684c13f87922b9a3a811930704fe665a5b0c810e59f616ddb35ff0473a21b0c54db48d8c5bdcab393581804c9d660d8aebcfa9f8cc0f66b2f1c37ce7feabf041b52397cf0619e8802353e5280b24ec6c524059c5163493e084afb6171892637c6686c48711c83910b9460951da385dc23f620d0ece196c72f641514fbcdd859447dbd29e73badf0c96211beea96e8d79e28abc6ffa742ae066b76ba1e6b68f186db16f65396a677e5d3794b5c64556ff44cf3cfc7a6faa2dd772442f57e6a92a1bc2f1c947333912ba0bf4b0c17121f389ae937382461929a1e6da794dc06146c016d62643766fb0e1ac1744e9299ea3cd40da776e138c13dacc3bb59ca2c45161f61383e69cfdfa03bb089ada1720c1fa5d638ed7a77e5280b42d64493dea506f96e8fa3918d68074187c29e6ecb1f3a92e6eff3f42ff5e1b291c7641c515035f23c5d1ba1192d5288201daa1c12dea772825a1965c460d87cb4133d4827a1bfd987b07ea6290d7b57c7099dfe148e28354167770a56f974365ec103dfdc18dd82ad7b7c4165d23208836cf06d079aeec58d0fe2910961d6cfcdf977fddd62ef95b3046b26471e336652361baf97bfa0886ef75e9e884deeba04bf2338fdebeeaefaea763360531816312568ed208e87ef9649f15097eec48e704ebeb33fbe5fe4722443b26ff13a5f51bb99a843343572766806338cae1c7cd81920d7194567aef6789086804d38eae31e48f55d8096ff137a70aea0855942925c936067dbe2d237ff29a4c873ad488b6235a1eff5b36721fc44013a485b4157ef3344e701e3fd29fa975c184fc08d4b442fa31c4ca30f4ebf8b0a9197efa48cf0d6de2c2ccef8b55146fdc984eb313c45a0d16bac2822c0226ae9f85ecd7555a9d763b8135a2fb0e70948dad936b26808c98a2e9d0f2a8af5c847d9ffaf8c7a46447a71a0677c427a3dd27c66c11901107517bbb38aec4fc8fc164baafd4234d0bd2387a5482eb8583d9767ad2183c745913adbdd598cdcd427d18b364d48a85fe2d9d4b2188dca3c775d41a4519e87fc814b7f4e99cd6b1f2eca1a353ffca83afd1660b87e7ae0bb14d11d240259a7ce1eea183b301de21d7722bfe742c3d91c879df29d7da9109c5a91d7747338d10354d6fa606f31d5445068afb0707ec85970cd1431febc2d857ea63143ee0efae39096116582d3f6387797c4282494bad1e4b06801dd37d4d05cd0b46d313e300b001eba99f18cf73a2cf31ea749ca058816152ca20dee832b14ae704a9529c391c79d9eab3d707a8e966b67ce0b8c8e1c3ccfba298db87f038da8b721b3731de05ada6ea93f468e663ebe1f657c08649fba09e2e8a06b47cf92b5b6826dd6d93a60afd776f5f1ba0ee1356c29cecdddafef0596e88547d039310bccdebd0bbcbac6e4807c17dcf62b9989dccf9cacf8ee6754661f66f3ed1d921bb654c30851445282f3629fd006776d0781cf39097068ad10416e048169c962e39e32f2c0c554b88434f0e99a3cfd1b8e78659893113e3d9b899616c1c6c76497f0360df86406d91bff8174147ffbe71843e76a5573e1149ace56adeb5805d77e8fca6171d106eef57ce57b010ff05982e5aa02a6e2df52f213b99af3328688fe10c5c812c69565104c1c69b185533da6e3999e114be317cc3f76d34b5e0486f06a63620861394a5cee1ef24b40c385d57e0637edd78fdb97265c6650a7552bee5e9fbee1b4c2f6497ac995e42baa7aa9149ac58b896e9af2444c64552bb40d2a050044339ddf07dfe5d2f5e01ac16fcc96ee5db50d69d3572e50a3d1dcef8c5452ce7fbfd9224be7208211e7213ca59b58d0ea6dfc1cee409b7abfc5d3b5c560fb8162255224995404a4d895bcb8ef10f52d55b7cb40f04038bec9df86887247554058022042dffa4b80ef2cd613014c46130826cbb8f486465d9651417c86c0a4a979904f51eb5f040d39f797bb4cf5147211c1b9164c0bd0a9ded03e69c26fab7d57b2f67a35f50514222ffe63d1b1f9d86fd84ed3cd1b21561c84d5b4e3a1661364136e64467a65a575832fcdd5393fe1cd8ab8b68fa8f47da5aa5980e0ec8487ff4015aefda22bad5504dfe5b765cb5f1a10ccfe50af1d0319ecfcb0f50875a733ee607b99f09f97deeff99149682becd2b6da72ddef0e8360f8d82b3998d15e522b6fd60d06b71a54004c9589c9b656c0f4be4b792a660b6987c0fbae2fa018d7e6793c996dcf4512d49359a8c72ab3bc2fb1799b9ab0af671c3be0c52489d20553b95e0ee9a373cca97a56a7009d63a71416adffa13170de9bab0545b96f1ec5df4423a61b305d8a614608de4660d335e8c35e768abc78896913925a10d4a0eb98c0758a942b40314558856c2a9185dad78a991f473f1081257d02624cfd95d37c1d1e0bee1d2be5f93aeee2b0709821f75d29f5518aa83dc1f8d5bd0c74648dc88db819ce570c8e926c0644bd79732d70b47c8ee07d5d96fc8890a40282920f7269422564a066f7a0b65b7fd54c8c7649afec10d1d282eb95304c3f3f256c806329f26a02404b81efd2f2065ed2686865cbb6283d84e217a17040e5ec7eb8ee4408829333703f1fdab6d3d93dc56ab89bad809f2a959880776421ce88049d1ab472be8adcf7e7c3217df6d38835760d1bb075ffb071b25e60a2dfdb06b4f2eb9085f1149cf2277aec9693346409e145d812310f2e1129173dd0a01cab48c5d374f05d079830d3e90afe6544672925a610368f6314dd46467730ee155638fa2a57bde89011b1cce20c63ba1ce49c08cd430863faa7c13d5ec9141b5f3fa7577fdec21d82564a09782ec936d30a4442cee8c1116bf15f28056037c19c36edd448bb85cb8700171c6035b9c6d81e82c10b7e1da2a839bccc56cf90f6126c05a188b23f8effc2f2109975860063a476b87bff4bab3c1bb5555cacff8169fde804a271dd2b4c09281abe809cbddb20077f2f8bddbe030d93ce9ac666badc898befda12ede7933282563de898bc323d9c80c1bf423af0626213f2adba6d68c62b2e25f8697bba71ba08351645dc5ad2e0f86c5ae643129884a888e8979eb8cb8e378d8533cc1235e350778fa41026da32ecbaf1191f899765d89a2de92acd05ca25eb565c0ceb80a5145fd41c6327b3893e5dc11c9a4b370877f036443b1629575ef6e6e41ac9bf1d1cdd14df43ce4e95d7e400cb7e43e0073084b781040096483a47a20a9dbd81978616bf5153b3220db0c0e3fc199e63adfddfa5c969f6d896096d45a1fbfb0fe87e943c506adbcdab2ec5c91e27bc0f10b26653bd83d20e0fdd18aae79f6a25125a3eb6a6b819887afa14bfdabb17470d246a14e3ad0a59b60d351271a76f3a0b5870182801b56efc7f66adf9e09055d5df810d50951764dc8c89e4d037243c5e1dba128d3caffa1eca2f1b06fcd16fbf08ad638d8735b515f87e1ba270689e4c631a63d038192776454a9129025209f8457e861b89daab668d607f1e62a65651c1922c8cfa1790e9bb842204b6fc1ae8f675bb13a435d9b7b5e100cfd63a437869591414c9aa482373c4ecf0e8cd6c64a4def9deb08ab35f359b99203530a2655287168c21f7fedd733cdca7dbfe55c3eb9f27e77ccb65ab3b19d794789b50c0293a51aa8a85a7513bb13fa669c117e773430546456c4df4ec50ce0d56c23603b4b39b27d7f40011ac81693ce47df583367262bf955f94f8f4485c361dd7ccf0ab036af76f7b44b5b22d06c796c095d203e16631eccfccab37fc6a850433b41ba842154d7d3d3fbf63271b7aa48c34db454c21f47fc86b8b535c35ceb3b6f71826954d9fe4ee602b2822f59a08d016cf031f707e8f26b1a976eee3b4bc4ab02d302be44ec4808d51f733b14c4b6409b021d77876f38adde320aef2a44cb751e121e1a5614b5b4feb8567214ca198fd9ff0b85793d476606cca6c6517f9ce77fa3746d624a6b7fec2a44e25d400116b29fb4fea723aa7616539d90d1b4e6b515b1ea468c20aa6d6db34aa55118be4d0f8b4d2bdab140d5c90189a4ac3390900c08fea3557d2979003dd7a4646aca0b9bf8b22bf4beaeff8044ee50dda32e764275c4cd1bf9590c2c423f0d92a79ac65e97aa9e077b67df757eede457580d49f1f9337b775d6ab81c3fb74224acc2ac3ce41c8cf2d55f762e2a92f75abb160a2808fe9bc16f5a67a94e9b0bd9e60d5e600fb71613dc9ef886bbc3648037163b1e28eb840eee7191c32b0c55cccde2eb5f6a17c9241c3902aaaf3a3f48485635aed4877d7a2e2e4ae0b3ad6b8c08421b211cd2972073c2700f8345378434a1235692cc353e08f44b171c8d3c2ee29a32b6c5fd94637a71db09d439da00d826f40f8c9ca0f6bb783b9906883d0245a6cd4375e8d7c97c423744c935a3efee1f2b8cc45ecbfafc694eebfb7667a46c242652e23715b22706b2d57d9b298805024f5c70cdf843ba50a6680d0f52e82d83bd61bb96d53b00b7ccd91897a2cfcad2be1b8a1c76db9d727bb3b344c8972cb5e68118d976db3513513a9f67de8de48bb48a9eebd68d4624fc97551b3bb561cf06b3af014197f6e4eb3e97cef82f7c7e9525e0c73c2214fc5f3b386feac3e53ae94ed9593f5cfec93465f60f05f056f969b0ef122a91d46091b62d07707b44ebf3ef7c1460224bb8d6e51e0e7e654e602ef8b34fa42bb4df173d51b12bf6506fc31be6c686ba2256c5c58e868ce260b0f07dfbdf72473c8d2378a711c38b5e982f03d7752432d17cb80cab810c81ad7291b42a3c44114621f14374ca43eaec470632bcbae2bba9c29e5658dc431819b15ecac4f9e909d2155d88122ccc49acfd5bf0e6294cfd458d11fb0880f3abcb102a113d9f01465b532cf70e4eb48ff9eeb370677e2ec0bc868d7870764cb7f657d2879bc12e0764693681853b11ba35fa506e043715c5c2fe21a6ced5eed071222a02e4c9f9c667374a3dcbd746207fe08aa52cbda2fa7d3023f5631b03c66f1f8dd74f59f68842316721988998dbfa4a8f45938a8000c76b69aa957acc711ff65fec4a06d7c2b941a16a1cea362589c60c3d4fb3b73b67154d756002029f3c95425ef52fbc3c02a4842cca2ca3e83cb37a62912b5a5353bf469cc2ca856f2dae5fe932db44c3ba0fef7d2d8e856fb359362807a2c686df01b81141c2f37a21f9fa032f413c4db39bafec312b963eb200f9adc74fde53a97850ca8dff2e68eeed9099f61fd50dbbc619e9a1d700b2d7c21979a96cbf23371b975359def59bb3bbab5f6a53362b658f49870a108fa4a673ab0805f188f0939ced93105e75ca5bb3c9e73b57e476bbc5379847f1004580051ed90670193280a4b9da23d8ec84bdc3b2ffe74f4cec12cadba08b6da3582f0e9ff617f6a615f6e8d2712ba0a07484aaa9bf8c01e3ff6a041fdcd5f08748e287b037a77dc3a05b26af64c7110449caffceb438a0e6e3aab6c114f462d51ea9b223362cb31cf837c58ed21666cd574786aeab89cac602e7b23f72bfa49e7e24e49e07b78f1b1df9790b9d5fc05fccaa5a8e5a9725a29d17369cc34d7dae39750dd38a918f1cbe67c95cca3301b2e9dfdf603ede1c2b8dd2605ce2d3ac9482a524e53181533fb1271701a35f134d916f7f901473934583c9f5fe00e504ab01c275e88e657da0fe7d378f14a98273a93bdff710a2ca13193ab5c43708c312d8159b6b590a0c95eacff8802f770c0d9fd7ecee7650a5c199000c7c21907449c5acce19e852c53f91a69b247f756b38991982215b6fe48b60c332dae320c1cad05887566beaaa313418f61fc0142cc08faa63f6adaa410532f4119194288442bf142c681fc6c267ff9b7e2ea6b0f4774be87fcd624b83226b859f27bd72dacac2887a8d89721f2e71157cc15ae81a73720b15bcb78f0a9a49307c62056bbdd15e88f217884f1cb4e265964c217610f099b25861bd7ebf37b82bb61b1a9787e6178642b6faf7ce69a15e1eabe57c5e07ee3e3682184ece0de400a814aa98d8314d8f1b3cbcf90278e0286c40b692056b1e176f53836ab9cd354e65f880ca3b0ab4bbf32e1439a1f1276b92e80ae80fb99e4d69acfe3f49e04eea50194f5ada77df002a37cc0244d3602bea1f256086d1bc42e0ce7ec7ce06a81c616dae0bf9cf0dd9ab1e18db79be80d3905f97ff998b121c9ec80d9963245ebd180ffad356ca8357a41a1133fc72024fe9493cd7fdd15d68799c9f04ddcdbbffb310d209863a859352728afb5e594a0ad01bc2345fd07fbef04cb855dce20ea6a7d72567f0f664804f4f9c652b78bd7dfa24b69d43650465cd5ba99f9056e944d3ec3a4bbb54ee024cb714575c93bd82f30003efe818c5ec176c7570772d1a5cfc3b5a62bc77a5bee1a66795961b1db958609ab0887bf5fb9c6ec4d94188f14598cf80f9003651fd11d3709f54abecd81c41c95a601016223506c2c0b37e5db5abbafea00dec65bc371397a6c4f3cfaaeec1fb8b45369a55ad91871cd528725f74a976e0b36554efd3b4677d7acb0177e3bed1852ba84837ccc6b3cde79d14b61ed6ecab9379d9cf9ab2549cad0b707d3cdb8380d4c9a638bcbb0d9758551bb82be69f4cef62532b435ce02aae6e208701b9267ca308f2a9cbd9c66e8e401019c5c8a17712f948a52159e4d89c60eae6da06c96d15342d21dd2dd10eb00f321f2c1b8bde39deb52bbe73a23188c0f55bb90a023df369b4c9022b7411f036436206562bb546901fb5aef20be5925e12fc6e09d77294522ffbe38bbca111295e6f3314cdec98f68a10a3c138ebf433fa8f3d4faf7db44b3b688f0b07ab1abec970e9c4cdbaddbd5aebf73629ef150259a1d676140929e6252c51e5aa7c5bfeef8ce2aaa3de67f7ccacaa54b7d2b6ef4f77c8f8cabeb01def0256ddcfc5f12f3ca4a6fe0f190bc6b83e3fa7b73f028cbffa62df1c3c365ca1140cc2a5ef993eeb8b98ffa920c9ad13714721e5cc493c325133d3274dc21765b49fffc993b25d2a6bfb234edece604214bc196af6e0115f48736d923769e0625eacd0e4677d2a7a09c9317d0e3b9033a6afb2a56978a190a145a3a85a0625bf19e3df98ea81387725267b3792e67931f6ec1baf721fcc2a5c1ab9f483359871aeaa2faf9d8e584a69cb00a6713d990b409ae978184152e84e2e5824d7caebe1535ff5d81fa5c9f91947b614e1fca5913ee3572d5ba275f803d8b37637828e36c466e313482f07cf5881f27de742f26c2ac5906754e68f7df44a8615ef812d79bda099240fcf61c8602aa84f93dd46b2cc7ccc11dbb12923e2d77f75762b249fd531452e4a8f7a8cdda5a1c750df472da88db2db11e9eee56249ed2b971a6d6ae5a55f6659ac002024c70461c1353a69d4fd77ae0334f4d44e57e4486803b90a44158d6f4756c1ba293266458538798fa58fe7133cfe1d9d8b8b980abbaa98bdbf4869e584dcc7efc560c5db015e4095a3a24ba37d274982e477b88804b0c07be7d85cb2117e4d78e95f38327d6e3d429e0fa661cb2af4d849c8ee5f80adb484b5289a9ee763d652b6a70894a89cc0337611e637b8ca54793d352e029f920a59fcdfd4d4452ce35042c9990b8f3497eb8833a62e96ebb986eaaf8359a61fbd51f870fcac21e1d5abc748ca3843d4737af358a3441f6d8ef8f3f8fde17eaa46c50caf82b80e7db560e55276e72ef6354ee106ff6e0a539bbb7ab84ab16609d128b1bf781fa9837d739048a0dc329af02cd98f0b976d3c9c5306d524d77f687796c1fcb3156badcfd3d3909fb9458bbcbaa161c4f802479646f4d857f472db91945d618e870eb9932eaf6339a8ba79f755805f21c823e6b84957a623a1951decf6dc75c6fec10a75e9cc6ae2f1620137075efd03dffa8c07875a140b564a1cd78c0859788269447c2682ff0020d056cab534e7ecca55554a94924f49ce570a2891cdd2f4d1d54da3c21814a7dbd9282c442ffe8d3039e67afcdfc530545bf9518426311642ad9209aaa1aef0db74c165bda181e842b7bbdbabb946b4ee9be81defa4498a7a621b3236bbaaac48108eb5d8a089a7186a5bc0e47ba7ff42dabb23db88c249c43f0bf3e58cae1d8b2d2ad7dc43b8bcf6b233e3dd9449dfa3b48037d6170d4ab75fa6a4684e4977ca4d4b30277f285bbfcb7dc931e11f181753204f4266fee5aacbeb5aa6e9ff939011522d2159afd3082ef2235d15eab0420e00e3a7d2cfe13d422ed83bb04090cbcac4cada5376b3aa250c515e6df97d1bbb7d10e6dee776af6acdbd3ffa0224a0e2ba6c0beff6a5a4f16cbe163841365f90c765d86e9c2e6bacc81ced897076ef4493c95138107ff55e733691b2874af57480b1cf21a0dd21e9ee8dc2d0631fbc6cb6ec2eb3c0bbee59a25f84be616e002c81163c21d6fb64abdbd8a8089ceced1ffe4511187dca017bc5c9ec35f13656f069ba5ac99de709980577cdd7c773d2ac816700e27601747fd17e9b8c0eb345a573ee76197173ae903d65d9ebb61f58966fc93d9ba4d541c9ae3be9f0ff7185786e2f12b0d11dc4c09c7ff897dc69e02b6c471c11e9da2a85e9a2dacce18d30fb052600b09b1a7ab526d09830bd8e7c97f93998fa3e846db8e8696d709dbbf83616289b5ce7ba6de46585338f88fae9385fcf7576f94fd4b1ebd257ad48adaf309562f732f2e18cc68ad9bfa14ce7fca8b8ce8aa15af6e327bf24844cd5f9890152cce4c7996e9c18e7ff3e5170c9fda5fdcf55a1f28f67e7a59218faa8a73e4fb6cf55f3b737a6af91aa2e161f5045a9f67faced9202834a1053ec951836863b507a3e423ade7f79c6fe5071968142f4c06caead6008d37e59e3688ec14f2c618ca9ee5b823b3f7bbdf7eb2c4083f12e703739c3b3521726d37dce39aa6bb43fbe78ff70a7ad819d95919cdb29ec786b2b170c316ed4fe9d9bd21a6010569dbaec3d4d28238110a5dce2b73aa5b8ed07525af2a502b1e480018db6cdd9646659871f4355bad499cf41002726bcecbddc9dce543d6d436d47b961c320625ceae02e9255bb11153cf4b257f2cd22725cc6f88a669ed7c289d429ee02bd584f5b0ddf7f87509918ed7868531c4c12f03b225ce844a4b37c0095505c3cc758ec20603506bde44161b0bca4d8de9af647ee5a147a9cf1578751cdf3b467d589272fb8228e4c452ffdfbd2e7d3a3d4d37c86fde6fd0bdb78010d1c054045a7adf56e50b21c91163e99ab7025188f10d833dbca776b63de43edf0b4535e84971740b85acec3659d72c41a12b4d3dd7db630154e3cc7e42b338e6636a34c12b3e74e6b6c2775831fa779abf2fbba89b47000ba131082521df9d3aa30e58f938f3be33151f4b7c011a5f9affe844aeef6baef010e0dff2a5ac9a559dea7614ea67be3a7c2b5de32b461fe4d523955f2c6378d4468658633e12f3bd77fbe02cdf57d84a079ae214624154b9411c3cfae3fff5260643e953c99208c7317c2e5bcca03c2bf455aa0d9329a31e4e54f41fce41cb86d2d6e3da82b3ad85cb0e8f4c57be33afa61f069063eb87714beffe7b87df2a76e98b5e158c0de7b11cab79230bbb423e2d095c357d57865257724134059719f59bd139b44d7e9018e9abc3281f2d0eb15aa18a5b55f13d8a25b0bcc61abe6233667fbc00c78be905ddf1915e2d90efef5c38f71a82bdfbd5a4aa8a13d8b80a55c007b8999cd8256fa89bc51139d7daad02af05b1ed42e42c4bc165619109f92f29758db28ad9ee1e6fff9ada791b23ee339fb79b2b613a6fbd5b309e0743e334f61cbd74ed94efbfb8c5b1e6304081d59e68c6008c0181da9680d7410c478bcef80c5efe9921432b58f9f4a5ea14b6aafb3687b68118f85d7eae7477471c7f5174f5f2924652ded4c3e14a935e6c8a59a67c3e08c1a9d267973920e4be561f1a7bf8a8992def0420e6dc407decda9e8259341d35404aa6dfeadcd1bfb224b2fbf41ca27cefb1aaebd9eafacae45b9a75ba109b08d296afc45022d4d82307ed315a5593b41b6d6ea2bd8a4e3f4cef4b50fc11495226a8921198f41299b1785e180e3454c2e033596adfa4b3e48b2979c2bb2855dfb06314cf646438aa77c4a08a72144984045d41a8a1186a808ee26e02a126c7190b63b0a06a7b4d9964f515496c7a3d4e9c6d0c3c4260c9bb6fc6e3e9d12d9d1da4952e46ea89910b4d8a5cb43e0707f4405efc15c59ada85fec1913692458daca333590f351c13686bec4f66dd13cad7ea04ec255cb3c004ba95f33aa929437292e6a379f3a1da90bd4f4e6b606334fdef5f268521af5a7e953eb9c52807530b7ede8b97aca5933930c44ef815b7bebde1d400088aeba4f20a891dbaa99e0adddddb07cd2ecadf19f8c7e9cea7cb9c39bc80e5d73cb9cb249c8c8d3e265e84c6100e6a615588dc4bd83e5053225661a9674859842b9efcfdc78530086c3bcdbe24b463514ce2e42a38eb9130dc5b162e39b845ccf40cb207844a0dddd2749b50bbdfb3d55b8ba7bba5447beb58f0d9a4ec43f681f36a2c5287b4f91325d121384e8a51002374f320213c0ec5b6c8c65cf8bfc35eb7d5be7c260970abc3f616d5158bca950d04cd151f16efc9462733d69c203c43cc4dd4c5103208484ac39697be8447391c839ce6b91b9459a6422e27754154add9012b89a973c20488318a28bee3c51f0979c966cf083d5a08bf05dcdbb129787e93cff3b67612e0daf4f90b645256038694721dff7ced077440b76ce93b7ab7685caacd98f7b729777536a98abf6bf4f9f42680ef518e6fe1078b4df9235072e281401e44ee921d432377a0be3bc649098cb39e384ae8123a16d00102876cf1d11b47a1675a0a7fd1f6983a0625f5d8064074ad69317d74f91a120af69364f5a1f26fdf42473bd144060457e27cbcac72a3c3012c9b6ae77e28569b865502fd0cb8d0dfa2beb062daca9fe2077e2309ff64e7e9141100aa70c01cb79618c36b742915eecd977b0919592acc75711af7856cb84527612b76e75e36bb36b0ffb9e6dbf7fc28da6d555839a1db5c0f4aba8d2cd90f2095c7569da0ae6e1a91a7e9641f472ec8b2645e99a20d95438757b8cf5f7e20d36f016e61cb9884e2794b7f9b999599933f32aac748e84f4d22f7ed1d644ba06caa2120d375c311f8192ea39bc7bf6aa22de91f316c631d1963322b7ed9da249e026f9927ea091e670d7cae47581609b6af395a47bf08574124fd23256fa3bb3193405b5e295a98a7d9fe321cc616c18172da48db28ab22e0003bb8fca50df6197a182238efaba8dc85aeccad4ce6121f7df943e3c9a787218444c31a20489667abaa0c937212429fad1b128837679b5ee5775d36b3c316896d8573927d28086b5c5d7a1b7a0ad5717113e8cdb3892f11641ddab4eda1a64dea7ce201c728dbc2a36e1b565617e817df81d92a6ddfcf600b96af4ed6991a52e691079c1a526087ac58c479fd1f8bec3af7b1dbd4ed7b1bf6d321cb2d6f9adc3b24bd80ce39937834ee3da2658f6371f240ea497f07dc732ef43ee857a09704de5541431f13cdb1d1fe23cbf501e4f4c0e62315987d3294db4666738bedf14bae82d8d5bd1c633c52959d62557a8fac806786ab6b51a38b35dd447c54661e6dba3ac8e7e836b4fa798d06951ec53ccbff0e62bf302375decd1f98b68b6690c54b4f544909e7912e14456642a824624398a6c6d14e6622c0ec16577f54778244f8fb9a97bb4d1f89542935cdee8b66163d3696c64ace776645bd304f515ea5987eb3813e1130f7b568d562bee2f3286d0e5c09c1b9d775c7b5e1f80ddcbad76c2623843967d1bc43daf37e9dec1b299b6c5a91f765b4259181daf535f0b0cd18e9862d252703a96e9b5ab2cab01230395db1a4d668ebd6ca9a144974cbb92729bc1ff84f8313164a9100a03c5e31360759d90452a61f1a7bd9a0b341676b132a8bebd990a480aec384f7934a609ed7427946b961122a55fe8c79685efdf30606b79ee9caa44382c0bcf975930ddaa3e502ee697de7779f2128887cdb4f9c038e4833676c91d138aebb49b888f8d29cdeb36136538214fcfe8fc63e8b804329b114abb516a32b2617e56f1af56294c3798d95340021544fde027ca10d206619ee6ce8ee8da0c43b52d257c4e1eb6103f3b52e9b66cd3a2e339bf3fcfcbb83e604c6f37c16569bcf382599ec49e98d57fb02d5264b2d9ab8548b6c859ad7f005793ff67081d5ca083b9e94a1878751f5f14fd8335b0425025f717e0fbe4190291e401cc95d71fda1202d0550a0fb04d5760ccabb971614442fa6f50c4f57515cfd4975da282515f5de06a6d75b58505ba2f91ba1051a194c3460fbe9183897672f2b1a4f6d1b744ee2e21f3cd4419827aca9d60d1139134c54e2f28399e4ed612c94a08f7310f52402389de8637389258d2d5fbd3fa4b2e45cfbe592d62e3e1963b9ca843ecad71c9feaaeffab5851e3b1968b8e8c1c3e3fd0b3ce876bc962f1fc6cf8669d503755d53130f20fc2fc29bd02cc93517cef97c92a767c5b353f853994a9ef2001960604c5accbfc9bce076c43a90359effdb020a5e46b8e10182a60ccbb2dd1fc2613b1d0f47bc08641b94e5386a8e922809ecd23be4cbff1beebd9a3f2ee245100fd6387e7434657d7fd7bc42d69c14ea85c5b99658e4529b7612beaa8dd73548b80ff43a99d9a0a744b9c49dfb38a49608b9223a03e0ca27d19f0b6a782fde351b39ce22e5792cce59b2a287a10c3264c3a290aea239c36052682140bce30e6206288a3d352e56d08dc698d993a8ebdcd8e14a873fe416e11f49a1f649d1d3b7372c1e2c5dc6e719ab53b707f6a38b4e5ca9773446e35bbfdbb5fa87acd1840b433b39dbbd036edce01e68af135faa6f8f94874f18ab810a7d7a2e75f098ed204643735ec89146c45a513c486581e389ef6661e6a5b420d31167a32747a8f548d00a91e52970840738c9f7d9911c6fac8dce862391fe494075522d59ecf6142b8bddd0120e22b5d86d1a7d0bb340d37cdd93b5b18b4cb98e43ededfa7294265381b6db7b5a50fd81f3dcbe667c82350df599b4b0e3854507085c615084d933d585129b20a63ab0f96094bea601cb6d871ef6943ce4ea35b9399ef0efbf26a91d0ca5fa847f77b721c5e34906c728d27e3222560cc2ce50a1f458acbccd27c3cd5e976a932c61643c83f156eae215444bfac4393ea30b69e62391449d58fae2c0e7874d033e76fb387a1ddf33ec48a172227af434b4c462a53692987ca67435bce73fbb607c26aabca68d9b31d31e69a34ff9814c8edf6c095c41fd3faea773bb74ac0bedcacc5e5c8d222d453332a70687899ee53223c034aa94ef825c8ec1f1f7ebacee975cdda0709f7718586ca0848f46a21b6284694315ed2d4bdae032c1be3d033db12009f0d17d4c49f0a4006e5046122e75223ba1910392daa6ed91757a62ed7d650291e7e4e77fa7cfb9caca96cfe27301dc7cba15a36eeeb677311f1805e79db7fd6ab4d9cc4a1b8d78ccab4da7eddf22ad406f57d0eb0b9ed45a1da08414a3cea5d7f87c29eee7093e03c1899060482ca2593a424b5a6594e0c3e6b00412e11521839f1f4daa8cf259c07074f89d996f511d5149f8ef2dedcb3e2a58c6edb5d54cc0ea0b6c2fc6f3377ea61dabce5b3cb4a819fdcdd176c7946d78c074b517ec99fe918e39664217be0d86be5f8d754ac4d1905f002a8fc0ca55b7e037f718923b98fe4429ec9037471df99a8091dd08180dff2e659c433cb080e142dc00c0fcb024a8257234833ffe1d0bd2940c438bfb9cf6f8f5e259ab4d394eb01033a9f3398103da485f2f8d2593e64828d9a5eeeb46ef8c2cc4f767383f85179dc35a6a018d8b15b9462eef8bf2aca7cca16c088767ba183eb3366f8db9ebef5e6f60779571e5c14205e0087302090ce933681f99b6df3d36dcdd07c323b8a03e6830730589c735826444232f2b841c841c11ae92b3f6918ef459b85ddef4e7d509ebddcb04e053a7d8c256ff3dbb3c16cdeb2bbfae1b61c22af70f5a3af9ae341d3e2bd3ea85d6464999f7cc2842330469a72dc42d3e88c3c8edd53f5f56249c528bda4c986c674dc4626e1dfe394a1ea0751eeecc004d3e62f24634b340fb58d8212e0072979b6dd75387cb99287099450bbd77c7991f6af1424c8cdacd9a1e767c1b3dee56fe0a366a3ad6445a3e7f01240c4e2717582177332c7e1a5c9c18c8bc8c7e44413b20f019ae3aa374e8091402d13e29fe06658aa4e9ae1c79e89e76e9274eaae5ac9ab91596e18dc8aaaa358ad338e90daca742f394548ecd85065f53f3ad0989c35403a7ef7b09fa874b7d7267de3b07b956d847c49047f104b4c576edddcde34f03aafc569664a7ca6d2592d0c552ccca27a9541392e58b60e096427155c5831a7323e48959aeb607746a6b0c40f87d5103f1fba5b1eaeb857972dd7905df1161a6fae99983362ea9c5225a15b3edb7677e395165c8df8011d5b03e67c0a6dcb1516c1de0b25159e78e564b006592e89866beddfeeaaa57103820c83e9e03816ef3e1e7f68b80856ab85dc80fec2df827a22f27ce8442ec353707ef5b7347b87d14ab810dc1a511d9db2d5b886eea4b6d8d47af8379e8932c475677c39fee6e355bc9dfab878baad516be487d09607e432a971132929f3408d63b38f4df03067cc50442912c0d547837ee14cdab20cf3306540ce0724e2c5112e6f5637df6b8826af5adc8579c0d3e9a18ce148fd7f57640076232ed36fb2aa94f10eee841334d4175afe893c0e823dcbc126631b5ae2ae7d9e243f36ed1e8876410fa2628147092d0396fd43c9cf7e5577e8bf429ff81a8db23dde77394ec48c50a09f2b0109a06299802bd6966639d5c494f27451576ab2ced8d4b6af74214ea581901aea9a41ac7312da7f1e2b15877a25ea512e2900bb7ad182388322093546ef8ec44b39e28ff2b100d74b8292fcab840b71d0647af1e1e04c364802b8ffab66579c96f406b8f036c7cb1b5101154029df3c13d8a6a1f4c3cd77a22334b43638f73a7f77755a70b4709d12c51ccf3d59e2760802da2b83c8c89618b20e0a7bc8a15ec88db60415564500d662136d8ca44becfac573ca33eca363c551363e7cee936d4efc696ea90c0d5e53e989119e1206dc574fd655bd2e1b879e6a0be5b29816896dab7a1ab3f47bea9a2b929f6cb9125f69d6bfe637f6603111d9e98eb34c3a5652f92b68777dc34823e78a9dff618973868e9fd7e09f74a707def5f8d5594a6c598deab5002bd44755c20eee84b5e04648b6cb5e6565c313311a2809417963f7d2b56b8312e675bad4d6de3e8919f43b493d0572746df02142687ed54cb3d8a92227b299f6303a85516f2219277e6d04b0cd48ebeeb7683ef25001bd9b78dc8781ccd29e99e74937726b2178df06d5fc8997f77fac79ff8fa0cbe7b93ba7311375284368991e9cdeb232f8b44c91e5c1b16d6893766e885b978ba2016c6d8a0fc502567eb020f42b3015366cf87bddf26e55033bf0f4334441589150bda6ce2ab09dafa25bef0523efc81b2e141df6dbb25d1541638cef5d5b0fa34ba82ea9d1c1269a0702db972eeec885c96b7ff0a58a4448ae48033f5353b0b80dd24a93429c796c080f9879a5a1d49547020bf5fff399974facc45d10c7ef9c2e8d533ce25b08385c79d80fb4bff759ff51284efe23455da537af5cdb9028d06039612ac7104f55ef189cfe115a2053c03b49c543e18d7a4a927b32fd5a08ed0302b3ecabc4a8f9e632f19fa0f6334675559d09220be2f1556758d71113d4eb90a3606e5adae80fca194b7532160152b7e7dc2bbbc5b8d52a340617f8797ca06e8eae06cffa720741d254b79ea9e6271fad6914f638b8896e72e16b5db317d7d610e7ac30add93e29a004569bf59b73b3ea32b8e660d034188692d287165b4bd7fe0355a4999f5a49aa21c7bc022636660c5cacb331ba86ab4f2cb55a9bd543165ffe76d8eadfe377ca5ba49ec60829e6836761a38c144808339bcca322ff6ac8bdc0941734e789ae89e34cbc6d8a2f0cdaa458ab95144598d86856df728828ed6e8a5173e09397c227fe45f2a05039a7f291e5afeeade47915fab1d4063a87ef4db2acd2344f81543f7f48c474583442c15263315869235d9d8b935920e81b1459d493136ee537270d4e0c942fa4e6278bb3770e624bf35275a35adddac2d4684b623dace95671f002eb101b0e8e9575ed17102fa209bfba5f2275a754417c7082c1dbae751e7ce8adfc01da6848d788c80a97a84435e152ad0a977f2c6112b28755dfd233540cab3e140615cba00414a39b9e6ed9dbbd06b9c731bd8766024b8e56c022299234b3265b55bb583b2fe0379fbbad2ce78ba013fd3843ca38ea5f3b5813baf96ceec8c880508c487c669cc45f53df2e3b3b8f5378b6fd838378b7516619352768ef52eee9f6d73d0ea829aede93d90e464b702d850115d4579be76442a81dcb1ae61ca5122b27b14bc4d0090fea9b0040580197c536fc916b69de88dc94974da89e8a510244b14b388ed091066af057d0229e385ae7b10dbf58f0eb6d54b33b02dadc285aaa7095ced7a073339e30f7eb2e99869af753037d3217ffa29cde474863542b18b425186427f8703aeb42720cb9dedb25e603f601a348529ccd0c4970d2e53f9093d4a5fb01956ada9bb02302667856059ae8a9a72c8c43d6b53b6b3de32c3786165422f41ac5955770555f518a6d2f98398b6af2e7861c81c06a536715df3acf98293d401dd558e12ffcc93aa4e728abef7b5bb2de662aa792e35aa49e9fa7cf0b14fced4e60672c7b67640d0889d84b90156cf07011c8e6680a10e9947b3a7836992aa7b97af9ed7f1793db1166f5cd3e1d1330efd356bacffbfb99feff9d3233dc3680a1a5aee6c72ee706f1c831960b074ef87edd2bc335411628c3ccde48ab9ef32d217dbd6a2d78307865efaabb632e1a65b121b871a6c04058a26e1a9e40c61650f8fdc052fcbebbfd27685813f6fc0212c377d4b779000238a09771d87180c135579d86384a50f6dd624e1b5e437c132ad8f615d0e8b78ab2d481312d412abcd646f9db600bf9bd4ff93012fbb3c96a97cc4ca68bfaf6a4f4b566bdc4c0d53c88261c875b6d63ef1f7fc4c6b01adc5ff1170b710cbbb5784871702bd5e2939152251623fd7ad3dd22b05f6b1832c79732d62a49075b6b55fd4a63a0e25fe4d496dbb1a0f390190478eab87e24450227df9f1196a9c6a49dc42e70181bbbad3f181bb9dcc5626f9cd2aea99a9b15df1bfacf7e053556453b5e2dc49028e0f2ea99c468c27eafad85e2c1d7527d81d817df8155ec4c78f6e6473a406878b8fc6722a01355653c73353a55975b2d6f089cbed47dcbd01285293e28cd97918ee54a46c68a2f0bc47263514711b0b12da4a07322673af8a7bd408996606437b1272bbfc71013215eb2ba2070aaca4ff4cadae6e9f8a8fa0b3790ebabc50f980905970dd719d2113bdf5215a6d072b7c9952dc7063fda7bed41bb9509c69381327c7b4cd34c4d39666dc145e558a524eaf9813bf1e880f346f29ce1f6fc96eab3f30a54447011d9bb6413eb2e5c45db5fa15e04fcb806d95c0c94f9f9f7fead5ef0ba472db32b4d29e1897c595285e9c3a8ccdc6f945dd8c38a5443b46f4423162802830a3675809e47f699910c31c0b26c67ff51f947a9d560ff396a4d9585d6d1d773d289a1019c6abc53909e08cde6317ac57a6c6e57c324198fd8cbd1e9019363a568488b6a9e14a0de2541fa06b5ec66d3d42c6c7cc5d91d62f6dda1c05cab0f377f76fc494678c88f5eed3831e50d13dc462eda0151c9adb9f1da1a2de245a80c78cb6866ffa57d401f5b6a6d55b6da3e74ecf42eafeb7cf50e9574b24042c3c7730e99119564514f9bdf95272d5ad831958b2d1b739f8d143f7e9aac1056838b68faec4f92f7d50c9e52bb7491896af99e25d5489672f2a95c901ec9d7f71fcea4055ee15372aee28d7defc4a83b47ff1a1ba6ef05624e283009dc8f5d8a77e2fd994425dbc8d6ff3399ede7a937e2c575d64dcfe98d93984709b87ec1968e7e38260bd413ae3b707e7e6b345a1904d2746cd282b50f5ebedc5dd8646e67bb1f531b28cbac2eafc6e1137cfbbe13894ee1d30c012d468e8e6b7e354b62f594c0d47011f1229fdc1026ba58f55d88c81b662bdc50d83aec1ba19a975d0f8c3079e6bfcf7564be6d664a774ca220234115b17d023fd5da3abc647f12a0ffcbb2ad83898edf723a8ebc202757509eea988d44e46631e3a77162de266cd333a18b009b354750f5a3ef8cfb10910ceacb046fc043cdeed093a91b19e6adbfa816e2b504f3ef1f65664a06f943769a99e4bc5f24cd4d96d4e5b6543e1b39dc5df51a0b34395e498b8a6bf92ed6cc77b5a78102aeacf811bd9ec374243ab9d8827dd58f6babace369f3ef03492cf2a6ac87f5d37966fd0b683ef8f455822e9f64e471af9475f5a19d50f565490832bb89e6453364187de3096c997019b257f4718084636462f8d4fb022ba2223dadd8cff40e39aeedb891e2609d2a9ea0370d56c8db8a9728f782e13c3e7b49d0bfb6d1372469d99e323a8607179518a44ed83ded1d2c6222a6f12aba94ef28e9a06a326a568f7b155749c3c2f3856ee5fbbeaadbbc3050abe4f94b50cd704be20e7c3c57f740b85842ef5f01926dcedb07387f3c77595c689480ea17b3d96ea221946e0247720fac279db0100ad7c3dd3c3e66692c9a2dc59714011da430e1936d2079198c6f269dd1467299a6cb0ccbb931e89572d58ad501a8b59ca95ad2c1b827f341f0cf94a150d6a6f3794d21d131328682e32cdb45ea119f5117f3b252ad186405949751f2d549fed1db5211ea0d4720305d41fe35788adbe628c805570f004ff764f69de7425ae3ad9a956a952492a4e97f2de8e5267a797df280f9e9aac10a02784826600fd43284895508ba67a51f28cde60d1c1c3b16b1999a83fbfdf177f157dde5fb33c9cbeaade094a6793a25ac7ea9334f7842270ed963a1bda71f3eed8f2cd36c768bea7ffbde805e5fbdef1d497b402dff721d9fc90452cd85975b9670c8b7c37fd35dafa3d1c0ff6b80ab036b0cb70ca1fec6bbc8f0d51a0d6113b2309902b731b38dff4447dd39b5a8e4c9ad10a5938c86324f1040615b14e4b6447d84524c65ea6492df208244da7de6ae7871045f2d961fa48b9b717bd41ca128cf5a2332b92c46b49e0436985cd7861dcc20e0c32ea47a7cadb853b6ad32fdbfcfb27b020c251d2e571d47cf2df23533d2df6ecc8e193da1a17ff317ffd1bff0c7fb697dc67b004110b535191dc5de1ae39fc8524c72211e846cc30d41bd8fd351087f42c8844c28947e1f2ae1ee8a47bf694bbe0ce901b316a6eae490d399e692277564c05c0cddfe5ab34540677a27c1e0250c2b6cf9f5b2869be0a41cf3c515132db92309ce2b978782c0e5a53c55398bd522bdf6763189669b76037de00cf26854870b6076316bc18883b38d61e7af5fceb21526507a14a71ffb0fd3a2ed7e7e46fe364f65cd5a848300f62597e7141735a679176937e0b8ea259ae2b1cbf797dc3f77395c2b97315086e4e2e83e07c3a321b2e31a2fde7f8f461d5ff3ed76ac160f120e89322e98f3280bb352784e52a820fa75130396c24bf5394b814092827a8b0bc062816923b658559ef94e248d09b1b277c77d8e90606b951fbe49e335df07088c55b79c780921e62b48f81889f4dad96f85d546310f6df17625b4223c4e04b63629155e2e855e83523ee3952be6b44faa4555e102ca4dccf64812cc2fe017bb8546a90e5452dad06cbebc13917b9ab58a9f677509265f81e45205c254039e1f2166b61142f26893a234313dc8cb280f5e6e2b922e1c5a3138d211e43efd7eb5a72d5300fce8a309dc70a9475597e757a5f96925eb676a1fc6f034607fb08882108c6922e9a9152b434250fbf63102081de0797b683c55538d5ea9764ec9f52d94c67d5ad73cea28b415cbdfedd330e72b7bef4e716ece8aed031ef98c984b771a7097cbc8869015859dace57b2376ce81265e98af4162516702734438fbd616aa174836c28287081cd83a1332f17369d3e24d28027b9a8133702822cc6c9c354f5585cd7bb0a140dfa777f1abeab81f65c2a602120f0a6cd14b1fdadf47753def5fe16dbf58f4bd671e13bcd51d8a8b2955a50d0240a91e8a571afd65187a767b196620756b5f818e9beef7d011ba38b40c992029eccb5c5e76b6dfeb2db75ba27cdf150ed3e1a36f0ef2ca612f57d05358377c7452d3dd42bd2c655438d6f457c5a92fce3be9ec44ce208fafd70675f05dd466df55670bcc0e95b308d3ef1e88aab4b16889c6004f0ae39de48879767a102af354ac12a08f6f34633832e5e62b7d07de4ca2ef2e3c01e87b1eab9c6461065f257540b3a47099d782ef9b05d0c58a7d3e8d0f0839ae0a37353d3339d676eab7a15e93b0a7f5e67e854fb1975cc74ab074eef3044a07dd52986fe75c6c38dd78e673b01dae076afb17ec8e963e281da91a4f4976618bd190b50ae5cee34b200c6d3dd2e7d5500a66b9db4d665941d49c5791cb5c9631972cb03831abc94541ec74b886d149dd18d32b078c47490caca39e590aef81567d2a12c2708c50e1e52aa491afe770bd0320eac48eac67cc66e750547485a4f78d91338e5f8e0dead8db0b3608289c9e67e47fc8304487fe2106fbcd45faa0da8f75431a17afefe9023f8013403d9db0df81546fdcd8f1f0f73e07d949df4de0bde0d1d156a0c778c8446e0dfac4086c92c69d5d870b307d87627c37b3f9e4d4493abff66da89bb5fb6c4ce10619abf112eb7424a7bda6d867de874f528b0b68ed7a167f0522c1c1314e5566cea4d08687cee1baf93c37fed1ee1230a42feb4707a25893e5d73b3da57abf36d028240671f3ccc3729f4d8bca5e8c8c78994c637586fab0fd2f0f2729cc59d6c6decb824e7a8c6c0be1e1dc7cd6c45b2f803b2aef88ed4b6c32aa623ad20f2e5fd5eb373ecf4b11318932d631891e60250eecdb3c9bc1ef8db6a795a0507651c10056f113b22a595215a5c21b74f45eb240a6a23d25ff19fa04dcc56e81fe8fda73d9dc0a50b1da38d4aa080526db0bd30efc4d1ae3700063bcf85ba82cc84198a35f6e6179b4ece9fcae9c822d80b90dbd95ea89942dd326fab81645c4da6fa53ca8ba7be4678a575a41071eab65b167adfc587e606aedc7ff11f8fe99273b4520692798d62b8a117002327d1da0a8f829ed88ae650f5630ea1072585f7789c62c5ce6136da7b7a42b43e87178a778fa6b2aa2201ce9f76ffb5328889bdbbe2a2e052f3a01ccf511cfcab3c4d5a2fda8ec62f5d6cc68961f713d33e8590e92d88c1db84eb6f81d324b3c24a2e8eee2967ce531f8ab76ce7d6a56a89a7ad55137f06e8f17ffac05851e91472f59309f7f7c037a311d275112fd101366e84a06cbb63bfcde08ab13f99fddb6a88fec65ae14ff956d96e8658c0b8cf89d99007a9bcde9164a73d562e9e4e427dbb27d4d152a74f113841ac81535223d295dc3ef7973487190a327ee275eab13f1fc9b98d91e0958034cbd636dc2d563d259cdbbf3adc48c43c7d3f0c15651178536fd88db7a16fc3af385bc0aa6d3d8a2abf4fca723727e6ea5bc1b608e7596edc3a0e483f9590aa1f4ef236f686888b6c4a26625c87dfeb88e860f89a9d1c360aec366ed854eb44b23b8a20945a89c729ec02aad035c08fb0cce542e96fbd6f921c83c27fb1508f697d8d7bcad3c11582386e7032db8de8a6a316f3de46e0b040201d296a6cc4d838b398fc44314661839a75c80723f0df86edd7287fab9a3c77da0f688b5e7a9bf7e94bf5b8b38c8a77a61bc5407923fc57b23a0b3685753f3de1572f229443a3c1abb59f1c67b5604c3dc9b41a6e7be3e01c417760288d79817ec4c2a4ce3b63cf9378bdd8dd1497aec5b4a616c6a93602fe6ab066fb0202aeec1551f77732bd3cb92362c81e0f30a76b933b926c929a00b18e3b26072a36ca9e17d973ba31063dfed857ce50b01dc3db623d3207da7a2977c73013554b020faf2fb4c57197bfc38e7eaef</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX排版系统介绍</title>
    <url>//posts/3038973426.html</url>
    <content><![CDATA[<h1
id="前言排版工具与书写工具的讨论">前言：排版工具与书写工具的讨论</h1>
<p>LaTeX
是一种“非所见即所得”的排版系统，用户需要输入特定的代码，保存在后缀为.tex
的文件中，通过编译得到所需的 pdf 文件.</p>
<span id="more"></span>
<p>例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">Hello, world!</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出的结果是一个 pdf 文件，内容是”Hello, world!“。</p>
<p>如何理解“非所见即所得”呢？在这里举个“所见即所得”的例子：Word。Word
的界面就是一张 A4
纸，输入的时候是什么样子，最后呈现出来就是什么样子。这给了我们极高的<strong>自由度</strong>，也非常容易上手，但是有如下问题：
- 对于对细节不敏感的用户，Word
的排版常常会在细节存在问题，比如两段话之间行间距不同、字体不同、标题样式不同等；
- 对于撰写论文的用户，Word
的标题、章节、图表、参考文献等无法自动标号，也很难在正文中引用； -
对于有公式输入需求的用户，Word
自带的公式不稳定，而公式插件效果常常不好。</p>
<p>相比之下，使用 LaTeX 进行排版，就像是在铺好的轨道上驾驶火车一样。使用
LaTeX 没有办法像 Word
一样非常自由，但是可以保证<strong>规范性</strong>，这使得 LaTeX
非常适合用于<strong>论文的排版</strong>。在学习的过程中，也将会感受到这一点。</p>
<p>无论是 LaTeX 还是 Word，其归根结底都只是<strong>排版工具</strong>，用
Word 也可以排出 LaTeX 的效果，用 LaTeX 也可以排出 Word
的效果。另外，笔者最建议的<strong>书写工具</strong>是
Markdown，其书写的过程中可以不在意排版，也支持使用 LaTeX
语法输入公式，与 LaTeX 之间的转换非常方便。</p>
<h1 id="准备工作安装-latex-与配置环境">准备工作：安装 LaTeX
与配置环境</h1>
<h2 id="安装-tex-live">安装 Tex Live</h2>
<p>官方的地址是http://mirror.ctan.org/systems/texlive/Images/texlive2021.iso，但是可能速度较慢，以下是一些国内的镜像地址：</p>
<ul>
<li>清华大学：https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2021.iso；</li>
<li>北京交通大学：https://mirror.bjtu.edu.cn/ctan/systems/texlive/Images/texlive2021.iso；</li>
<li>上海交通大学：https://mirrors.sjtug.sjtu.edu.cn/ctan/systems/texlive/Images/texlive2021.iso；</li>
<li>中国科技大学：https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2021.iso；</li>
<li>重庆大学：https://mirrors.cqu.edu.cn/CTAN/systems/texlive/Images/texlive2021.iso；</li>
<li>腾讯云：https://mirrors.cloud.tencent.com/CTAN/systems/texlive/Images/texlive2021.iso。
其中的 iso
文件可以使用压缩软件解压，或者加载到光盘，接下来直接安装就行了。对于其他操作系统的用户（如
MacOS），可以参考<a href="https://liam.page/texlive/">TeX Live
下载及安装说明 | 始终 (liam.page)</a>中的方法。</li>
</ul>
<h2 id="选择-tex-编辑器">选择 TeX 编辑器</h2>
<p>对于新手，最推荐的编辑器是
TeXworks，非常适合用来上手，也避免了配置环境带来的问题。如果想要提高效率的话，可以选用：</p>
<p>TeXstudio，安装地址为<a href="https://cn.overleaf.com/">TeXstudio - A
LaTeX editor (sourceforge.net)</a>； 宇宙第一的 Visual Studio
Code，这是笔者最建议的 TeX 编辑器，不过需要手动配置 LaTeX，较为麻烦；
另外，也有在线的编辑器，如<a href="https://cn.overleaf.com/">Overleaf,
在线 LaTeX 编辑器</a>。</p>
<h2 id="选择-pdf-阅读器和编辑器">选择 pdf 阅读器和编辑器</h2>
<p>LaTeX 编译的结果是 pdf 文件，建议选用专业的 pdf 阅读器或 pdf
编辑器。特别是在阅读 beamer
类型的文件时，不同的阅读器效果差别极大。在这里推荐 Acrobat：</p>
<ul>
<li>Adobe Acrobat Reader，免费，可用于查看、签署、协作处理和批注 PDF
文件，安装地址为<a
href="https://www.adobe.com/cn/acrobat/pdf-reader.html">Adobe Acrobat
Reader (中国)</a>；</li>
<li>Adobe Acrobat Pro，付费，可用于创建、保护、转换和编辑 PDF
文件，安装地址为 Adobe <a
href="https://www.adobe.com/cn/acrobat.html">Acrobat | Adobe Document
Cloud</a>。</li>
</ul>
<h1 id="利用-latex-编写文档">利用 LaTeX 编写文档</h1>
<h2 id="文档类型">文档类型</h2>
<p>TeX 有多种文档类型可选，笔者较常用的有如下几种类型：</p>
<ul>
<li>对于英文，可以用<code>book</code>、<code>article</code>和<code>beamer</code>；</li>
<li>对于中文，可以用<code>ctexbook</code>、<code>ctexart</code>和<code>ctexbeamer</code>，这些类型自带了对中文的支持。
不同的文件类型，编写的过程中也会有一定的差异，如果直接修改文件类型的话，甚至会报错。以下统一选用<code>ctexart</code>。在编辑框第一行，输入如下内容来设置文件类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br></pre></td></tr></table></figure>
<p>另外，一般也可以在<code>\documentclass</code>处设置基本参数，笔者通常设置默认字体大小为
12pt，纸张大小为 A4，单面打印。需要将第一行的内容替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;</span><br></pre></td></tr></table></figure>
<p>文件的正文部分需要放入 document 环境中，在 document
环境外的部分不会出现在文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">这里是正文.</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h2 id="宏包">宏包</h2>
<p>为了完成一些功能（如定理环境），还需要在导言区，也即 document
环境之前加载宏包。加载宏包的代码是<code>\usepackage&#123;&#125;</code>。本份教程中，与数学公式与定理环境相关的宏包为<code>amsmath</code>、<code>amsthm</code>、<code>amssymb</code>，用于插入图片的宏包为<code>graphicx</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;amsmath, amsthm, amssymb, graphicx&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在加载宏包时还可以设置基本参数，如使用超链接宏包
hyperref，可以设置引用的颜色为黑色等，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]&#123;hyperref&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标题">标题</h2>
<p>标题可以用<code>\title&#123;&#125;</code>设置，作者可以用<code>\author</code>设置，日期可以用<code>\date&#123;&#125;</code>设置，这些都需要放在导言区。为了在文档中显示标题信息，需要使用<code>\maketitle</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;</span><br><span class="line">\usepackage&#123;amsmath, amsthm, amssymb, graphicx&#125;</span><br><span class="line">\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line">% 导言区</span><br><span class="line"></span><br><span class="line">\title&#123;我的第一个\LaTeX 文档&#125;</span><br><span class="line">\author&#123;Dylaaan&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\maketitle</span><br><span class="line"></span><br><span class="line">这里是正文.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正文">正文</h2>
<p>正文可以直接在 document
环境中书写，没有必要加入空格来缩进，因为文档默认会进行首行缩进。相邻的两行在编译时仍然会视为同一段。在
LaTeX 中，另起一段的方式是使用一行相隔，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是第一段.</span><br><span class="line"></span><br><span class="line">我是第二段.</span><br></pre></td></tr></table></figure>
<p>这样编译出来就是两个段落。在正文部分，多余的空格、回车等等都会被自动忽略，这保证了全文排版不会突然多出一行或者多出一个空格。另外，另起一页的方式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\newpage</span><br></pre></td></tr></table></figure>
<p>在正文中，还可以设置局部的特殊字体：</p>
<table>
<thead>
<tr>
<th>字体</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>直立</td>
<td></td>
</tr>
<tr>
<td>意大利</td>
<td></td>
</tr>
<tr>
<td>倾斜</td>
<td></td>
</tr>
<tr>
<td>小型大写</td>
<td></td>
</tr>
<tr>
<td>加宽加粗</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="章节">章节</h2>
<p>对于 ctexart
文件类型，章节可以用<code>\section&#123;&#125;</code>和<code>\subsection&#123;&#125;</code>命令来标记，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;</span><br><span class="line">\usepackage&#123;amsmath, amsthm, amssymb, graphicx&#125;</span><br><span class="line">\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line">% 导言区</span><br><span class="line"></span><br><span class="line">\title&#123;我的第一个\LaTeX 文档&#125;</span><br><span class="line">\author&#123;Dylaaan&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">\section&#123;一级标题&#125;</span><br><span class="line">\subsection&#123;二级标题&#125;</span><br><span class="line">这里是正文.</span><br><span class="line">\subsection&#123;二级标题&#125;</span><br><span class="line">这里是正文.</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目录">目录</h2>
<p>在有了章节的结构之后，使用<code>\tableofcontents</code>命令就可以在指定位置生成目录。通常带有目录的文件需要编译两次，因为需要先在目录中生成.toc
文件，再据此生成目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;</span><br><span class="line">\usepackage&#123;amsmath, amsthm, amssymb, graphicx&#125;</span><br><span class="line">\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line">% 导言区</span><br><span class="line"></span><br><span class="line">\title&#123;我的第一个\LaTeX 文档&#125;</span><br><span class="line">\author&#123;Dylaaan&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\maketitle</span><br><span class="line"></span><br><span class="line">\tableofcontents</span><br><span class="line"></span><br><span class="line">\section&#123;一级标题&#125;</span><br><span class="line"></span><br><span class="line">\subsection&#123;二级标题&#125;</span><br><span class="line"></span><br><span class="line">这里是正文.</span><br><span class="line"></span><br><span class="line">\subsection&#123;二级标题&#125;</span><br><span class="line"></span><br><span class="line">这里是正文.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片">图片</h2>
<p>插入图片需要使用 graphicx 宏包，建议使用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;[htbp]</span><br><span class="line">    \centering</span><br><span class="line">    \includegraphics[width=8cm]&#123;图片.jpg&#125;</span><br><span class="line">    \caption&#123;图片标题&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>[htbp]</code>的作用是自动选择插入图片的最优位置，<code>\centering</code>设置让图片居中，<code>[width=8cm]</code>设置了图片的宽度为
8cm，<code>\caption&#123;&#125;</code>用于设置图片的标题。</p>
<h2 id="表格">表格</h2>
<p>LaTeX 中表格的插入较为麻烦，可以直接使用<a
href="https://www.tablesgenerator.com/#">Create LaTeX tables online –
TablesGenerator.com</a>来生成。建议使用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;[htbp]</span><br><span class="line">    \centering</span><br><span class="line">    \caption&#123;表格标题&#125;</span><br><span class="line">    \begin&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3 \\</span><br><span class="line">        4 &amp; 5 &amp; 6 \\</span><br><span class="line">        7 &amp; 8 &amp; 9</span><br><span class="line">    \end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列表">列表</h2>
<p>LaTeX
中的列表环境包含无序列表<code>itemize</code>、有序列表<code>enumerate</code>和描述<code>description</code>，以<code>enumerate</code>为例，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">    \item 这是第一点;</span><br><span class="line">    \item 这是第二点;</span><br><span class="line">    \item 这是第三点.</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>另外，也可以自定义<code>\item</code>的样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">    \item[(1)] 这是第一点;</span><br><span class="line">    \item[(2)] 这是第二点;</span><br><span class="line">    \item[(3)] 这是第三点.</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定理环境">定理环境</h2>
<p>定理环境需要使用 amsthm 宏包，首先在导言区加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]</span><br></pre></td></tr></table></figure>
<p>其中<code>&#123;theorem&#125;</code>是环境的名称，<code>&#123;定理&#125;</code>设置了该环境显示的名称是“定理”，<code>[section]</code>的作用是让<code>theorem</code>环境在每个
section 中单独编号。在正文中，用如下方式来加入一条定理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;theorem&#125;[定理名称]</span><br><span class="line">    这里是定理的内容.</span><br><span class="line">\end&#123;theorem&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>[定理名称]</code>不是必须的。另外，我们还可以建立新的环境，如果要让新的环境和<code>theorem</code>环境一起计数的话，可以用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]</span><br><span class="line">\newtheorem&#123;definition&#125;[theorem]&#123;定义&#125;</span><br><span class="line">\newtheorem&#123;lemma&#125;[theorem]&#123;引理&#125;</span><br><span class="line">\newtheorem&#123;corollary&#125;[theorem]&#123;推论&#125;</span><br><span class="line">\newtheorem&#123;example&#125;[theorem]&#123;例&#125;</span><br><span class="line">\newtheorem&#123;proposition&#125;[theorem]&#123;命题&#125;</span><br></pre></td></tr></table></figure>
<p>另外，定理的证明可以直接用 proof 环境。</p>
<h2 id="页面">页面</h2>
<p>最开始选择文件类型时，我们设置的页面大小是
a4paper，除此之外，我们也可以修改页面大小为 b5paper 等等。</p>
<p>一般情况下，LaTeX
默认的页边距很大，为了让每一页显示的内容更多一些，我们可以使用<code>geometry</code>宏包，并在导言区加入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;geometry&#125;</span><br><span class="line">\geometry&#123;left=2.54cm, right=2.54cm, top=3.18cm, bottom=3.18cm&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了设置行间距，可以使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\linespread&#123;1.5&#125;</span><br></pre></td></tr></table></figure>
<h2 id="页码">页码</h2>
<p>默认的页码编码方式是阿拉伯数字，用户也可以自己设置为小写罗马数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\pagenumbering&#123;roman&#125;</span><br></pre></td></tr></table></figure>
<p>另外，<code>aiph</code>表示小写字母，<code>Aiph</code>表示大写字母，<code>Roman</code>表示大写罗马数字，<code>arabic</code>表示默认的阿拉伯数字。如果要设置页码的话，可以用如下代码来设置页码从
0 开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\setcounter&#123;page&#125;&#123;0&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS指令类型</title>
    <url>//posts/3010580983.html</url>
    <content><![CDATA[<h1 id="mips指令">MIPS指令</h1>
<p>操作码的长度决定了可以提供多少个指令数；操作码的编码一定要有唯一的解释</p>
<h2 id="一计算机的寻址方式">一、计算机的寻址方式</h2>
<ol type="1">
<li>立即寻址：指令中给出操作数</li>
<li>直接寻址：指令中给出操作数所在的有效地址</li>
<li>间接寻址：指令中给出一个间接地址，间接地址在内存中寻找直接地址，直接地址读出操作数</li>
<li>寄存器间接寻址：指令给出寄存器编号，根据寄存器内容找出操作数</li>
<li>基址寻址：指令中给出一个寄存器编号，同时给出一个偏移地址，基址寄存器内容+偏移地址从内存中取操作数</li>
</ol>
<h2 id="二操作码编码">二、操作码编码</h2>
<ol type="1">
<li>定长操作码编码</li>
<li>扩展操作码编码</li>
</ol>
<h2
id="三mips的指令可以分为3种操作类型">三、MIPS的指令可以分为3种操作类型</h2>
<ol type="1">
<li>R型</li>
<li>I型</li>
<li>J型</li>
</ol>
<p>1、R型指令</p>
<ul>
<li>OP：000000 由func来决定他的功能</li>
<li>rs、rt是两个源操作数所在的寄存器号</li>
<li>rd是目的操作数所在的寄存器号</li>
<li>shamt是位移量，执行移位操作的时候指明需要移动的次数</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/6a90526e0372ab06887ff12d9a1ab421.png" /></p>
<p>同时也要牢记R型指令的指令表：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/13823636d7033879cbecad68090ada93.png" /></p>
<p>2、I型指令</p>
<ul>
<li>操作功能由OP决定</li>
<li>rs是第一个源操作数，immediate是第二个源操作数</li>
<li>rt是目的操作数所在的寄存器编号</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/580d2e491a84537b5b19defbf0d87ff3.png" /></p>
<p>I型指令的操作表：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/0c570f3582b99b2dbfde54ce045ad0ec.png" /></p>
<ul>
<li>在I型指令中，addi指令是需要进行符号位扩展，但是andi、ori、xori指令只需要进行零扩展即可</li>
<li>sw、lw、beq、bne等操作都是进行符号位扩展</li>
</ul>
<p>3、J型指令</p>
<ul>
<li>操作功能由OP决定</li>
<li>转移地址：26位（立即数）<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/44fd4af08ce66b1a54a681e5f09494e9.png" /></li>
</ul>
<p>J型指令操作表：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/cc597cdea27b10e64a6e1d62b5c536e0.png" /></p>
<h2 id="跳转指令寻址">跳转指令寻址：</h2>
<h3 id="伪直接寻址">伪直接寻址</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204201758789.png"
alt="image-20241204201758789" />
<figcaption aria-hidden="true">image-20241204201758789</figcaption>
</figure>
<h3 id="pc相对寻址">PC相对寻址</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204201816128.png"
alt="image-20241204201816128" />
<figcaption aria-hidden="true">image-20241204201816128</figcaption>
</figure>
<h2 id="异常和中断">异常和中断</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204202419275.png"
alt="image-20241204202419275" />
<figcaption aria-hidden="true">image-20241204202419275</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204202444945.png"
alt="image-20241204202444945" />
<figcaption aria-hidden="true">image-20241204202444945</figcaption>
</figure>
<h2 id="cache映射">Cache映射</h2>
<h3 id="直接映射">直接映射</h3>
<p>主存中的每个块只能放在Cache中的唯一位置（行）</p>
<p>Cache行号=主存块号 mod Cache 行数</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204202801123.png"
alt="image-20241204202801123" />
<figcaption aria-hidden="true">image-20241204202801123</figcaption>
</figure>
<h3 id="全相联映射">全相联映射</h3>
<p>主存中的每个块可放置在Cache中的<strong>任何</strong>位置（行）</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204202851289.png"
alt="image-20241204202851289" />
<figcaption aria-hidden="true">image-20241204202851289</figcaption>
</figure>
<h3 id="n路组相联映射">N路组相联映射</h3>
<p>一个Set是若干块的集合</p>
<p>主存和Cache中的组都具有同样大小（组内块数相同）</p>
<p>“N路”指每个组中包含的块（行）的数目，也称为相联度</p>
<p>主存中的一个块首先被映射到Cache中的唯一一组中，然后该块可以放在这个组的任何一行中</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204203017769.png"
alt="image-20241204203017769" />
<figcaption aria-hidden="true">image-20241204203017769</figcaption>
</figure>
<h3 id="总结">总结</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204203026144.png"
alt="image-20241204203026144" />
<figcaption aria-hidden="true">image-20241204203026144</figcaption>
</figure>
<h2 id="cache结构的表示">Cache结构的表示</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204203049833.png"
alt="image-20241204203049833" />
<figcaption aria-hidden="true">image-20241204203049833</figcaption>
</figure>
<h2 id="cache块替换策略">Cache块替换策略</h2>
<h3 id="lru">LRU</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204203225314.png"
alt="image-20241204203225314" />
<figcaption aria-hidden="true">image-20241204203225314</figcaption>
</figure>
<h2 id="cache写命中策略">Cache写命中策略</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241204203412872.png"
alt="image-20241204203412872" />
<figcaption aria-hidden="true">image-20241204203412872</figcaption>
</figure>
<h3 id="写直达">写直达</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/%E5%8A%A8%E7%94%BB.gif"
alt="动画" />
<figcaption aria-hidden="true">动画</figcaption>
</figure>
<h3 id="写回">写回</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/%E5%8A%A8%E7%94%BB1.gif"
alt="动画1" />
<figcaption aria-hidden="true">动画1</figcaption>
</figure>
<h3 id="写分配">写分配</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/%E5%8A%A8%E7%94%BB2.gif"
alt="动画2" />
<figcaption aria-hidden="true">动画2</figcaption>
</figure>
<h3 id="写不分配">写不分配</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/%E5%8A%A8%E7%94%BB3.gif"
alt="动画3" />
<figcaption aria-hidden="true">动画3</figcaption>
</figure>
<h3 id="虚拟索引虚拟标记vivt">虚拟索引虚拟标记（VIVT）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/image-20241207204819592.png" /></p>
<p>优点：
不需要每次访存的时候把虚拟地址经过MMU转换为物理地址缩短了访存关键路径，
提升了频率， 提升了Cache访问速度</p>
<p>缺点： 即使Cache命中，也需要访问并更新TLB（两者可以并行）
进程切换需要冲刷Cache，或者增加PID（进程ID）位 歧义问题（ambiguity）
别名问题（alias）</p>
<p>歧义问题： 相同的虚拟地址映射到不同的物理地址
假设A进程的虚拟地址0x4000映射物理地址0x2000，B进程的虚拟地址0x4000映射物理地址0x3000。A进程切换到B进程，导致0x4000地址访问命中，而对应的是物理地址0x2000中的数据，从而出现错误
解决方案：冲刷（flush）Cache（使用专门的Cache指令，例如MIPS中的Cache），保证切换后的进程不会错误的命中上一个进程的缓存数据</p>
<p>别名问题：
不同的虚拟地址映射到相同的物理地址，例如进程间通信假设虚拟地址0x2000和0x4000都映射到相同的物理地址0x3000，其中虚拟地址中的[15…4]位作为index，此时同一物理地址数据被加载到不同的Cache
Line，容易破坏数据一致性。</p>
<h3 id="物理索引物理标记">物理索引物理标记</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/image-20241207204925506.png" /></p>
<p>从虚拟地址中抽取index查找Cache，从物理地址中抽取tag进行比较
Cache的查找和物理地址的转换同时进行，性能优于PIPT
不存在歧义问题，但依然存在别名问题。</p>
<h3 id="vipt中的别名问题">VIPT中的别名问题</h3>
<p>直接映射：当Cache容量不大于页大小时，将不会产生别名问题
组相联：当Cache中一路的容量不大于页大小时，将不会产生别名问题
此时，index位于页偏移之中，虚拟地址和物理地址对应的index相同
VIPT相当于PIPT</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/MIPS%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B/image-20241207205415587.png"
alt="image-20241207205415587" />
<figcaption aria-hidden="true">image-20241207205415587</figcaption>
</figure>
<p>解决方案1：提高相联度，将索引index控制在page offset字段范围之内
解决方案2：使用大页，将索引index控制在page offset字段范围之内
解决方案3：调整虚实映射，避免相同物理地址数据加载到不同Cache行对于直接相联，在建立共享映射的时候，虚拟地址都是按照Cache大小对齐对于组相联，在建立共享映射的时候，虚拟地址都是按照一路Cache大小对齐
解决方案4：但满足不了将索引VA的index控制在page
offset字段范围之内时，需要操作系统提供支持，即Page Color功能。</p>
]]></content>
      <tags>
        <tag>计算机组成与体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定时器（setitimer定时）</title>
    <url>//posts/3461879022.html</url>
    <content><![CDATA[<h2 id="定时器流程">定时器流程</h2>
<p>1、itimerval——设置定时器的初值和周期值</p>
<p>2、setitimer——设置定时器</p>
<p>3、sigaction（）/signal（）——处理信号，执行定时功能</p>
<p>4、SIGALRM——触发信号</p>
<h2
id="itimerval设置定时器的初值和周期值">itimerval（设置定时器的初值和周期值）</h2>
<p><code>itimerval</code> 是一个结构体，它在 POSIX
兼容的操作系统中定义于 <code>&lt;sys/time.h&gt;</code>
头文件中。这个结构体用于 <code>setitimer</code>
系统调用，以便获取或设置进程的虚拟定时器和实时定时器。</p>
<p><strong>结构体定义：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerval</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_interval; <span class="comment">/* 定时器重复触发的时间周期 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_value;    <span class="comment">/* 从当前时间到定时器第一次触发的剩余时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>成员解释：</strong></p>
<ul>
<li><p><strong><code>it_interval</code></strong>：这是一个
<code>timeval</code>
结构，它指定了定时器的间隔时间，即定时器重复触发的时间周期。<code>timeval</code>
结构包含两个字段：<strong><code>tv_sec</code></strong>（秒）和
<strong><code>tv_usec</code></strong>（微秒）。</p></li>
<li><p><strong><code>it_value</code></strong>：这也是一个
<code>timeval</code>
结构，它指定了定时器的到期时间，即从当前时间到定时器第一次触发的剩余时间。</p></li>
</ul>
<h2 id="setitimer设置定时器">setitimer（设置定时器）</h2>
<p><code>setitimer</code> 是 UNIX 和类 UNIX 系统（包括
Linux）中的一个系统调用，用于设置进程的虚拟、实时或性能定时器。这个系统调用提供了一种机制，允许进程接收定时信号，例如，<code>SIGALRM</code>。</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value, <span class="keyword">struct</span> itimerspec *old_value)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<ul>
<li><strong><code>which</code></strong>：指定要设置的定时器类型，可以是以下之一：
<ul>
<li><code>ITIMER_REAL</code>：实时定时器，基于系统时钟。</li>
<li><code>ITIMER_VIRTUAL</code>：虚拟定时器，基于进程的虚拟执行时间。</li>
<li><code>ITIMER_PROF</code>：性能定时器，用于采样程序的执行时间。</li>
</ul></li>
<li><strong><code>new_value</code></strong>：指向
<code>itimerspec</code> 结构的指针，该结构包含两个 <code>timespec</code>
结构，分别指定定时器的初值和周期值。<code>timespec</code> 结构包含
<code>tv_sec</code>（秒）和 <code>tv_nsec</code>（纳秒）。</li>
<li><strong><code>old_value</code></strong>：指向
<code>itimerspec</code>
结构的指针，用于存储定时器被设置前的旧值。如果设置为
<code>NULL</code>，则忽略旧值。</li>
</ul>
<p>要使用 <code>setitimer</code>
创建一个周期性执行的任务，你需要设置定时器的初值（<code>it_value</code>）和周期值（<code>it_interval</code>），这两者都定义在
<code>itimerspec</code>
结构体中。周期值设置了定时器触发的频率，而初值设置了第一次触发前的时间间隔。</p>
<h2 id="signal-sigaction函数">signal（）/ sigaction（）函数</h2>
<p>在 UNIX 和类 UNIX 系统中，<strong><code>signal</code></strong> 和
<strong><code>sigaction</code></strong>
都是用来处理信号的函数。信号是一种特殊的软件中断，当程序接收到某些事件（比如用户按下
Ctrl+C 或者定时器到期）时，操作系统会发送信号给程序。</p>
<p><code>signal</code>
是一个用于处理异步事件的机制，它允许程序对操作系统发送的信号进行响应。在
UNIX 和类 UNIX 系统（包括
Linux）中，信号是一种软件中断，用于通知进程发生了某个事件，如用户按下中断键（通常是
Ctrl+C），或者系统检测到一个错误条件。</p>
<p>信号可以由多种不同的源触发，包括硬件事件、软件条件或系统调用。它们通常用于中断正在执行的进程，以便进程可以采取适当的行动，比如清理资源、记录日志或优雅地终止。</p>
<p><strong>捕获并自定义处理信号</strong>：进程可以通过
<code>signal</code>
函数来捕获信号，并为其定义自定义的处理函数。这个处理函数将在信号到达时被调用，如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SIGALRM 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGALRM received!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里可以放置你想要周期性执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置信号处理函数</span></span><br><span class="line"><span class="built_in">signal</span>(SIGALRM, signal_handler);</span><br></pre></td></tr></table></figure>
<p><strong><code>sigaction</code></strong> 函数是 <code>signal</code>
函数的现代替代品，它提供了更多的功能和更好的可移植性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">sigaction</span>(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>signum</code></strong>
是要处理的信号的编号。</p></li>
<li><p><strong><code>act</code></strong> 是指向 <code>sigaction</code>
结构的指针，该结构定义了信号的处理方式。</p></li>
<li><p><strong><code>oldact</code></strong> 是指向
<code>sigaction</code> 结构的指针，用于存储旧的信号处理函数。</p></li>
</ul>
<p>使用 <code>sigaction</code>
时，可以更安全地处理信号，并且可以设置信号处理函数的额外属性，如
<code>sa_mask</code>（信号屏蔽字），<code>sa_flags</code>（信号处理标志），以及
<code>sa_handler</code>（信号处理函数）。</p>
<h2 id="signal与-sigaction区别">signal（）与 sigaction（）区别</h2>
<p><code>signal</code> 是较旧的函数，它有一些限制。例如，你不能在
<code>signal</code>
函数中使用某些会阻塞的函数，因为这可能会导致程序无法响应其他信号。而且，<code>signal</code>
函数本身的限制也比较多，比如它不能处理一些新的信号。</p>
<p><code>sigaction</code> 是一个更新的函数，它解决了 <code>signal</code>
的一些问题。使用
<code>sigaction</code>，你可以更安全地处理信号，并且可以设置更多的信号处理选项。例如，可以告诉操作系统在处理信号时是否应该暂停其他信号的接收，这样可以避免在处理一个信号时被另一个信号打断。</p>
<h2 id="sigalrm定时器信号">SIGALRM（定时器信号）</h2>
<p><code>SIGALRM</code>（Signal Alarm）是一个在 UNIX 和类 UNIX
系统（包括
Linux）中广泛使用的信号，它用于处理定时器到期事件。当一个进程设置了闹钟（alarm
clock），并在指定的时间间隔后，<code>SIGALRM</code>
信号会被发送给该进程。这个信号可以用来提醒进程执行某些操作，或者在特定的时间点触发某些事件。</p>
<h2 id="示例">示例</h2>
<p>以下是一个简单的 C 程序示例，演示如何使用 <code>setitimer</code> 和
<code>SIGALRM</code> 信号来创建一个周期性的定时器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGALRM 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGALRM received!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里可以放置你想要周期性执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> its;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器的周期值和初值</span></span><br><span class="line">    its.it_value.tv_sec = <span class="number">2</span>;  <span class="comment">// 2 秒后触发</span></span><br><span class="line">    its.it_value.tv_nsec = <span class="number">0</span>;</span><br><span class="line">    its.it_interval.tv_sec = <span class="number">2</span>; <span class="comment">// 每隔 2 秒触发一次</span></span><br><span class="line">    its.it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setitimer 设置定时器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setitimer</span>(ITIMER_REAL, &amp;its, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环，等待定时器触发</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>(); <span class="comment">// pause 函数会使进程休眠，直到收到 SIGALRM 或其他信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，首先设置了一个信号处理函数 <code>signal_handler</code>
来处理 <code>SIGALRM</code> 信号。然后，使用 <code>setitimer</code>
函数设置了一个周期性的定时器，每隔 2 秒触发一次 <code>SIGALRM</code>
信号。最后，使用 <code>pause</code>
函数进入一个无限循环，等待信号的到来。</p>
<p>信号处理函数 <code>signal_handler</code>
是一个特殊的函数，它在信号到达时被操作系统调用。在这个例子中，<code>signal_handler</code>
函数只是简单地打印一条消息到控制台。每次定时器触发时，<code>signal_handler</code>
都会被调用一次。</p>
<p><strong>注意事项 ：</strong></p>
<ul>
<li>信号处理函数应该尽可能地短小，避免执行复杂的操作，因为这可能会影响系统的信号处理效率。</li>
<li>在信号处理函数中，应该避免使用可能会阻塞的系统调用或库函数。</li>
<li>如果需要长时间运行的操作，应该在信号处理函数中安排这些操作在进程的主体中异步执行。</li>
</ul>
<h2 id="设定定时器与-while-循环有本质的区别">设定定时器与
<code>while</code> 循环有本质的区别</h2>
<ol type="1">
<li><p><strong>异步执行</strong>：
信号处理函数是异步执行的，这意味着它们是由操作系统在信号到达时调用的，而不是程序的主执行流程（如
<code>while</code>
循环）的一部分。这意味着信号处理函数可以在程序的任何地方被调用，而不仅仅是在
<code>while</code> 循环中。</p></li>
<li><p><strong>实时性</strong>： 使用 <code>setitimer</code>
和信号处理函数可以确保某些操作以固定的频率发生，即使程序的主线程正在忙于其他任务。这在需要实时响应的情况下非常有用，例如在嵌入式系统或实时操作系统中。</p></li>
<li><p><strong>主线程的阻塞</strong>： <code>while</code>
循环会阻塞程序的主线程，直到循环条件不再满足。在循环内部执行的任务会连续不断地运行，直到循环结束。而信号处理函数则是在
<code>while</code>
循环之外独立执行的，它们不会阻塞主线程，也不会影响主线程的执行顺序。</p></li>
<li><p><strong>周期性任务的实现方式</strong>： 在 <code>while</code>
循环中实现周期性任务通常需要在循环内部使用延时函数（如
<code>sleep</code>），这会导致程序的整体执行速度降低，因为主线程必须等待延时结束才能继续执行。而使用
<code>setitimer</code>
和信号处理函数，周期性任务是由操作系统在后台管理的，不会影响主线程的执行。</p></li>
</ol>
<p>总结来说，<code>setitimer</code>
和信号处理函数提供了一种异步和实时的方式来周期性地执行任务，而
<code>while</code>
循环提供了一种同步和阻塞的方式来执行任务。选择哪种方式取决于具体需求和程序的设计。</p>
]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>定时器</tag>
        <tag>time.h</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-6.5840 Assignment Instruction</title>
    <url>//posts/3970638095.html</url>
    <content><![CDATA[<h3 id="introduction-介绍">Introduction 介绍</h3>
<p>In this lab you'll build a MapReduce system. You'll implement a
worker process that calls application Map and Reduce functions and
handles reading and writing files, and a master process that hands out
tasks to workers and copes with failed workers. You'll be building
something similar to the <a
href="http://research.google.com/archive/mapreduce-osdi04.pdf">MapReduce
paper</a>. 在本实验中，您将构建一个 MapReduce
系统。您将实施一个调用应用程序 Map 和 Reduce
函数并处理文件读写的工作进程，以及一个将任务分配给工作程序并处理失败的工作程序的主进程。您将构建类似于
<a
href="http://research.google.com/archive/mapreduce-osdi04.pdf">MapReduce
论文</a>的内容。</p>
<h3 id="collaboration-policy-合作政策">Collaboration Policy
合作政策</h3>
<p>You must write all the code you hand in for 6.824, except for code
that we give you as part of assignments. You are not allowed to look at
anyone else's solution, and you are not allowed to look at solutions
from previous years. You may discuss the assignments with other
students, but you may not look at or copy each others' code. The reason
for this rule is that we believe you will learn the most by designing
and implementing your lab solution yourself. 您必须编写为 6.824
提交的所有代码，但我们作为作业的一部分提供给您的代码除外。你不能看别人的解决方案，也不能看前几年的解决方案。您可以与其他学生讨论作业，但不得查看或复制彼此的代码。制定此规则的原因是，我们相信您自己设计和实施实验室解决方案会学到最多。</p>
<p>Please do not publish your code or make it available to current or
future 6.824 students. <code>github.com</code> repositories are public
by default, so please don't put your code there unless you make the
repository private. You may find it convenient to use <a
href="https://github.mit.edu/">MIT's GitHub</a>, but be sure to create a
private repository. 请不要发布您的代码或将其提供给当前或未来的 6.824
学生。 <code>github.com</code>
仓库默认为公有，因此除非您将仓库设为私有，否则请不要将代码放在那里。您可能会发现使用
<a href="https://github.mit.edu/">MIT 的 GitHub</a>
很方便，但请务必创建一个私有存储库。</p>
<h3 id="software-软件">Software 软件</h3>
<p>You'll implement this lab (and all the labs) in <a
href="http://www.golang.org/">Go</a>. The Go web site contains lots of
tutorial information. We will grade your labs using Go version 1.13; you
should use 1.13 too. You can check your Go version by running
<code>go version</code>. 您将在 <a href="http://www.golang.org/">Go</a>
中实现此实验室（以及所有实验室）。Go Web
站点包含许多教程信息。我们将使用 Go 1.13
版对您的实验室进行评分;你也应该使用 1.13。您可以通过运行
<code>go version</code> 来检查您的 Go 版本。</p>
<p>We recommend that you work on the labs on your own machine, so you
can use the tools, text editors, etc. that you are already familiar
with. Alternatively, you can work on the labs on Athena.
我们建议您在自己的计算机上进行实验，以便您可以使用您已经熟悉的工具、文本编辑器等。或者，您可以在
Athena 上进行实验。</p>
<h4 id="macos-macos操作系统">macOS macOS操作系统</h4>
<p>You can use <a href="https://brew.sh/">Homebrew</a> to install Go.
After installing Homebrew, run <code>brew install go</code>. 您可以使用
<a href="https://brew.sh/">Homebrew</a> 安装 Go。安装 Homebrew 后，运行
<code>brew install go</code> .</p>
<h4 id="linux-linux的">Linux Linux的</h4>
<p>Depending on your Linux distribution, you might be able to get an
up-to-date version of Go from the package repository, e.g. by running
<code>apt install golang</code>. Otherwise, you can manually install a
binary from Go's website. First, make sure that you're running a 64-bit
kernel (<code>uname -a</code> should mention "x86_64 GNU/Linux"), and
then run: 根据您的 Linux 发行版，您或许能够从包存储库获取最新版本的
Go，例如，通过运行 <code>apt install golang</code> .否则，您可以从 Go
的网站手动安装二进制文件。首先，确保您运行的是 64 位内核（
<code>uname -a</code> 应该提到 “x86_64 GNU/Linux”），然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget -qO- https://dl.google.com/go/go1.13.6.linux-amd64.tar.gz | sudo tar xz -C /usr/local</span><br></pre></td></tr></table></figure>
<p>You'll need to make sure <code>/usr/local/bin</code> is on your
<code>PATH</code>. 您需要确保 <code>/usr/local/bin</code> 在您的
<code>PATH</code> .</p>
<h4 id="windows-窗户">Windows 窗户</h4>
<p>The labs probably won't work directly on Windows. If you're feeling
adventurous, you can try to get them running inside <a
href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows
Subsystem for Linux</a> and following the Linux instructions above.
Otherwise, you can fall back to Athena. 实验室可能无法直接在 Windows
上运行。如果您喜欢冒险，可以尝试让它们在<a
href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">适用于
Linux 的 Windows 子系统</a>中运行，并按照上面的 Linux
说明进行操作。否则，您可以回退到 Athena。</p>
<h4 id="athena-雅典娜">Athena 雅典娜</h4>
<p>You can log into a public Athena host with
<code>ssh &#123;your kerberos&#125;@athena.dialup.mit.edu</code>. Once you're
logged in, to get Go 1.13, run: 您可以使用
<code>ssh &#123;your kerberos&#125;@athena.dialup.mit.edu</code> .登录后，要获取
Go 1.13，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ setup ggo</span><br></pre></td></tr></table></figure>
<h3 id="getting-started-开始">Getting started 开始</h3>
<p>You'll fetch the initial lab software with <a
href="https://git-scm.com/">git</a> (a version control system). To learn
more about git, look at the <a href="https://git-scm.com/book/en/v2">Pro
Git book</a> or the <a
href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">git
user's manual</a>. To fetch the 6.824 lab software: 您将使用 <a
href="https://git-scm.com/">git</a>（一个版本控制系统）获取初始实验室软件。要了解有关
git 的更多信息，请查看 <a href="https://git-scm.com/book/en/v2">Pro Git
书籍</a>或 <a
href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">git
用户手册</a>。要获取 6.824 lab 软件，请执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824</span><br><span class="line">$ cd 6.824</span><br><span class="line">$ ls</span><br><span class="line">Makefile src</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>We supply you with a simple sequential mapreduce implementation in
<code>src/main/mrsequential.go</code>. It runs the maps and reduces one
at a time, in a single process. We also provide you with a couple of
MapReduce applications: word-count in <code>mrapps/wc.go</code>, and a
text indexer in <code>mrapps/indexer.go</code>. You can run word count
sequentially as follows: 我们为您提供了一个简单的顺序 mapreduce 实现
<code>src/main/mrsequential.go</code>
。它在单个进程中运行映射并逐个缩减。我们还为您提供了几个 MapReduce
应用程序：中的 <code>mrapps/wc.go</code> word-count 和 中的
<code>mrapps/indexer.go</code>
文本索引器。您可以按如下方式按顺序运行字数统计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ cd src/main</span><br><span class="line">$ go build -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ rm mr-out*</span><br><span class="line">$ go run mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>mrsequential.go</code> leaves its output in the file
<code>mr-out-0</code>. The input is from the text files named
<code>pg-xxx.txt</code>. <code>mrsequential.go</code> 将其输出保留在
file <code>mr-out-0</code> .输入来自名为 <code>pg-xxx.txt</code>
的文本文件。</p>
<p>Feel free to borrow code from <code>mrsequential.go</code>. You
should also have a look at <code>mrapps/wc.go</code> to see what
MapReduce application code looks like. 随意从
<code>mrsequential.go</code> 中借用代码。您还应该查看
<code>mrapps/wc.go</code> MapReduce 应用程序代码的外观。</p>
<h3 id="your-job-您的工作">Your Job 您的工作</h3>
<p>Your job is to implement a distributed MapReduce, consisting of two
programs, the master and the worker. There will be just one master
process, and one or more worker processes executing in parallel. In a
real system the workers would run on a bunch of different machines, but
for this lab you'll run them all on a single machine. The workers will
talk to the master via RPC. Each worker process will ask the master for
a task, read the task's input from one or more files, execute the task,
and write the task's output to one or more files. The master should
notice if a worker hasn't completed its task in a reasonable amount of
time (for this lab, use ten seconds), and give the same task to a
different worker. 您的工作是实现一个分布式 MapReduce，它由
两个程序，主程序和工作程序。将会有 只有一个主进程，以及一个或多个在
平行。在实际系统中，worker 将在一堆
不同的计算机，但对于本练习，您将在一台计算机上运行它们。 worker 将通过
RPC 与 master 对话。每个 worker 进程都会询问
任务的主节点，从一个或多个文件中读取任务的输入，
执行任务，并将任务的输出写入一个 或更多文件。master 应该注意到 worker
是否尚未完成 其任务在合理的时间内完成（对于本实验，请使用 10 个
秒），并将相同的任务分配给不同的 worker。</p>
<p>We have given you a little code to start you off. The "main" routines
for the master and worker are in <code>main/mrmaster.go</code> and
<code>main/mrworker.go</code>; don't change these files. You should put
your implementation in <code>mr/master.go</code>,
<code>mr/worker.go</code>, and <code>mr/rpc.go</code>.
我们为您提供了一些代码，以便您开始。master 和 worker 的 “main” 例程位于
<code>main/mrmaster.go</code> 和 <code>main/mrworker.go</code>
;请勿更改这些文件。您应该将实现放在 <code>mr/master.go</code> 、
<code>mr/worker.go</code> 和 <code>mr/rpc.go</code> 中。</p>
<p>Here's how to run your code on the word-count MapReduce application.
First, make sure the word-count plugin is freshly built:
下面介绍如何在字数统计 MapReduce 应用程序上运行代码。首先，确保
word-count 插件是新构建的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build -buildmode=plugin ../mrapps/wc.go</span><br></pre></td></tr></table></figure>
<p>In the <code>main</code> directory, run the master. 在该
<code>main</code> 目录中，运行 master.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm mr-out*</span><br><span class="line">$ go run mrmaster.go pg-*.txt</span><br></pre></td></tr></table></figure>
<p>The <code>pg-*.txt</code> arguments to <code>mrmaster.go</code> are
the input files; each file corresponds to one "split", and is the input
to one Map task. 的 <code>pg-*.txt</code> <code>mrmaster.go</code>
参数是 输入文件;每个文件对应一个 “split”，并且是 input 添加到一个 Map
任务中。</p>
<p>In one or more other windows, run some workers:
在一个或多个其他窗口中，运行一些 worker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go run mrworker.go wc.so</span><br></pre></td></tr></table></figure>
<p>When the workers and master have finished, look at the output in
<code>mr-out-*</code>. When you've completed the lab, the sorted union
of the output files should match the sequential output, like this: 当
worker 和 master 完成后，查看输出 在 <code>mr-out-*</code> .完成实验后，
输出文件的排序并集应与 Sequential 匹配 output 中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat mr-out-* | sort | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>We supply you with a test script in <code>main/test-mr.sh</code>. The
tests check that the <code>wc</code> and <code>indexer</code> MapReduce
applications produce the correct output when given the
<code>pg-xxx.txt</code> files as input. The tests also check that your
implementation runs the Map and Reduce tasks in parallel, and that your
implementation recovers from workers that crash while running tasks.
我们在 中 <code>main/test-mr.sh</code>
为您提供了一个测试脚本。测试将检查 <code>wc</code> 和
<code>indexer</code> MapReduce 应用程序在将 <code>pg-xxx.txt</code>
文件作为输入时是否生成正确的输出。这些测试还会检查您的实施是否并行运行
Map 和 Reduce
任务，以及您的实施是否从运行任务时崩溃的工作程序中恢复。</p>
<p>If you run the test script now, it will hang because the master never
finishes: 如果您现在运行测试脚本，它将挂起，因为 master 从未完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/6.824/src/main</span><br><span class="line">$ sh test-mr.sh</span><br><span class="line">*** Starting wc test.</span><br></pre></td></tr></table></figure>
<p>You can change <code>ret := false</code> to true in the Done function
in <code>mr/master.go</code> so that the master exits immediately. Then:
您可以在 Done 函数中更改为 <code>ret := false</code> true，
<code>mr/master.go</code> 以便主服务器立即退出。然后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sh ./test-mr.sh</span><br><span class="line">*** Starting wc test.</span><br><span class="line">sort: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- wc output is not the same as mr-correct-wc.txt</span><br><span class="line">--- wc test: FAIL</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>The test script expects to see output in files named
<code>mr-out-X</code>, one for each reduce task. The empty
implementations of <code>mr/master.go</code> and
<code>mr/worker.go</code> don't produce those files (or do much of
anything else), so the test fails. 测试脚本希望在名为
<code>mr-out-X</code> 的文件中看到输出，每个 reduce 任务一个。
<code>mr/master.go</code> 和 的 <code>mr/worker.go</code>
空实现不会生成这些文件（或执行其他大部分操作），因此测试失败。</p>
<p>When you've finished, the test script output should look like this:
完成后，测试脚本输出应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sh ./test-mr.sh</span><br><span class="line">*** Starting wc test.</span><br><span class="line">--- wc test: PASS</span><br><span class="line">*** Starting indexer test.</span><br><span class="line">--- indexer test: PASS</span><br><span class="line">*** Starting map parallelism test.</span><br><span class="line">--- map parallelism test: PASS</span><br><span class="line">*** Starting reduce parallelism test.</span><br><span class="line">--- reduce parallelism test: PASS</span><br><span class="line">*** Starting crash test.</span><br><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>You'll also see some errors from the Go RPC package that look like
你还会看到 Go RPC 包中的一些错误，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure>
<p>Ignore these messages. 忽略这些消息。</p>
<p>A few rules: 一些规则：</p>
<ul>
<li>The map phase should divide the intermediate keys into buckets for
<code>nReduce</code> reduce tasks, where <code>nReduce</code> is the
argument that <code>main/mrmaster.go</code> passes to
<code>MakeMaster()</code>. map 阶段应将中间键划分为 reduce 任务的
<code>nReduce</code> 存储桶，其中 <code>nReduce</code> 是
<code>main/mrmaster.go</code> 传递给 的 <code>MakeMaster()</code>
参数。</li>
<li>The worker implementation should put the output of the X'th reduce
task in the file <code>mr-out-X</code>. worker 实现应将第 X 个 reduce
任务的输出放在 file <code>mr-out-X</code> 中。</li>
<li>A <code>mr-out-X</code> file should contain one line per Reduce
function output. The line should be generated with the Go
<code>"%v %v"</code> format, called with the key and value. Have a look
in <code>main/mrsequential.go</code> for the line commented "this is the
correct format". The test script will fail if your implementation
deviates too much from this format. <code>mr-out-X</code> 文件的每个
Reduce 函数输出应包含一行。该行应使用 Go <code>"%v %v"</code>
格式生成，并使用 key 和 value 调用。看看
<code>main/mrsequential.go</code> 评论“This is the correct
format”的那一行。如果您的 implementation
与此格式有太多偏差，则测试脚本将失败。</li>
<li>You can modify <code>mr/worker.go</code>, <code>mr/master.go</code>,
and <code>mr/rpc.go</code>. You can temporarily modify other files for
testing, but make sure your code works with the original versions; we'll
test with the original versions. 您可以修改 <code>mr/worker.go</code> 、
<code>mr/master.go</code> 和 <code>mr/rpc.go</code>
。您可以临时修改其他文件以进行测试，但请确保您的代码与原始版本兼容;我们将使用原始版本进行测试。</li>
<li>The worker should put intermediate Map output in files in the
current directory, where your worker can later read them as input to
Reduce tasks. worker 应该将中间的 Map 输出放在当前目录的文件中，以便
worker 稍后可以将它们作为 Reduce 任务的输入读取。</li>
<li><code>main/mrmaster.go</code> expects <code>mr/master.go</code> to
implement a <code>Done()</code> method that returns true when the
MapReduce job is completely finished; at that point,
<code>mrmaster.go</code> will exit. <code>main/mrmaster.go</code>
<code>mr/master.go</code> 期望实现一个 <code>Done()</code> 在 MapReduce
作业完全完成时返回 true 的方法;此时， <code>mrmaster.go</code>
将退出。</li>
<li>When the job is completely finished, the worker processes should
exit. A simple way to implement this is to use the return value from
<code>call()</code>: if the worker fails to contact the master, it can
assume that the master has exited because the job is done, and so the
worker can terminate too. Depending on your design, you might also find
it helpful to have a "please exit" pseudo-task that the master can give
to workers.
当作业完全完成后，工作进程应退出。实现这一点的一种简单方法是使用 return
value from <code>call()</code> ： 如果 worker 没有联系
master，它可以假设 master 已经退出，因为 job 已经完成，因此 worker
也可以终止。根据您的设计，您可能还会发现 master 可以将其分配给 worker 的
“please exit” 伪任务会很有帮助。</li>
</ul>
<h3 id="hints-提示">Hints 提示</h3>
<ul>
<li><p>One way to get started is to modify <code>mr/worker.go</code>'s
<code>Worker()</code> to send an RPC to the master asking for a task.
Then modify the master to respond with the file name of an
as-yet-unstarted map task. Then modify the worker to read that file and
call the application Map function, as in <code>mrsequential.go</code>.
一种开始的方法是修改 <code>mr/worker.go</code> ， <code>Worker()</code>
将 RPC 发送到 master
请求任务。然后修改主服务器以使用尚未启动的映射任务的文件名进行响应。然后修改
worker 以读取该文件并调用应用程序 Map 函数，如
<code>mrsequential.go</code> .</p></li>
<li><p>The application Map and Reduce functions are loaded at run-time
using the Go plugin package, from files whose names end in
<code>.so</code>. 应用程序 Map 和 Reduce 函数在运行时使用 Go
插件包从名称以 . <code>.so</code></p></li>
<li><p>If you change anything in the <code>mr/</code> directory, you
will probably have to re-build any MapReduce plugins you use, with
something like <code>go build -buildmode=plugin ../mrapps/wc.go</code>
如果你更改 <code>mr/</code>
了目录中的任何内容，你可能必须重新构建你使用的任何 MapReduce
插件，如下所示
<code>go build -buildmode=plugin ../mrapps/wc.go</code></p></li>
<li><p>This lab relies on the workers sharing a file system. That's
straightforward when all workers run on the same machine, but would
require a global filesystem like GFS if the workers ran on different
machines. 此实验室依赖于共享文件系统的工作程序。当所有 worker
都在同一台机器上运行时，这很简单，但如果 worker
在不同机器上运行，则需要像 GFS 这样的全局文件系统。</p></li>
<li><p>A reasonable naming convention for intermediate files is
<code>mr-X-Y</code>, where X is the Map task number, and Y is the reduce
task number. 中间文件的合理命名约定是 <code>mr-X-Y</code> ，其中 X 是
Map 任务编号，Y 是 reduce 任务编号。</p></li>
<li><p>The worker's map task code will need a way to store intermediate
key/value pairs in files in a way that can be correctly read back during
reduce tasks. One possibility is to use Go's</p></li>
</ul>
<pre><code>encoding/json

 package. To write key/value pairs to a JSON file:


worker 的 map 任务代码将需要一种方法来存储中间 键/值对，以便正确读回 在 减少 任务 期间。一种可能性是使用 Go 的包 `encoding/json` 。自 将键/值对写入 JSON 文件：

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := ... &#123;</span><br><span class="line">  err := enc.Encode(&amp;kv)</span><br></pre></td></tr></table></figure>

and to read such a file back:


并要读回这样的文件：

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> kv KeyValue</span><br><span class="line">  <span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>The map part of your worker can use the <code>ihash(key)</code>
function (in <code>worker.go</code>) to pick the reduce task for a given
key. worker 的 map 部分可以使用 <code>ihash(key)</code> 函数 （in
<code>worker.go</code> ） 为给定的 key 选择 reduce 任务。</p></li>
<li><p>You can steal some code from <code>mrsequential.go</code> for
reading Map input files, for sorting intermedate key/value pairs between
the Map and Reduce, and for storing Reduce output in files.
您可以从中窃取一些代码 <code>mrsequential.go</code> ，用于读取 Map
输入文件，在 Map 和 Reduce 之间对中间键/值对进行排序，以及将 Reduce
输出存储在文件中。</p></li>
<li><p>The master, as an RPC server, will be concurrent; don't forget to
lock shared data. master 作为 RPC
服务器，将是并发的;不要忘记锁定共享数据。</p></li>
<li><p>Use Go's race detector, with <code>go build -race</code> and
<code>go run -race</code>. <code>test-mr.sh</code> has a comment that
shows you how to enable the race detector for the tests. 使用 Go 的 race
检测器，其中有 <code>go build -race</code> 和 <code>go run -race</code>
。 <code>test-mr.sh</code>
有一个注释，向您展示如何为测试启用争用检测器。</p></li>
<li><p>Workers will sometimes need to wait, e.g. reduces can't start
until the last map has finished. One possibility is for workers to
periodically ask the master for work, sleeping with
<code>time.Sleep()</code> between each request. Another possibility is
for the relevant RPC handler in the master to have a loop that waits,
either with <code>time.Sleep()</code> or <code>sync.Cond</code>. Go runs
the handler for each RPC in its own thread, so the fact that one handler
is waiting won't prevent the master from processing other RPCs. Worker
有时需要等待，例如，在最后一个 map 完成之前，减少无法启动。一种可能性是
worker 定期向 master 请求工作，在每次请求之间休
<code>time.Sleep()</code> 眠。另一种可能性是主服务器中的相关 RPC
处理程序有一个等待的循环，要么是 或 <code>time.Sleep()</code>
<code>sync.Cond</code> 。Go 在自己的线程中运行每个 RPC
的处理程序，因此一个处理程序正在等待的事实不会阻止 master 处理其他
RPC。</p></li>
<li><p>The master can't reliably distinguish between crashed workers,
workers that are alive but have stalled for some reason, and workers
that are executing but too slowly to be useful. The best you can do is
have the master wait for some amount of time, and then give up and
re-issue the task to a different worker. For this lab, have the master
wait for ten seconds; after that the master should assume the worker has
died (of course, it might not have). 主节点无法可靠地区分崩溃的
worker、存活但由于某种原因而停滞的 worker 以及正在执行但太慢而无法使用的
worker。你能做的最好的事情是让 master
等待一段时间，然后放弃并将任务重新分配给不同的
worker。对于此实验室，让主服务器等待 10 秒;之后，master 应该假设 worker
已经死亡（当然，它可能没有）。</p></li>
<li><p>To test crash recovery, you can use the
<code>mrapps/crash.go</code> application plugin. It randomly exits in
the Map and Reduce functions. 要测试崩溃恢复，您可以使用
<code>mrapps/crash.go</code> 应用程序插件。它会在 Map 和 Reduce
函数中随机退出。</p></li>
<li><p>To ensure that nobody observes partially written files in the
presence of crashes, the MapReduce paper mentions the trick of using a
temporary file and atomically renaming it once it is completely written.
You can use <code>ioutil.TempFile</code> to create a temporary file and
<code>os.Rename</code> to atomically rename it.
为了确保在崩溃的情况下没有人观察到部分写入的文件，MapReduce
论文提到了使用临时文件并在完全写入后对其进行原子重命名的技巧。您可以使用
<code>ioutil.TempFile</code> 创建临时文件并 <code>os.Rename</code>
对其进行原子重命名。</p></li>
<li><p><code>test-mr.sh</code> runs all the processes in the
sub-directory <code>mr-tmp</code>, so if something goes wrong and you
want to look at intermediate or output files, look there.<br />
<code>test-mr.sh</code> 运行 sub directory <code>mr-tmp</code>
中的所有进程，因此如果出现问题并且您想查看中间文件或输出文件，请查看那里。</p></li>
</ul>
<h3 id="handin-procedure-handin-程序">Handin procedure Handin 程序</h3>
<p>Before submitting, please run <code>test-mr.sh</code> one final time.
在提交之前，请最后一次运行 <code>test-mr.sh</code> 。</p>
<p>Use the <code>make lab1</code> command to package your lab assignment
and upload it to the class's submission website, located at
https://6824.scripts.mit.edu/2020/handin.py/. 使用该
<code>make lab1</code> 命令打包您的实验室作业并将其上传到位于
https://6824.scripts.mit.edu/2020/handin.py/ 的课程提交网站。</p>
<p>You may use your MIT Certificate or request an API key via email to
log in for the first time. Your API key (<code>XXX</code>) is displayed
once you logged in, which can be used to upload lab1 from the console as
follows. 首次登录时，您可以使用 MIT 证书或通过电子邮件请求 API
密钥。登录后，将显示您的 API 密钥 （ <code>XXX</code>
），该密钥可用于从控制台上传 lab1，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ echo XXX &gt; api.key</span><br><span class="line">$ make lab1</span><br></pre></td></tr></table></figure>
<p>Check the submission website to make sure it thinks you submitted
this lab! 检查提交网站，确保它认为您提交了此实验！</p>
<p>You may submit multiple times. We will use the timestamp of your
<strong>last</strong> submission for the purpose of calculating late
days.
您可以多次提交。我们将使用您<strong>上次</strong>提交的时间戳来计算逾期天数。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>MIT</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.828 实验记录 (一)</title>
    <url>//posts/2756843955.html</url>
    <content><![CDATA[<p>大二学习操作系统的时候，老师给我们介绍了MIT6.828的实验，由于课程安排的原因，我们并没有完成MIT6.828太多的实验，记忆中应该是只看了和xv6相关的内容辅助理解操作系统，以至于我现在几乎忘记了当时做了哪些实验。趁大三上课不是很多，想重新自己完整完成这7个实验。
## Part 0: 6.828 Build Environment</p>
<ul>
<li>虚拟机环境：Ubuntu 18.04（64位）</li>
<li>仿真器（qemu）：<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li>
<li>实验代码（lab）：<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code></li>
</ul>
<p>虚拟机环境<code>32位</code>，因为<code>JOS</code>就是32位的操作系统。
仿真器使用MIT进行patch过的(见上链接)。原因是实验中分页机制是有意修改过的，使用<code>patched version</code>的话在后面<code>Exercise</code>中不需要手动转换地址。
关于实验代码，默认熟悉<code>Git</code>和<code>MakeFile</code>。每做完一个<code>Exercise</code>可以使用<code>make grade</code>进行测试。
<code>./configure</code>时候可能会出现库缺失导致无法完成配置，可以根据报错提示将缺失的库重新安装补全，Google一下。详细的搭建过程见<a
href="https://pdos.csail.mit.edu/6.828/2018/tools.html#">Tools
Guide</a>。</p>
<p>关于Tool
Guide中给出的配置指令，如果<code>[--prefix=PFX]</code>参数没有指定的话，默认会安装在<code>/usr/local/share/qemu</code>中，这个目录需要管理员权限才能修改，所以安装时需要使用<code>sudo make install</code></p>
<p>关于在<code>make install</code>过程中可能会出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:</span><br><span class="line">/qemu/qga/commands-posix.c:633: undefined reference to `major&#x27;</span><br><span class="line">/usr/bin/ld: /qemu/qga/commands-posix.c:634: undefined reference to `minor&#x27;</span><br></pre></td></tr></table></figure>
<p>解决办法是：在<code>/qemu/qga/commands-posix.c</code>头文件中插入<code>#include &lt;sys/sysmacros.h&gt;</code></p>
<hr />
<h2 id="part-1-pc-bootstrap">Part 1: PC Bootstrap</h2>
<p>如果您还不熟悉 x86 汇编语言，那么在本课程中您将很快熟悉它！<a
href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC
汇编语言手册</a>是一个很好的起点。希望这本书包含新旧材料的混合供你参考。</p>
<p><em>警告：</em>不幸的是，书中的例子是为 NASM
汇编器编写的，而我们将使用 GNU 汇编器。NASM 使用所谓的 <em>Intel</em>
语法，而 GNU 使用 <em>AT&amp;T</em>
语法。虽然在语义上是等效的，但程序集文件将有很大差异，至少在表面上是这样，具体取决于使用的语法。幸运的是，两者之间的转换非常简单，<a
href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan's
Guide to Inline Assembly</a> 中对此进行了介绍。</p>
<blockquote>
<p>Exercise 1. Familiarize yourself with the assembly language materials
available on <a
href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828
reference page</a>. You don't have to read them now, but you'll almost
certainly want to refer to some of this material when reading and
writing x86 assembly. We do recommend reading the section "The Syntax"
in <a
href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan's
Guide to Inline Assembly</a>. It gives a good (and quite brief)
description of the AT&amp;T assembly syntax we'll be using with the GNU
assembler in JOS.</p>
</blockquote>
<h3 id="simulating-the-x86">Simulating the x86</h3>
<p>我们不是在真实的物理个人计算机 （PC）
上开发操作系统，而是使用忠实模拟完整 PC
的程序：您为仿真器编写的代码也可以在真实 PC
上启动。使用仿真器可以简化调试;例如，您可以在模拟的 x86
中设置断点，这对于 x86 的 Silicon 版本来说很难做到。 在 6.828
中，我们将使用 <a href="http://www.qemu.org/">QEMU
Emulator</a>，这是一种现代且相对较快的仿真器。虽然 QEMU
的内置监视器仅提供有限的调试支持，但 QEMU 可以充当 <a
href="http://www.gnu.org/software/gdb/">GNU 调试器</a> （GDB）
的远程调试目标，我们将在本实验中使用它来逐步完成早期启动过程。</p>
<p>接下来我们就可以编译并尝试在QEMU上运行JOS了，进入之前clone的lab文件夹，执行make指令，可以看到下面的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$ make</span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">ld: warning: section `.bss<span class="string">&#x27; type changed to PROGBITS</span></span><br><span class="line"><span class="string">+ as boot/boot.S</span></span><br><span class="line"><span class="string">+ cc -Os boot/main.c</span></span><br><span class="line"><span class="string">+ ld boot/boot</span></span><br><span class="line"><span class="string">boot block is 397 bytes (max 510)</span></span><br><span class="line"><span class="string">+ mk obj/kern/kernel.img</span></span><br></pre></td></tr></table></figure>
<p>这就表示已经成功编译出了镜像文件。
现在可以运行qemu，将上面创建的<code>obj/kern/kernel.img</code>作为模拟PC的“虚拟硬盘”的内容提供。这个硬盘映像包含我们的引导加载程序
（ <code>obj/boot/boot</code> ） 和内核 （ <code>obj/kernel</code>
）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$ make qemu</span><br><span class="line">sed <span class="string">&quot;s/localhost:1234/localhost:26000/&quot;</span> &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure>
<p>要退出QEMU，请键入 <code>Ctrl+a x</code></p>
<h3 id="the-pcs-physical-address-space">The PC's Physical Address
Space</h3>
<p>PC 的物理地址空间是硬连线的，具有以下常规布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>第一台基于 16 位 Intel 8088 处理器的 PC 只能寻址 1MB
的物理内存。因此，早期 PC 的物理地址空间将从 0x00000000 开始，但以
0x000FFFFF 结束，而不是 0xFFFFFFFF。标记为“Low Memory”的 640KB
区域是早期 PC 唯一<em>可以使用的随机</em>存取存储器
（RAM）;事实上，最早的 PC 只能配置 16KB、32KB 或 64KB 的 RAM！</p>
<p>从 0x000A0000 到 0x000FFFFF 的 384KB
区域由硬件保留用于特殊用途，例如视频显示缓冲区和非易失性存储器中保存的固件。此保留区域最重要的部分是基本输入/输出系统
（BIOS），它占据了从 0x000F0000 到 0x000FFFFF 的 64KB 区域。在早期的 PC
中，BIOS 保存在真正的只读存储器 （ROM） 中，但当前的 PC 将 BIOS
存储在可更新的闪存中。BIOS
负责执行基本的系统初始化，例如激活视频卡和检查安装的内存量。执行此初始化后，BIOS
会从某个适当的位置（如软盘、硬盘、CD-ROM
或网络）加载操作系统，并将计算机的控制权传递给操作系统。</p>
<p>当英特尔最终用分别支持 16MB 和 4GB 物理地址空间的 80286 和 80386
处理器“打破 1MB 的障碍”时，PC 架构师仍然保留了 1MB
物理地址空间的原始布局，以确保与现有软件的向后兼容性。因此，现代 PC
在物理内存上有一个从 0x000A0000 到 0x00100000 的“漏洞”，将 RAM
分为“低内存”或“传统内存”（前
640KB）和“扩展内存”（其他所有内存）。此外，PC 的 32
位物理地址空间最顶部的一些空间（尤其是物理 RAM）现在通常由 BIOS 保留供
32 位 PCI 设备使用。</p>
<p>最新的 x86 处理器可以支持<em>超过</em> 4GB 的物理 RAM，因此 RAM
可以进一步扩展到 0xFFFFFFFF 以上。在这种情况下，BIOS 必须在系统 RAM 的
32 位可寻址区域顶部留出<em>第二个</em>孔，以便为这些 32
位设备留出空间进行映射。由于设计限制，JOS 无论如何都会只使用 PC
物理内存的前 256MB，所以现在我们假设所有 PC 都“只有”一个 32
位的物理地址空间。但是，处理复杂的物理地址空间和多年来发展起来的硬件组织的其他方面是操作系统开发的重要实际挑战之一。</p>
<h3 id="the-rom-bios">The ROM BIOS</h3>
<p>打开两个终端窗口和 cd 两个 shell
进入您的实验室目录。在一个版本中，输入 <code>make qemu-gdb</code>
。这将启动 QEMU，但 QEMU 在处理器执行第一条指令并等待来自 GDB
的调试连接之前停止。在第二个终端中，从您运行的同一目录中运行
<code>make gdb</code>。然后应该就能看到下面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$  make gdb</span><br><span class="line">gdb -n -x .gdbinit</span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the &quot;file&quot; command.</span><br><span class="line">warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration</span><br><span class="line">of GDB.  Attempting to continue with the default i8086 settings.</span><br><span class="line"></span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br></pre></td></tr></table></figure>
<p><code>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b</code>是GDB对QEMU执行的第一条指令的反汇编。</p>
<ul>
<li><p>IBM PC 从物理地址 <code>0x000ffff0</code> 开始执行，该地址位于为
ROM BIOS 保留的 64KB 区域的最顶部。</p></li>
<li><p>PC 以 <code>CS(Code Segment) = 0xf000</code> 和
<code>IP(Instruction Pointer) = 0xfff0</code> 开始执行。</p></li>
<li><p>要执行的第一条指令是一条 <code>jmp</code>
指令，该指令跳转到分段地址 <code>CS = 0xf000</code> 和
<code>IP = 0xe05b</code> 。</p></li>
</ul>
<p>这条指令 <code>0xffff0: ljmp $0xf000,$0xe05b</code>
是一个远跳转（<code>ljmp</code>）指令，它用于将程序的执行流跳转到特定的段和偏移地址。
<code>0xffff0</code>: 这是指令在内存中的地址，意味着当前指令位于内存的
<code>0xFFFF0</code> 地址处。<code>ljmp $0xf000, $0xe05b</code>:
这是一条远跳转指令（long jump，简称
<code>ljmp</code>），它包含两个部分：</p>
<ul>
<li><strong>段选择符</strong> <code>$0xf000</code>:
段寄存器的值，即代码段的基地址。</li>
<li><strong>偏移地址</strong> <code>$0xe05b</code>:
相对于段基地址的偏移量。</li>
</ul>
<p>在 x86
保护模式之前的实模式下，内存地址是通过段和偏移组合的形式访问的：</p>
<ul>
<li><code>物理地址 = 段选择符 × 16 + 偏移地址</code></li>
</ul>
<p>因此，执行这条指令后，CPU 会跳转到段 <code>$0xf000</code> 和偏移
<code>$0xe05b</code> 组合形成的物理地址：</p>
<ul>
<li>物理地址 = <code>0xf000 * 16 + 0xe05b</code></li>
<li>物理地址 = <code>0xf0000 + 0xe05b = 0xfe05b</code></li>
</ul>
<p>这种指令通常出现在系统启动时（例如，BIOS 启动阶段）。当 CPU
加电或者复位时，它会从 <code>0xFFFF0</code>
这个地址开始执行，通常这是一条跳转指令，将 CPU 引导到系统 BIOS
的实际启动代码处。</p>
<p><strong>实模式 (Real Mode)</strong></p>
<p>实模式是x86处理器上电或重置后默认的工作模式，最早用于<strong>8086</strong>处理器，并且向后兼容现代处理器。</p>
<ul>
<li><strong>内存寻址</strong>：处理器只能访问 <strong>1MB</strong>
的内存空间。这是由于实模式只能使用20位地址（段寄存器16位+偏移量16位，实际结果为20位地址线）。</li>
<li><strong>段寄存器</strong>：内存寻址采用分段机制，内存地址是通过段寄存器和偏移量相加来计算的。例如，物理地址
= <code>段基址 × 16 + 偏移量</code>。</li>
<li><strong>没有内存保护</strong>：在实模式下，程序可以直接访问任何内存地址，导致多个程序之间可能会互相覆盖内存，容易出现系统崩溃。</li>
<li><strong>多任务处理</strong>：没有内建的硬件支持多任务处理，处理器无法有效地管理多个程序的并行执行。</li>
<li><strong>应用</strong>：实模式主要用于早期的操作系统（如DOS），以及一些简单的嵌入式系统。</li>
</ul>
<p><strong>保护模式 (Protected Mode)</strong></p>
<p>保护模式是现代x86处理器的主要工作模式，最早引入于<strong>80286</strong>处理器，后来在<strong>80386</strong>及以后的处理器中得到了大幅改进。</p>
<ul>
<li><strong>内存寻址</strong>：使用32位地址总线，最多可以寻址
<strong>4GB</strong>
的内存。并且支持更复杂的内存管理机制，如分页（Paging）和虚拟内存（Virtual
Memory）。</li>
<li><strong>段管理</strong>：保护模式中的段寄存器不再简单地提供段基址，而是与<strong>全局描述符表（GDT）</strong>和<strong>局部描述符表（LDT）</strong>关联，提供段保护。每个段都有自己的权限、大小等信息。</li>
<li><strong>内存保护</strong>：每个程序运行在自己的地址空间内，处理器能够检测非法的内存访问。通过段和分页机制，操作系统可以防止不同程序互相干扰，增强系统的稳定性和安全性。</li>
<li><strong>多任务处理</strong>：硬件支持多任务处理，处理器能够通过任务状态段（TSS）快速切换任务。内存保护机制使得每个任务在自己的地址空间中运行，确保系统的稳定性。</li>
<li><strong>虚拟内存</strong>：保护模式支持虚拟内存，通过分页机制将虚拟地址映射到物理地址，允许程序使用比实际物理内存更大的地址空间。</li>
<li><strong>应用</strong>：所有现代操作系统（如Windows、Linux、macOS）都运行在保护模式下。</li>
</ul>
<p><strong>实模式和保护模式的对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>实模式</th>
<th>保护模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存寻址</td>
<td>最大 1MB</td>
<td>最大 4GB（支持分页）</td>
</tr>
<tr>
<td>段寄存器</td>
<td>简单的段+偏移</td>
<td>与 GDT/LDT 关联，支持权限</td>
</tr>
<tr>
<td>内存保护</td>
<td>无内存保护</td>
<td>内存保护，防止进程冲突</td>
</tr>
<tr>
<td>多任务处理</td>
<td>不支持</td>
<td>支持，硬件层面支持</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>不支持</td>
<td>支持（通过分页实现）</td>
</tr>
<tr>
<td>应用场景</td>
<td>早期操作系统、嵌入式系统</td>
<td>现代操作系统和应用</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Exercise 2. Use GDB's si (Step Instruction) command to trace into the
ROM BIOS for a few more instructions, and try to guess what it might be
doing. You might want to look at <a
href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">Phil
Storrs I/O Ports Description</a>, as well as other materials on the <a
href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828
reference materials page</a>. No need to figure out all the details -
just the general idea of what the BIOS is doing first.</p>
</blockquote>
<p>当 BIOS 运行时，它会设置中断描述符表并初始化各种设备，例如 VGA
显示器。这就是您在 QEMU 窗口中看到的 “ <code>Starting SeaBIOS</code> ”
消息的来源。 在初始化 PCI 总线和 BIOS
知道的所有重要设备后，它会搜索可启动设备，例如软盘、硬盘驱动器或
CD-ROM。最终，当它找到可启动磁盘时，BIOS 会从磁盘中读取 <em>boot
loader</em> 并将控制权转移给它。</p>
<h2 id="part-2-the-boot-loader">Part 2: The Boot Loader</h2>
<p>用于 PC 的软盘和硬盘被划分为 512
字节的区域，称为<em>扇区</em>。扇区是磁盘的最小传输粒度：每个读取或写入操作的大小必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可引导的，则第一个扇区称为<em>引导扇区</em>，因为这是引导加载程序代码所在的位置。当
BIOS 找到可启动的软盘或硬盘时，它会将 512
字节的引导扇区加载到物理地址的内存中，0x7c00 到 0x7dff，然后使用
<code>jmp</code> 指令将 CS：IP 设置为 <code>0000:7c00</code>
，将控制权传递给引导加载程序。与 BIOS 加载地址一样，这些地址相当任意 -
但它们对于 PC 来说是固定和标准化的。</p>
<p>在 PC 的发展过程中，从 CD-ROM 启动的能力出现得要晚得多，因此 PC
架构师借此机会稍微重新考虑了启动过程。因此，现代 BIOS 从 CD-ROM
启动的方式稍微复杂一些（也更强大）。CD-ROM 使用的扇区大小为 2048
字节而不是 512 字节，并且 BIOS
可以在将控制权转移到磁盘之前将更大的引导映像从磁盘加载到内存中（而不仅仅是一个扇区）。有关更多信息，请参见<a
href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El
Torito”可启动 CD-ROM 格式规范</a>。</p>
<p>然而，对于
6.828，我们将使用传统的硬盘驱动器启动机制，这意味着我们的启动加载程序必须适合区区
512 字节。引导加载程序由一个汇编语言源文件 <code>boot/boot.S</code>
和一个 C 源文件组成， <code>boot/main.c</code>
请仔细查看这些源文件，并确保您了解发生了什么。引导加载程序必须执行两个主要功能：</p>
<ol type="1">
<li>首先，boot loader 将处理器从实模式切换到 <em>32
位保护模式</em>，因为只有在这种模式下，软件才能访问处理器物理地址空间中
1MB 以上的所有内存。保护模式在 <a
href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC
汇编语言</a>的 1.2.7 和 1.2.8 节中简要描述，在 Intel
架构手册中也有非常详细的描述。此时，您只需要了解分段地址
（segment：offset pairs）
到物理地址的转换在保护模式下的发生方式不同，并且在转换后偏移量是 32
位而不是 16 位。</li>
<li>其次，引导加载程序通过 x86 的特殊 I/O 指令直接访问 IDE
磁盘设备寄存器，从硬盘读取内核。如果您想更好地理解此处的特定 I/O
指令的含义，请查看 <a
href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828
参考页面上的</a>“IDE
硬盘驱动器控制器”部分。在本课程中，您不需要学习太多有关特定设备编程的知识：编写设备驱动程序实际上是操作系统开发中非常重要的部分，但从概念或体系结构的角度来看，它也是最不有趣的部分之一。</li>
</ol>
<p>了解引导加载程序源代码后，请查看文件 <code>obj/boot/boot.asm</code>
.这个文件是我们的 GNUmakefile 在编译 boot loader <em>后</em>创建的 boot
loader 的反汇编。这个反汇编文件可以很容易地看到所有 boot loader
代码在物理内存中的确切位置，并且更容易跟踪在 GDB 中单步执行 boot loader
时发生的情况。同样， <code>obj/kern/kernel.asm</code> 包含 JOS
内核的反汇编，这通常对调试很有用。</p>
<p>您可以使用该 <code>b</code> 命令在 GDB 中设置地址断点。例如，
<code>b *0x7c00</code> 在地址 <code>0x7C00</code>
处设置断点。到达断点后，您可以使用 c and si 命令继续执行： c 使 QEMU
继续执行，直到下一个断点（或直到您按下 <code>Ctrl-C</code> ），并
<code>si N</code> 一次单步执行 <em><code>N</code></em> 指令。</p>
<p>要检查内存中的指令（除了 GDB
自动打印的下一个要执行的指令），请使用命令 <code>x/i</code>
。此命令的语法 <code>x/Ni ADDR</code> 为 ，其中 <em>N</em>
是要反汇编的连续指令数，<em>ADDR</em> 是开始反汇编的内存地址。</p>
<blockquote>
<p>Exercise 3. Take a look at the <a
href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools
guide</a>, especially the section on GDB commands. Even if you're
familiar with GDB, this includes some esoteric GDB commands that are
useful for OS work. Set a breakpoint at address 0x7c00, which is where
the boot sector will be loaded. Continue execution until that
breakpoint. Trace through the code in <code>boot/boot.S</code>, using
the source code and the disassembly file <code>obj/boot/boot.asm</code>
to keep track of where you are. Also use the <code>x/i</code> command in
GDB to disassemble sequences of instructions in the boot loader, and
compare the original boot loader source code with both the disassembly
in <code>obj/boot/boot.asm</code> and GDB. Trace into
<code>bootmain()</code> in <code>boot/main.c</code>, and then into
<code>readsect()</code>. Identify the exact assembly instructions that
correspond to each of the statements in <code>readsect()</code>. Trace
through the rest of <code>readsect()</code> and back out into
<code>bootmain()</code>, and identify the begin and end of the
<code>for</code> loop that reads the remaining sectors of the kernel
from the disk. Find out what code will run when the loop is finished,
set a breakpoint there, and continue to that breakpoint. Then step
through the remainder of the boot loader.</p>
</blockquote>
<p>Quesiton：</p>
<ol type="1">
<li><p>At what point does the processor start executing 32-bit code?
What exactly causes the switch from 16- to 32-bit mode?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses </span><br><span class="line"># identical to their physical addresses, so that the </span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">  7c1e:	0f 01 16             	lgdtl  (%esi)</span><br><span class="line">  7c21:	64 7c 0f             	fs jl  7c33 &lt;protcseg+0x1&gt;</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">  7c24:	20 c0                	and    %al,%al</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">  7c26:	66 83 c8 01          	or     $0x1,%ax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line">  7c2a:	0f 22 c0             	mov    %eax,%cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line">  7c2d:	ea                   	.byte 0xea</span><br><span class="line">  7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh</span><br></pre></td></tr></table></figure>
<p>在这里，引导程序从实模式切换到保护模式，支持更大的内存访问，在GDT（Global
Descriptor
Table）加载完成之后，处理器就可以开始处理32位指令了，</p></li>
<li><p>What is the <em>last</em> instruction of the boot loader
executed, and what is the <em>first</em> instruction of the kernel it
just loaded?</p></li>
<li><p><em>Where</em> is the first instruction of the kernel?</p></li>
<li><p>How does the boot loader decide how many sectors it must read in
order to fetch the entire kernel from disk? Where does it find this
information?</p></li>
</ol>
<h3 id="loading-the-kernel">Loading the Kernel</h3>
<p>现在，我们将更详细地查看引导加载程序的 C 语言部分。
<code>boot/main.c</code> 但在此之前，现在是停下来回顾一下 C
编程的一些基础知识的好时机。</p>
<blockquote>
<p>Exercise 4. Read about programming with pointers in C. The best
reference for the C language is <em>The C Programming Language</em> by
Brian Kernighan and Dennis Ritchie (known as 'K&amp;R'). We recommend
that students purchase this book (here is an <a
href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&amp;s=books">Amazon
Link</a>) or find one of <a
href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&amp;doc_library=MIT01&amp;doc_number=000355242&amp;year=&amp;volume=&amp;sub_library=">MIT's
7 copies</a>. Read 5.1 (Pointers and Addresses) through 5.5 (Character
Pointers and Functions) in K&amp;R. Then download the code for <a
href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>,
run it, and make sure you understand where all of the printed values
come from. In particular, make sure you understand where the pointer
addresses in printed lines 1 and 6 come from, how all the values in
printed lines 2 through 4 get there, and why the values printed in line
5 are seemingly corrupted. There are other references on pointers in C
(e.g., <a
href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A
tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as
strongly recommended. <em>Warning:</em> Unless you are already
thoroughly versed in C, do not skip or even skim this reading exercise.
If you do not really understand pointers in C, you will suffer untold
pain and misery in subsequent labs, and then eventually come to
understand them the hard way. Trust us; you don't want to find out what
"the hard way" is.</p>
</blockquote>
<p>要弄清楚这一点， <code>boot/main.c</code> 您需要知道什么是 ELF
二进制文件。编译和链接 C 程序（如 JOS 内核）时，编译器会将每个 C 源 （'
<code>.c</code> '） 文件转换为<em>一个对象</em> （' <code>.o</code> '）
文件，其中包含以硬件所需的二进制格式编码的汇编语言指令。然后，链接器将所有已编译的目标文件组合成一个<em>二进制映像</em>，例如
<code>obj/kern/kernel</code> ，在本例中是 ELF
格式的二进制文件，代表“可执行和可链接格式”。</p>
<p>有关此格式的完整信息可在<a
href="https://pdos.csail.mit.edu/6.828/2018/reference.html">我们的参考页面上</a><a
href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">的 ELF
规范</a>中找到，但您无需在本课程中深入研究此格式的详细信息。尽管整体格式非常强大和复杂，但大多数复杂的部分都是为了支持共享库的动态加载，我们不会在本课程中这样做。<a
href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">维基百科页面</a>有一个简短的描述。</p>
<p>对于 6.828，您可以将 ELF
可执行文件视为具有加载信息的标头，后跟几个<em>程序部分</em>，每个部分都是要加载到指定地址的内存中的连续代码块或数据。引导加载程序不会修改代码或数据;它会将其加载到内存中并开始执行它。</p>
<p>ELF 二进制文件以固定长度的 <em>ELF
标头</em>开头，后跟一个可变长度的<em>程序标头</em>，其中列出了要加载的每个程序部分。这些
ELF 标头的 C 定义位于 <code>inc/elf.h</code>
中。我们感兴趣的节目部分是：</p>
<ul>
<li><code>.text</code> ：程序的可执行指令。</li>
<li><code>.rodata</code> ：只读数据，例如 C 编译器生成的 ASCII
字符串常量。（但是，我们不会费心设置硬件来禁止写入。）</li>
<li><code>.data</code> ：data
部分保存程序的初始化数据，例如使用初始化器声明的全局变量，如
<code>int x = 5;</code> .</li>
</ul>
<p>当链接器计算程序的内存布局时，它会为<em>未初始化的</em>全局变量保留空间，例如
<code>int x;</code> ，在内存中紧随其后的 <code>.data</code> 名为 section
<code>.bss</code> called 中。C
要求“未初始化”的全局变量以零值开头。因此，无需在 ELF
二进制文件中存储内容 <code>.bss</code> ;相反，链接器仅记录
<code>.bss</code> 节的地址和大小。加载器或程序本身必须将
<code>.bss</code> 部分归零。</p>
<p>通过键入以下内容，检查内核可执行文件中所有部分的名称、大小和链接地址的完整列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$ objdump -h obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001925  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000704  f0101940  00101940  00002940  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00003a15  f0102044  00102044  00003044  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001989  f0105a59  00105a59  00006a59  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .bss          00000648  f0112300  00112300  00013300  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .comment      0000002a  00000000  00000000  00013948  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>这些信息通常包含在程序的可执行文件中，但不会由程序加载器加载到内存中。</p>
<p>请特别注意该 <code>.text</code> 部分的 “VMA” （或<em>链接地址</em>）
和 “LMA”
（或<em>加载地址</em>）。节的加载地址是该节应加载到内存中的内存地址。</p>
<p>节的 link address 是 section
预期执行的内存地址。链接器以各种方式对二进制文件中的链接地址进行编码，例如，当代码需要全局变量的地址时，结果是如果二进制文件从未链接的地址执行，则二进制文件通常不起作用。（可以生成不包含任何此类绝对地址的<em>与位置无关</em>的代码。这被现代共享库广泛使用，但它有性能和复杂性成本，因此我们不会在
6.828 中使用它。</p>
<p>通常，链路地址和加载地址相同。例如，查看 boot loader
<code>.text</code> 的部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$ objdump -h obj/boot/boot.out</span><br><span class="line"></span><br><span class="line">obj/boot/boot.out:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000018d  00007c00  00007c00  00000074  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br><span class="line">  1 .stab         0000084c  00000000  00000000  00000204  2**2</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  2 .stabstr      00000862  00000000  00000000  00000a50  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  3 .comment      0000002a  00000000  00000000  000012b2  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>引导加载程序使用 ELF
<em>程序头</em>文件来决定如何加载这些部分。程序头文件指定要加载到内存中的
ELF
对象的哪些部分，以及每个部分应占用的目标地址。您可以通过键入以下内容来检查程序头文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/lab$ objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">obj/kern/kernel</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x000073e2 memsz 0x000073e2 flags r-x</span><br><span class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</span><br><span class="line">         filesz 0x0000a948 memsz 0x0000a948 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001925  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000704  f0101940  00101940  00002940  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00003a15  f0102044  00102044  00003044  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001989  f0105a59  00105a59  00006a59  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .bss          00000648  f0112300  00112300  00013300  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .comment      0000002a  00000000  00000000  00013948  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">f0100000 l    d  .text	00000000 .text</span><br><span class="line">f0101940 l    d  .rodata	00000000 .rodata</span><br><span class="line">f0102044 l    d  .stab	00000000 .stab</span><br><span class="line">f0105a59 l    d  .stabstr	00000000 .stabstr</span><br><span class="line">f0108000 l    d  .data	00000000 .data</span><br><span class="line">f0112300 l    d  .bss	00000000 .bss</span><br><span class="line">00000000 l    d  .comment	00000000 .comment</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 obj/kern/entry.o</span><br><span class="line">f010002f l       .text	00000000 relocated</span><br><span class="line">f010003e l       .text	00000000 spin</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 entrypgdir.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 init.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 console.c</span><br><span class="line">f01001a0 l     F .text	0000000e delay</span><br><span class="line">f01001ae l     F .text	00000020 serial_proc_data</span><br><span class="line">f01001ce l     F .text	00000041 cons_intr</span><br><span class="line">f0112320 l     O .bss	00000208 cons</span><br><span class="line">f010058a l     F .text	0000010c kbd_proc_data</span><br><span class="line">f0112304 l     O .bss	00000001 serial_exists</span><br><span class="line">f010029a l     F .text	000001f0 cons_putc</span><br><span class="line">f0112310 l     O .bss	00000002 crt_pos</span><br><span class="line">f011230c l     O .bss	00000004 crt_buf</span><br><span class="line">f0112308 l     O .bss	00000004 addr_6845</span><br><span class="line">f0112300 l     O .bss	00000004 shift.1300</span><br><span class="line">f0101a00 l     O .rodata	00000100 shiftcode</span><br><span class="line">f0101b00 l     O .rodata	00000100 togglecode</span><br><span class="line">f0101c00 l     O .rodata	00000010 charcode</span><br><span class="line">f0112000 l     O .data	00000100 normalmap</span><br><span class="line">f0112100 l     O .data	00000100 shiftmap</span><br><span class="line">f0112200 l     O .data	00000100 ctlmap</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 monitor.c</span><br><span class="line">f0101df4 l     O .rodata	00000018 commands</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 printf.c</span><br><span class="line">f010094d l     F .text	00000013 putch</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 kdebug.c</span><br><span class="line">f0100960 l     F .text	00000101 stab_binsearch</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 printfmt.c</span><br><span class="line">f0100c40 l     F .text	000000e8 printnum</span><br><span class="line">f0100d28 l     F .text	0000003a getuint</span><br><span class="line">f0100d62 l     F .text	0000001d sprintputch</span><br><span class="line">f0102018 l     O .rodata	0000001c error_string</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 readline.c</span><br><span class="line">f0112540 l     O .bss	00000400 buf</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*	00000000 string.c</span><br><span class="line">f010000c g       .text	00000000 entry</span><br><span class="line">f0101339 g     F .text	00000020 strcpy</span><br><span class="line">f010020f g     F .text	00000012 kbd_intr</span><br><span class="line">f01006a0 g     F .text	0000000a mon_backtrace</span><br><span class="line">f0100085 g     F .text	0000005f _panic</span><br><span class="line">f0100141 g     F .text	0000005b i386_init</span><br><span class="line">f01014e0 g     F .text	0000007c memmove</span><br><span class="line">f01011cf g     F .text	00000028 snprintf</span><br><span class="line">f0100d7f g     F .text	000003f8 vprintfmt</span><br><span class="line">f010023c g     F .text	00000043 cons_getc</span><br><span class="line">f0100933 g     F .text	0000001a cprintf</span><br><span class="line">f010155c g     F .text	00000021 memcpy</span><br><span class="line">f0101220 g     F .text	000000d3 readline</span><br><span class="line">f0111000 g     O .data	00001000 entry_pgtable</span><br><span class="line">f01000e4 g     F .text	0000005d test_backtrace</span><br><span class="line">f0101177 g     F .text	00000058 vsnprintf</span><br><span class="line">f0112300 g       .bss	00000000 edata</span><br><span class="line">f010049a g     F .text	000000f0 cons_init</span><br><span class="line">f0105a58 g       .stab	00000000 __STAB_END__</span><br><span class="line">f0105a59 g       .stabstr	00000000 __STABSTR_BEGIN__</span><br><span class="line">f01017f0 g     F .text	00000135 .hidden __umoddi3</span><br><span class="line">f0100221 g     F .text	0000001b serial_intr</span><br><span class="line">f01016c0 g     F .text	00000128 .hidden __udivdi3</span><br><span class="line">f0100290 g     F .text	0000000a iscons</span><br><span class="line">f01015da g     F .text	000000e4 strtol</span><br><span class="line">f0101318 g     F .text	00000021 strnlen</span><br><span class="line">f0101359 g     F .text	0000002c strcat</span><br><span class="line">f0112944 g     O .bss	00000004 panicstr</span><br><span class="line">f0112940 g       .bss	00000000 end</span><br><span class="line">f0100040 g     F .text	00000045 _warn</span><br><span class="line">f0101464 g     F .text	0000001d strfind</span><br><span class="line">f0101925 g       .text	00000000 etext</span><br><span class="line">0010000c g       .text	00000000 _start</span><br><span class="line">f01013b1 g     F .text	00000033 strlcpy</span><br><span class="line">f010140a g     F .text	00000039 strncmp</span><br><span class="line">f0101385 g     F .text	0000002c strncpy</span><br><span class="line">f010157d g     F .text	00000040 memcmp</span><br><span class="line">f010048a g     F .text	00000010 cputchar</span><br><span class="line">f0101481 g     F .text	0000005f memset</span><br><span class="line">f010027f g     F .text	00000011 getchar</span><br><span class="line">f01011f7 g     F .text	00000028 printfmt</span><br><span class="line">f01073e1 g       .stabstr	00000000 __STABSTR_END__</span><br><span class="line">f01013e4 g     F .text	00000026 strcmp</span><br><span class="line">f0100a61 g     F .text	000001d6 debuginfo_eip</span><br><span class="line">f0100900 g     F .text	00000033 vcprintf</span><br><span class="line">f0110000 g       .data	00000000 bootstacktop</span><br><span class="line">f0110000 g     O .data	00001000 entry_pgdir</span><br><span class="line">f0108000 g       .data	00000000 bootstack</span><br><span class="line">f0102044 g       .stab	00000000 __STAB_BEGIN__</span><br><span class="line">f0101300 g     F .text	00000018 strlen</span><br><span class="line">f0101443 g     F .text	00000021 strchr</span><br><span class="line">f01006aa g     F .text	000000ca mon_kerninfo</span><br><span class="line">f01007bd g     F .text	00000143 monitor</span><br><span class="line">f01015bd g     F .text	0000001d memfind</span><br><span class="line">f0100774 g     F .text	00000049 mon_help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Exercise 5. Trace through the first few instructions of the boot
loader again and identify the first instruction that would "break" or
otherwise do the wrong thing if you were to get the boot loader's link
address wrong. Then change the link address in
<code>boot/Makefrag</code> to something wrong, run make clean, recompile
the lab with make, and trace into the boot loader again to see what
happens. Don't forget to change the link address back and make clean
again afterward!</p>
</blockquote>
<p>在一个<code>terminal</code>中cd到<code>lab</code>目录下，执行
<code>make qemu-gdb</code>。再开一个
<code>terminal</code>执行<code>make gdb</code>。 因为BIOS会把boot
loader加载到0x7c00的位置，因此设置断点<code>b *0x7c00</code>。再执行<code>c</code>,会看到QUMU终端上显示<code>Booting from hard disk</code>。
执行<code>x/30i 0x7c00</code>就能看到与<code>boot.S</code>中类似的汇编代码了。</p>
<p>BIOS会将引导扇区的内容加载到 0x7c00
的位置，引导程序也就从0x7C00的位置开始执行。我们通过<code>-Ttext 0x7C00</code>将链接地址传递给<code>boot / Makefrag</code>中的链接器，因此链接器将在生成的代码中生成正确的内存地址。
除了部分信息之外，ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>。该字段保存程序中入口点的链接地址：程序应该开始执行的代码段的存储地址。
在反汇编代码中，可以看到最后call 了 0x10018地址。</p>
<p>boot loader程序，最后会调用entry point</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return!</span></span><br><span class="line">((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>
<p>通过boot.asm文件，可以得知，我们的entry地址是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">   7d71:	ff 15 18 00 01 00    	call   *0x10018</span><br></pre></td></tr></table></figure>
<p>与实际执行<code>objdump -f kernel</code>的 结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./obj/kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Exercise 6.</strong> We can examine memory using GDB's x
command. The <a
href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB
manual</a> has full details, but for now, it is enough to know that the
command x/<em>N</em>x <em>ADDR</em> prints <em><code>N</code></em> words
of memory at <em><code>ADDR</code></em>. (Note that both
'<code>x</code>'s in the command are lowercase.) <em>Warning</em>: The
size of a word is not a universal standard. In GNU assembly, a word is
two bytes (the 'w' in xorw, which stands for word, means 2 bytes).</p>
</blockquote>
<p>答案应该很明显，在BIOS进入Boot
loader时，0x100000内存后的8个字都为零，因为此时内核程序还没有加载进入内存。
内核的加载在<code>bootmain</code>函数中完成。
若需要用gdb调试，可以使用<code>x/8x 0x100000</code> 查看其内存内容。</p>
<h2 id="part-3-the-kernel">Part 3: The Kernel</h2>
<h3 id="using-virtual-memory-to-work-around-position-dependence">Using
virtual memory to work around position dependence</h3>
<p>操作系统内核通常喜欢在非常高的<em>虚拟地址</em>（例如0xf0100000）上链接和运行，以便将处理器虚拟地址空间的较低部分留给用户程序使用。这种安排的原因将在下一个实验中变得更加清楚。
许多机器在地址 0xf0100000
处没有任何物理内存，因此我们不能指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址
0xf0100000（内核代码<em>预期</em>运行的链接地址）映射到物理地址
0x00100000（引导加载程序将内核加载到物理内存中）。这样，虽然内核的虚拟地址足够高，可以为用户进程留下足够的地址空间，但它将被加载到物理内存中，位于
PC RAM 中的 1MB 点处，就在 BIOS ROM 上方。这种方法要求 PC
至少有几兆字节的物理内存（以便物理地址 0x00100000 有效），但这对于 1990
年左右制造的任何 PC 来说可能都是如此。</p>
<blockquote>
<p><strong>Exercise 7.</strong> Use QEMU and GDB to trace into the JOS
kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at
0x00100000 and at 0xf0100000. Now, single step over that instruction
using the stepi GDB command. Again, examine memory at 0x00100000 and at
0xf0100000. Make sure you understand what just happened. What is the
first instruction <em>after</em> the new mapping is established that
would fail to work properly if the mapping weren't in place? Comment out
the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace
into it, and see if you were right.</p>
</blockquote>
<p>在执行<code>movl％eax，％cr0</code>之前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x1000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<p>之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x1000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb)  x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x34000004      0x1000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure>
<p>虚拟地址<code>0xf0100000</code>已经被映射到<code>0x00100000</code>处
在修改cr0之前修改了cr3寄存器。将地址<code>0x118000</code>写入了页目录寄存器，页目录表应该就是存放在地址<code>0x118000</code>处。其他操作应该是由<code>entry_pgdir</code>的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">	<span class="comment">// Map VA&#x27;s [0, 4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">	[<span class="number">0</span>]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">	<span class="comment">// Map VA&#x27;s [KERNBASE, KERNBASE+4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">	[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成了映射。使得再读取<code>0xf0100000</code>地址时，自动映射到了<code>0~4M</code>的某个位置</p>
<blockquote>
<p>CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。</p>
</blockquote>
<p>注释掉kern/entry.S中的<code>movl %eax, %cr0</code>因为没有开启分页虚拟存储机制，当访问高位地址时，会出现RAM
or ROM 越界错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:      add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74              movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line">(gdb) si</span><br><span class="line">Remote connection closed</span><br></pre></td></tr></table></figure>
<p>在执行0xf010002c之后就出错了</p>
<h3 id="formatted-printing-to-the-console">Formatted Printing to the
Console</h3>
<blockquote>
<p><strong>Exercise 8.</strong> We have omitted a small fragment of code
- the code necessary to print octal numbers using patterns of the form
"%o". Find and fill in this code fragment.</p>
</blockquote>
<p>就是把%u的代码复制一遍，base 改为 8 就差不多了，并不复杂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">	<span class="comment">// Replace this with your code.</span></span><br><span class="line">          num = getuint(&amp;ap, lflag);</span><br><span class="line">          base = <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Explain the interface between <code>printf.c</code> and
<code>console.c</code>. Specifically, what function does
<code>console.c</code> export? How is this function used by
<code>printf.c</code>?</p>
</blockquote>
<p>printf.c中使用了console.c
中的<code>cputchar</code>函数，并封装为<code>putch</code>函数。并以函数形参传递到printfmt.c中的<code>vprintfmt</code>函数，用于向屏幕上输出一个字符。</p>
<blockquote>
<p>Explain the following from <code>console.c</code>:</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">	memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">		crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>CRT_ROWS，CRT_COLS：CRT显示器行列最大值， 此处是<em>25x80</em></li>
<li>ctr_buf 在初始化时指向了显示器I/O地址</li>
<li><code>memmove</code> 没有理清哪个是源，哪个是目的。
按理解清除第一行的数据，应该第二个是源。即2~n行的数据（CRT_SIZE -
CRT_COLS）个，移动到1~n-1行的位置。</li>
</ul>
<blockquote>
<p>For the following questions you might wish to consult the notes for
Lecture 2. These notes cover GCC's calling convention on the x86.</p>
</blockquote>
<p>在kern/init.c的<code>i386_init()</code>下加入代码，就可以直接测试；加Lab1_exercise8_3标号的目的是为了在kern/kernel.asm反汇编代码中容易找到添加的代码的位置。可以看到地址在<code>0xf0100080</code>处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lab1 Exercise_8</span><br><span class="line">&#123;</span><br><span class="line">    cprintf(&quot;Lab1_Exercise_8:\n&quot;);</span><br><span class="line">    int x = 1, y = 3, z = 4;</span><br><span class="line">    // </span><br><span class="line">    Lab1_exercise8_3:</span><br><span class="line">    cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br><span class="line"></span><br><span class="line">    unsigned int i = 0x00646c72;</span><br><span class="line">    cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;) </span><br><span class="line">可以看到以上地址处就存了字符串</span><br><span class="line">(gdb) x/s 0xf010478d</span><br><span class="line">0xf010478d:    &quot;x %d, y %x, z %d\n&quot;</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf0102f85 &lt;vcprintf&gt;:    push   %ebp</span><br><span class="line">vcprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;, ap=0xf0118fc4 &quot;\001&quot;)</span><br><span class="line">    at kern/printf.c:18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) x/16b 0xf0118fc4</span><br><span class="line">0xf0118fc4:    0x01    0x00    0x00    0x00    0x03    0x00    0x00    0x00</span><br><span class="line">0xf0118fcc:    0x04    0x00    0x00    0x00    0x7b    0x47    0x10    0xf0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; 0xf0100a41 &lt;vcprintf&gt;:       push   %ebp</span><br><span class="line">vcprintf (fmt=0xf0101a97 &quot;6828 decimal is %o octal!\n&quot;, ap=0xf010efd4 &quot;\254\032&quot;) at kern/printf.c:18</span><br><span class="line">18      &#123;</span><br><span class="line"></span><br><span class="line">(gdb) x/s 0xf0101a97</span><br><span class="line">0xf0101a97:     &quot;6828 decimal is %o octal!\n&quot;</span><br></pre></td></tr></table></figure>
<h3 id="the-stack">The Stack</h3>
<blockquote>
<p><strong>Exercise 9.</strong> Determine where the kernel initializes
its stack, and exactly where in memory its stack is located. How does
the kernel reserve space for its stack? And at which "end" of this
reserved area is the stack pointer initialized to point to?</p>
</blockquote>
<ul>
<li>entry.S 77行初始化栈</li>
<li>栈的位置是0xf0108000-0xf0110000</li>
<li>设置栈的方法是在kernel的数据段预留32KB空间(entry.S 92行)</li>
<li>栈顶的初始化位置是0xf0110000</li>
</ul>
<blockquote>
<p><strong>Exercise 10.</strong> To become familiar with the C calling
conventions on the x86, find the address of the
<code>test_backtrace</code> function in
<code>obj/kern/kernel.asm</code>, set a breakpoint there, and examine
what happens each time it gets called after the kernel starts. How many
32-bit words does each recursive nesting level of
<code>test_backtrace</code> push on the stack, and what are those
words?</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">test_backtrace(int x)</span><br><span class="line">&#123;</span><br><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">f0100045:	e8 91 01 00 00       	call   f01001db &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">f010004a:	81 c3 be 02 01 00    	add    $0x102be,%ebx</span><br><span class="line">f0100050:	8b 75 08             	mov    0x8(%ebp),%esi</span><br><span class="line">	cprintf(&quot;entering test_backtrace %d\n&quot;, x);</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 38 17 ff ff    	lea    -0xe8c8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 f5 09 00 00       	call   f0100a58 &lt;cprintf&gt;</span><br><span class="line">	if (x &gt; 0)</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f0100066:	85 f6                	test   %esi,%esi</span><br><span class="line">f0100068:	7e 29                	jle    f0100093 &lt;test_backtrace+0x53&gt;</span><br><span class="line">		test_backtrace(x-1);</span><br><span class="line">f010006a:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f010006d:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f0100070:	50                   	push   %eax</span><br><span class="line">f0100071:	e8 ca ff ff ff       	call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">f0100076:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">	else</span><br><span class="line">		mon_backtrace(0, 0, 0);</span><br><span class="line">	cprintf(&quot;leaving test_backtrace %d\n&quot;, x);</span><br><span class="line">f0100079:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f010007c:	56                   	push   %esi</span><br><span class="line">f010007d:	8d 83 54 17 ff ff    	lea    -0xe8ac(%ebx),%eax</span><br><span class="line">f0100083:	50                   	push   %eax</span><br><span class="line">f0100084:	e8 cf 09 00 00       	call   f0100a58 &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f0100089:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010008c:	8d 65 f8             	lea    -0x8(%ebp),%esp</span><br><span class="line">f010008f:	5b                   	pop    %ebx</span><br><span class="line">f0100090:	5e                   	pop    %esi</span><br><span class="line">f0100091:	5d                   	pop    %ebp</span><br><span class="line">f0100092:	c3                   	ret    </span><br><span class="line">		mon_backtrace(0, 0, 0);</span><br><span class="line">f0100093:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f0100096:	6a 00                	push   $0x0</span><br><span class="line">f0100098:	6a 00                	push   $0x0</span><br><span class="line">f010009a:	6a 00                	push   $0x0</span><br><span class="line">f010009c:	e8 f5 07 00 00       	call   f0100896 &lt;mon_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d3                	jmp    f0100079 &lt;test_backtrace+0x39&gt;</span><br></pre></td></tr></table></figure>
<p>上面是asm中完整的test_backtrace函数定义。</p>
<blockquote>
<p><strong>Exercise 11.</strong> Implement the backtrace function as
specified above. Use the same format as in the example, since otherwise
the grading script will be confused. When you think you have it working
right, run make grade to see if its output conforms to what our grading
script expects, and fix it if it doesn't. <em>After</em> you have handed
in your Lab 1 code, you are welcome to change the output format of the
backtrace function any way you like.</p>
<p><strong>Exercise 12.</strong> Modify your stack backtrace function to
display, for each <code>eip</code>, the function name, source file name,
and line number corresponding to that <code>eip</code>. In
<code>debuginfo_eip</code>, where do <code>__STAB_*</code> come from?
This question has a long answer; to help you to discover the answer,
here are some things you might want to do:</p>
<ul>
<li>look in the file <code>kern/kernel.ld</code> for
<code>__STAB_*</code></li>
<li>run objdump -h obj/kern/kernel</li>
<li>run objdump -G obj/kern/kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format
-DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of
loading the kernel binary</li>
</ul>
<p>Complete the implementation of <code>debuginfo_eip</code> by
inserting the call to <code>stab_binsearch</code> to find the line
number for an address. Add a <code>backtrace</code> command to the
kernel monitor, and extend your implementation of
<code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print
a line for each stack frame of the form:</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure></p>
<p>Each line gives the file name and line within that file of the stack
frame's <code>eip</code>, followed by the name of the function and the
offset of the <code>eip</code> from the first instruction of the
function (e.g., <code>monitor+106</code> means the return
<code>eip</code> is 106 bytes past the beginning of
<code>monitor</code>). Be sure to print the file and function names on a
separate line, to avoid confusing the grading script. Tip: printf format
strings provide an easy, albeit obscure, way to print
non-null-terminated strings like those in STABS tables.
<code>printf("%.*s", length, string)</code> prints at most
<code>length</code> characters of <code>string</code>. Take a look at
the printf man page to find out why this works. You may find that some
functions are missing from the backtrace. For example, you will probably
see a call to <code>monitor()</code> but not to <code>runcmd()</code>.
This is because the compiler in-lines some function calls. Other
optimizations may cause you to see unexpected line numbers. If you get
rid of the <code>-O2</code> from <code>GNUMakefile</code>, the
backtraces may make more sense (but your kernel will run more
slowly).</p>
</blockquote>
<p>需要实现monitor.c中的一个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line">     ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp!=<span class="number">0</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,ebp,eip, *(ebp+<span class="number">2</span>), *(ebp+<span class="number">3</span>), *(ebp+<span class="number">4</span>), *(ebp+<span class="number">5</span>), *(ebp+<span class="number">6</span>));</span><br><span class="line">        ebp  = (<span class="type">uint32_t</span>*) *ebp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mon_backtrace</code>函数中调用的<code>read_ebp()</code>函数声明在
<code>inc/x86.h</code>中，函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __inline <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">read_ebp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    __asm __volatile(<span class="string">&quot;movl %%ebp,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (ebp));</span><br><span class="line">    <span class="keyword">return</span> ebp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就已经可以输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ebp f010ff08  eip f01000a1  args 00000000 00000000 00000000 f010004a f0111308</span><br></pre></td></tr></table></figure>
<p>但是，还需要获取eip对应的文件名，行号，函数名等信息。</p>
<p>在阅读实验指导书之后，发现代码提供了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">debuginfo_eip</span><span class="params">(<span class="type">uintptr_t</span> eip, <span class="keyword">struct</span> Eipdebuginfo *info)</span>;</span><br></pre></td></tr></table></figure>
<p>用于eip信息的获取，直接调用并输出结构体中的信息就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">	ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">uint32_t</span> eip = *(ebp+<span class="number">1</span>);</span><br><span class="line">		debuginfo_eip(eip,&amp;info);</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,ebp,eip, *(ebp+<span class="number">2</span>), *(ebp+<span class="number">3</span>), *(ebp+<span class="number">4</span>), *(ebp+<span class="number">5</span>), *(ebp+<span class="number">6</span>));</span><br><span class="line">		cprintf(<span class="string">&quot;%s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ebp[<span class="number">1</span>] - info.eip_fn_addr);</span><br><span class="line">        ebp  = (<span class="type">uint32_t</span>*) *ebp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程中发现，行号的获取始终是0，查阅代码的时候发现行号的获取需要自己实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line"><span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line"><span class="comment">// If not found, return -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//	There&#x27;s a particular stabs type used for line numbers.</span></span><br><span class="line"><span class="comment">//	Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line"><span class="comment">//	which one. N_SLINE</span></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">   <span class="keyword">if</span> (lline &gt; rline)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure>
<p>原来输出是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ebp f010ffa8  eip f0100076  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">kern/init.c:0: test_backtrace:F(0,1)=(0,1)+54</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ebp f010ffa8  eip f0100076  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">kern/init.c:16 test_backtrace+54</span><br></pre></td></tr></table></figure>
<p>make grade 成功通过测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tommygong@TommyGong:~/MIT-6.828/lab$ make grade</span><br><span class="line">make clean</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/tommygong/MIT-6.828/lab&#x27;</span></span><br><span class="line"><span class="built_in">rm</span> -rf obj .gdbinit jos.in qemu.log</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/tommygong/MIT-6.828/lab&#x27;</span></span><br><span class="line">./grade-lab1 </span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/tommygong/MIT-6.828/lab&#x27;</span></span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">ld: warning: section `.bss<span class="string">&#x27; type changed to PROGBITS</span></span><br><span class="line"><span class="string">+ as boot/boot.S</span></span><br><span class="line"><span class="string">+ cc -Os boot/main.c</span></span><br><span class="line"><span class="string">+ ld boot/boot</span></span><br><span class="line"><span class="string">boot block is 396 bytes (max 510)</span></span><br><span class="line"><span class="string">+ mk obj/kern/kernel.img</span></span><br><span class="line"><span class="string">make[1]: Leaving directory &#x27;</span>/home/tommygong/MIT-6.828/lab<span class="string">&#x27;</span></span><br><span class="line"><span class="string">running JOS: (1.2s) </span></span><br><span class="line"><span class="string">  printf: OK </span></span><br><span class="line"><span class="string">  backtrace count: OK </span></span><br><span class="line"><span class="string">  backtrace arguments: OK </span></span><br><span class="line"><span class="string">  backtrace symbols: OK </span></span><br><span class="line"><span class="string">  backtrace lines: OK </span></span><br><span class="line"><span class="string">Score: 50/50</span></span><br></pre></td></tr></table></figure>
<p>最后还要添加一下指令支持，修改一下<em>static</em> struct Command
commands<em>[]</em>即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display the call stack&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="part-5-note">Part 5: Note</h2>
<p>终于是写完了，断断续续持续了一个学期吧，期间有别的实验需要写。也就在期末才有空余的时间来重新看一下这个实验。
老实说，这个实验上手难度还是有一点的，哪怕我学完了操作系统，计算机组成原理，体系结构等课程，回来看这个实验的前大半部分还是比较难以理解。
所幸英语水平在不断提高，学的东西也在不断变多。
编写代码的部分不是很多，主要是对整个过程有一个清晰的认识，才是这个lab1所困难的地方。</p>
]]></content>
      <tags>
        <tag>MIT</tag>
        <tag>6.828</tag>
        <tag>JOS</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.828 实验记录 (二)</title>
    <url>//posts/1297384559.html</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>在本实验中，您将为操作系统编写内存管理代码。内存管理有两个组成部分。</p>
<p>第一个组件是内核的物理内存分配器， 以便内核可以分配内存并随后释放它。
你的分配器将以 4096 字节为单位进行操作，称为
<em>页面</em>。您的任务是维护数据结构，记录哪些物理页是空闲的、哪些是已分配的，以及有多少进程正在共享每个分配的页。您还将编写分配和释放内存页的例程。</p>
<p>内存管理的第二个组成部分是<em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。
x86 硬件的内存管理单元 (MMU)
在指令使用内存时执行映射，并查阅一组页表。您将修改 JOS
以根据我们提供的规范设置 MMU 的页表。</p>
<h2 id="getting-started">Getting started</h2>
<p>在本实验和未来的实验中，您将逐步构建您的内核。我们还将为您提供一些额外的来源。要获取该源，请使用
Git 提交自提交实验 1
以来所做的更改（如果有），获取课程存储库的最新版本，然后创建一个名为的本地分支
<code>lab2</code> 基于我们的 lab2 分支， <code>origin/lab2</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">athena% cd ~/6.828/lab</span><br><span class="line">athena% add git</span><br><span class="line">athena% git pull</span><br><span class="line">Already up-to-date.</span><br><span class="line">athena% git checkout -b lab2 origin/lab2</span><br><span class="line">Branch lab2 set up to track remote branch refs/remotes/origin/lab2.</span><br><span class="line">Switched to a new branch &quot;lab2&quot;</span><br><span class="line">athena% </span><br></pre></td></tr></table></figure>
<p>这里我们因为是推送到自己仓库的，所以指令要修改一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add jos https://pdos.csail.mit.edu/6.828/2018/jos.git</span><br><span class="line">git checkout -b lab2 jos/lab2</span><br><span class="line">git branch --set-upstream-to=origin/lab2 lab2</span><br></pre></td></tr></table></figure>
<p>这 git checkout -b
上面显示的命令实际上做了两件事：它首先创建一个本地分支 <code>lab2</code>
这是基于 <code>origin/lab2</code>
分支由课程工作人员提供，其次，它改变了你的内容 <code>lab</code>
目录来反映存储在的文件 <code>lab2</code> 分支。 Git
允许使用以下方式在现有分支之间切换 git checkout <em>branch-name</em>
，尽管您应该在切换到另一个分支之前在一个分支上提交所有未完成的更改。</p>
<p>在某些情况下，Git
可能无法弄清楚如何将您的更改与新的实验作业合并（例如，如果您修改了第二个实验作业中更改的某些代码）。在这种情况下，
git merge
命令会告诉您哪些文件有<em>冲突</em>，您应该首先解决冲突（通过编辑相关文件），然后使用以下命令提交生成的文件
git commit -a 。</p>
<p>实验 2 包含以下新源文件，您应该浏览这些文件：</p>
<ul>
<li><code>inc/memlayout.h</code></li>
<li><code>kern/pmap.c</code></li>
<li><code>kern/pmap.h</code></li>
<li><code>kern/kclock.h</code></li>
<li><code>kern/kclock.c</code></li>
</ul>
<p><code>memlayout.h</code> 描述了必须通过修改来实现的虚拟地址空间的布局
<code>pmap.c</code> 。 <code>memlayout.h</code> 和 <code>pmap.h</code>
定义<code>PageInfo</code> 您将使用它来跟踪哪些页面的结构
物理内存是空闲的。 <code>kclock.c</code> 和 <code>kclock.h</code> 操纵
PC 的电池供电时钟和 CMOS RAM 硬件， 其中 BIOS 记录 PC 包含的物理内存量，
除其他事项外。 代码在 <code>pmap.c</code>
需要读取该设备硬件才能弄清楚有多少物理内存，但这部分代码已经为您完成：您不需要了解
CMOS 硬件如何工作的详细信息。</p>
<p>特别注意 <code>memlayout.h</code> 和 <code>pmap.h</code>
，因为本实验要求您使用并理解它们包含的许多定义。您可能想查看
<code>inc/mmu.h</code> ，因为它还包含许多对本实验有用的定义。</p>
<p>在此实验和后续实验中，完成实验中描述的所有常规练习以及<em>至少一个</em>挑战问题。
（当然，有些挑战问题比其他问题更具挑战性！）此外，写下实验中提出的问题的简短答案，以及您为解决所选挑战问题所做的工作的简短描述（例如，一两段）。如果您实现了多个挑战问题，您只需在文章中描述其中一个问题，当然我们也欢迎您做更多的事情。将写入的内容放在名为的文件中
<code>answers-lab2.txt</code> 在你的顶层 <code>lab</code>
交作业前的目录。</p>
<h2 id="part-1-physical-page-management">Part 1: Physical Page
Management</h2>
<p>操作系统必须跟踪物理 RAM 的哪些部分是空闲的以及哪些部分当前正在使用。
JOS以<em>页粒度</em>管理PC的物理内存，以便可以使用MMU来映射和保护每块分配的内存。</p>
<p>您现在将编写物理页分配器。它通过<code>struct PageInfo</code>对象的链接列表（与
xv6
不同，它们<em>不</em>嵌入空闲页面本身）来跟踪哪些页面是空闲的，每个对象对应于一个物理页面。您需要先编写物理页分配器，然后才能编写其余的虚拟内存实现，因为页表管理代码需要分配物理内存来存储页表。</p>
<blockquote>
<p><strong>Exercise 1.</strong> In the file <code>kern/pmap.c</code>,
you must implement code for the following functions (probably in the
order given).</p>
<p>boot_alloc()</p>
<p><code>mem_init()</code> (only up to the call to
<code>check_page_free_list(1)</code>)</p>
<p>page_init()</p>
<p>page_alloc()</p>
<p>page_free()</p>
<p><code>check_page_free_list()</code> and
<code>check_page_alloc()</code> test your physical page allocator. You
should boot JOS and see whether <code>check_page_alloc()</code> reports
success. Fix your code so that it passes. You may find it helpful to add
your own <code>assert()</code>s to verify that your assumptions are
correct.</p>
</blockquote>
<p>本实验以及所有 6.828
实验将要求您做一些侦探工作，以准确弄清楚您需要做什么。此作业并未描述您必须添加到
JOS 的代码的所有详细信息。在 JOS
源代码中查找您必须修改的部分的注释；这些评论通常包含规范和提示。您还需要查看
JOS 的相关部分、Intel 手册，或许还需要查看 6.004 或 6.033 注释。</p>
<h2 id="part-2-virtual-memory">Part 2: Virtual Memory</h2>
<p>在做任何其他事情之前，先熟悉 x86
的保护模式内存管理架构：即<em>分段</em>和<em>页面转换</em>。</p>
<blockquote>
<p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a
href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel
80386 Reference Manual</a>, if you haven't done so already. Read the
sections about page translation and page-based protection closely (5.2
and 6.4). We recommend that you also skim the sections about
segmentation; while JOS uses the paging hardware for virtual memory and
protection, segment translation and segment-based protection cannot be
disabled on the x86, so you will need a basic understanding of it.</p>
</blockquote>
<h3 id="virtual-linear-and-physical-addresses">Virtual, Linear, and
Physical Addresses</h3>
<p>在 x86
术语中，<em>虚拟地址</em>由段选择器和段内的偏移量组成。<em>线性地址</em>是在段转换之后但在页转换之前获得的地址。<em>物理地址</em>是经过段和页转换后最终获得的地址，以及最终通过硬件总线发送到
RAM 的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br></pre></td></tr></table></figure>
<p>AC指针是虚拟地址的“偏移”部分。在 <code>boot/boot.S</code>
，我们安装了一个全局描述符表（GDT），它通过将所有段基地址设置为 0
并限制为<code>0xffffffff</code>来有效禁用段转换。因此，“选择器”不起作用，线性地址始终等于虚拟地址的偏移量。在实验
3
中，我们必须与分段进行更多交互以设置权限级别，但对于内存翻译，我们可以在整个
JOS 实验室中忽略分段，而只关注页面翻译。</p>
<p>回想一下，在实验 1 的第 3
部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000
处运行，即使它实际上加载到 ROM BIOS 上方的物理内存中的 0x00100000
处。这个页表只映射了4MB的内存。在本实验中您将为 JOS
设置的虚拟地址空间布局中，我们将对其进行扩展以映射从虚拟地址 0xf0000000
开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。</p>
<blockquote>
<p><strong>Exercise 3.</strong> While GDB can only access QEMU's memory
by virtual address, it's often useful to be able to inspect physical
memory while setting up virtual memory. Review the QEMU <a
href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor
commands</a> from the lab tools guide, especially the <code>xp</code>
command, which lets you inspect physical memory. To access the QEMU
monitor, press Ctrl-a c in the terminal (the same binding returns to the
serial console).</p>
<p>Use the xp command in the QEMU monitor and the x command in GDB to
inspect memory at corresponding physical and virtual addresses and make
sure you see the same data.</p>
<p>Our patched version of QEMU provides an info pg command that may also
prove useful: it shows a compact but detailed representation of the
current page tables, including all mapped memory ranges, permissions,
and flags. Stock QEMU also provides an info mem command that shows an
overview of which ranges of virtual addresses are mapped and with what
permissions.</p>
</blockquote>
<p>从 CPU 上执行的代码开始，一旦我们处于保护模式（我们首先进入
<code>boot/boot.S</code>
），没有办法直接使用线性或物理地址。<em>所有</em>内存引用都被解释为虚拟地址并由
MMU 翻译，这意味着 C 中的所有指针都是虚拟地址。</p>
<p>JOS
内核通常需要将地址作为不透明值或整数进行操作，而不取消对它们的引用，例如在物理内存分配器中。有时这些是虚拟地址，有时它们是物理地址。为了帮助记录代码，JOS
源代码区分了两种情况：类型<code>uintptr_t</code>表示不透明虚拟地址，
<code>physaddr_t</code>表示物理地址。这两种类型实际上只是 32 位整数 (
<code>uint32_t</code> )
的同义词，因此编译器不会阻止您将一种类型分配给另一种类型！由于它们是整数类型（而不是指针），因此如果您尝试取消引用它们，编译器<em>会</em>抱怨。</p>
<p>JOS
内核可以通过首先将<code>uintptr_t</code>转换为指针类型来取消引用它。相反，内核无法明智地取消引用物理地址，因为
MMU
会转换所有内存引用。如果将<code>physaddr_t</code>转换为指针并取消引用它，您可能能够加载并存储到结果地址（硬件会将其解释为虚拟地址），但您可能无法获得您想要的内存位置。</p>
]]></content>
      <tags>
        <tag>MIT</tag>
        <tag>6.828</tag>
        <tag>JOS</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法大全</title>
    <url>//posts/1406297574.html</url>
    <content><![CDATA[<h2 id="markdown标题">1.Markdown标题</h2>
<p>提升标题等级<strong>ctrl+</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<h2 id="markdown字体">2.Markdown字体</h2>
<p>用1个星号*或底线_表示斜体 <strong>斜体：Ctrl+I</strong></p>
<p>用2个星号*或底线_表示粗体 <strong>加粗：Ctrl+B</strong></p>
<p>用3个星号*或底线_表示粗斜体</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*斜体文字*</span><br><span class="line"></span><br><span class="line">_斜体文字_</span><br><span class="line"></span><br><span class="line">**粗体文字**</span><br><span class="line"></span><br><span class="line">__粗体文字__</span><br><span class="line"></span><br><span class="line">***粗斜体文字***</span><br><span class="line"></span><br><span class="line">___粗斜体文字___</span><br></pre></td></tr></table></figure>
<h2 id="markdown分割线">3.Markdown分割线</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">******</span><br><span class="line">------</span><br></pre></td></tr></table></figure>
<h2 id="markdown删除线">4.Markdown删除线</h2>
<p>快捷键<strong>Alt+Shift+5</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~~tencent.com~~</span><br></pre></td></tr></table></figure>
<h2 id="代码块">5.代码块</h2>
<p>快捷键<strong>Ctrl+Shift+`</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">`world`</span><br></pre></td></tr></table></figure>
<h2 id="markdown下划线">6.Markdown下划线</h2>
<p>快捷键<strong>Ctrl+U</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;   </span><br></pre></td></tr></table></figure>
<h2 id="markdown列表">7.Markdown列表</h2>
<p>无序列表(三个都行）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>
<p>有序列表直接在文字有加上1. 2. 3.
来表示，符号和文字之间加上一个空格字符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>
<h2 id="markdown嵌套列表">8.Markdown嵌套列表</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
<h2 id="markdown链接">9.Markdown链接</h2>
<p>超链接<strong><a
href="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main">Ctrl+K</a></strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">这是一个链接 [新浪新闻](https://news.sina.com.cn/)</span><br><span class="line">&lt;https://news.sina.com.cn/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="markdown图片">10.Markdown图片</h2>
<p>图片<strong>Ctrl+Shift+I</strong></p>
<h2 id="markdown表格">11.Markdown表格</h2>
<p>快捷键<strong>ctrl+t</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | -----: | :------: |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line"></span><br><span class="line">| 表头   | 表头   |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
<h2 id="markdown扩展语法">12.Markdown扩展语法</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">==高亮==</span><br><span class="line">内联公式 例：$\LateX$</span><br><span class="line">下标 例：H~2~O</span><br><span class="line">上标 例：X^2</span><br><span class="line">图标</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim算法（普里姆算法）详解</title>
    <url>//posts/941783862.html</url>
    <content><![CDATA[<h1 id="prim算法普里姆算法详解">prim算法（普里姆算法）详解</h1>
<p>了解了什么是最小生成树后，本节为您讲解如何用普里姆（prim）算法查找连通网（带权的连通图）中的最小生成树。</p>
<p>普里姆算法查找最小生成树的过程，采用了贪心算法的思想。对于包含 N
个顶点的连通网，普里姆算法每次从连通网中找出一个权值最小的边，这样的操作重复
N-1 次，由 N-1 条权值最小的边组成的生成树就是最小生成树。</p>
<p>那么，如何找出 N-1 条权值最小的边呢？普里姆算法的实现思路是：</p>
<p>将连通网中的所有顶点分为两类（假设为 A 类和 B
类）。初始状态下，所有顶点位于 B 类；</p>
<p>选择任意一个顶点，将其从 B 类移动到 A 类；</p>
<p>从 B 类的所有顶点出发，找出一条连接着 A
类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B
类；</p>
<p>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到
N-1 条边。</p>
<p>举个例子，下图是一个连通网，使用普里姆算法查找最小生成树，需经历以下几个过程：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785257966.jpg" />
图 1 连通网</p>
<p>将图中的所有顶点分为 A 类和 B 类，初始状态下，A = {}，B = {A, B, C,
D, S, T}。</p>
<p>从 B 类中任选一个顶点，假设选择 S 顶点，将其从 B 类移到 A 类，A =
{S}，B = {A, B, C, D, T}。从 A 类的 S 顶点出发，到达 B 类中顶点的边有 2
个，分别是 S-A 和 S-C，其中 S-A 边的权值最小，所以选择 S-A
边组成最小生成树，将 A 顶点从 B 类移到 A 类，A = {S, A}，B = {B, C, D,
T}。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785303306.jpg" />
图 2 S-A 边组成最小生成树</p>
<p>从 A 类中的 S、A 顶点出发，到达 B 类中顶点的边有 3 个，分别是
S-C、A-C、A-B，其中 A-C 的权值最小，所以选择 A-C 组成最小生成树，将顶点
C 从 B 类移到 A 类，A = {S, A, C}，B = {B, D, T}。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785307186.jpg" />
图 3 A-C 边组成最小生成树</p>
<p>从 A 类中的 S、A、C 顶点出发，到达 B 类顶点的边有
S-C、A-B、C-B、C-D，其中 C-D 边的权值最小，所以选择 C-D
组成最小生成树，将顶点 D 从 B 类移到 A 类，A = {S, A, C, D}，B = {B,
T}。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785311690.jpg" />
图 4 C-D 边组成最小生成树</p>
<p>从 A 类中的 S、A、C、D 顶点出发，到达 B 类顶点的边有
A-B、C-B、D-B、D-T，其中 D-B 和 D-T 的权值最小，任选其中的一个，例如选择
D-B 组成最小生成树，将顶点 B 从 B 类移到 A 类，A = {S, A, C, D, B}，B =
{T}。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785311690.jpg" />
图 5 D-B 边组成最小生成树</p>
<p>从 A 类中的 S、A、C、D、B 顶点出发，到达 B 类顶点的边有
B-T、D-T，其中 D-T 的权值最小，选择 D-T 组成最小生成树，将顶点 T 从 B
类移到 A 类，A = {S, A, C, D, B, T}，B = {}。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785315841.jpg" />
图 6 D-T 边组成最小生成树</p>
<p>由于 B 类中的顶点全部移到了 A 类，因此 S-A、A-C、C-D、D-B、D-T
组成的是一个生成树，而且是一个最小生成树，它的总权值为 17。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/Prim算法（普里姆算法）详解/1683785320527.jpg" />
图 7 最小生成树</p>
<p>普里姆算法的具体实现</p>
<p>接下来，我们将给出实现普里姆算法的 C、Java、Python
程序，程序中有详尽的注释，您可以借助编译器一边运行程序一边观察程序的执行过程，彻底搞清楚普里姆算法是如何找到最小生成树的。</p>
<p>如下是使用普里姆算法在图 1 所示的连通网中查找最小生成树的 C
语言程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V 6    <span class="comment">// 记录图中顶点的个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> <span class="literal">false</span>, <span class="literal">true</span> &#125; <span class="type">bool</span>;</span><br><span class="line"><span class="comment">//查找权值最小的、尚未被选择的顶点，key 数组记录了各顶点之间的权值数据，visited数组记录着各个顶点是否已经被选择的信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min_Key</span><span class="params">(<span class="type">int</span> key[], <span class="type">bool</span> visited[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">2147483647</span>, min_index;  <span class="comment">//遍历 key 数组使用，min 记录最小的权值，min_index 记录最小权值关联的顶点</span></span><br><span class="line">    <span class="comment">//遍历 key 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">        <span class="comment">//如果当前顶点为被选择，且对应的权值小于 min 值</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            <span class="comment">//更新  min 的值并记录该顶点的位置</span></span><br><span class="line">            min = key[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最小权值的顶点的位置</span></span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_MST</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> cost[V][V])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小生成树为：\n&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历 parent 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="comment">//parent 数组下标值表示各个顶点，各个下标对应的值为该顶点的父节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d wight:%d\n&quot;</span>, parent[i] + <span class="number">1</span>, i + <span class="number">1</span>, cost[i][parent[i]]);<span class="comment">//由于数组下标从 0 开始，因此输出时各自 +1</span></span><br><span class="line">        <span class="comment">//统计最小生成树的总权值</span></span><br><span class="line">        minCost += cost[i][parent[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总权值为：%d&quot;</span>, minCost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据用户提供了图的信息（存储在 cost 数组中），寻找最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_MST</span><span class="params">(<span class="type">int</span> cost[V][V])</span></span><br><span class="line">&#123;    <span class="comment">//key 数组用于记录 B 类顶点到 A 类顶点的权值</span></span><br><span class="line">    <span class="comment">//parent 数组用于记录最小生成树中各个顶点父节点的位置，便于最终生成最小生成树</span></span><br><span class="line">    <span class="comment">//visited 数组用于记录各个顶点属于 A 类还是 B 类</span></span><br><span class="line">    <span class="type">int</span> parent[V], key[V];</span><br><span class="line">    <span class="type">bool</span> visited[V];</span><br><span class="line">    <span class="comment">// 初始化 3 个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        key[i] = <span class="number">2147483647</span>;    <span class="comment">// 将 key 数组各个位置设置为无限大的数</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;     <span class="comment">// 所有的顶点全部属于 B 类</span></span><br><span class="line">        parent[i] = <span class="number">-1</span>;         <span class="comment">// 所有顶点都没有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择 key 数组中第一个顶点，开始寻找最小生成树</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 该顶点对应的权值设为 0</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 该顶点没有父节点</span></span><br><span class="line">    <span class="comment">// 对于 V 个顶点的图，最需选择 V-1 条路径，即可构成最小生成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; V - <span class="number">1</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从 key 数组中找到权值最小的顶点所在的位置</span></span><br><span class="line">        <span class="type">int</span> u = min_Key(key, visited);</span><br><span class="line">        <span class="comment">// 该顶点划分到 A 类</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 由于新顶点加入 A 类，因此需要更新 key 数组中的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果类 B 中存在到下标为 u 的顶点的权值比 key 数组中记录的权值还小，表明新顶点的加入，使得类 B 到类 A 顶点的权值有了更好的选择</span></span><br><span class="line">            <span class="keyword">if</span> (cost[u][v] != <span class="number">0</span> &amp;&amp; visited[v] == <span class="literal">false</span> &amp;&amp; cost[u][v] &lt; key[v])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新 parent 数组记录的各个顶点父节点的信息</span></span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="comment">// 更新 key 数组</span></span><br><span class="line">                key[v] = cost[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 parent 记录的各个顶点父节点的信息，输出寻找到的最小生成树</span></span><br><span class="line">    print_MST(parent, cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main function</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1, p2;</span><br><span class="line">    <span class="type">int</span> wight;</span><br><span class="line">    <span class="type">int</span> cost[V][V] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入图（顶点到顶点的路径和权值)：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p1, &amp;p2);</span><br><span class="line">        <span class="comment">//如果用户输入 -1 -1，表示输入结束</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">-1</span> &amp;&amp; p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wight);</span><br><span class="line">        cost[p1 - <span class="number">1</span>][p2 - <span class="number">1</span>] = wight;</span><br><span class="line">        cost[p2 - <span class="number">1</span>][p1 - <span class="number">1</span>] = wight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户输入的图的信息，寻找最小生成树</span></span><br><span class="line">    find_MST(cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————
版权声明：本文为CSDN博主「睿科知识云」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ccc369639963/article/details/122621467</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtualbox安装Ubuntu乱码与终端无法打开</title>
    <url>//posts/3159472295.html</url>
    <content><![CDATA[<h2 id="环境">环境</h2>
<p>Virtualbox 7.0.20 r163906 (Qt5.15.2)</p>
<p>Ubuntu-18.04.6 desktop</p>
<h2 id="乱码的原因">乱码的原因</h2>
<p>主要是因为<code>/ect/default</code>文件中的字符描述错误了，导致了顶部日期乱码与终端无法打开</p>
<h2 id="解决方法">解决方法</h2>
<p>首先图形界面无法使用命令行，需要切换到TTY终端，<code>Ctrl+Alt+F3</code>可以直接切换到TTY，完成修复或者中途需要退回可以使用<code>Ctrl+Alt+F1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/default</span><br><span class="line"><span class="built_in">sudo</span> nano locale</span><br><span class="line"><span class="comment"># 或者可以使用vim，看你虚拟机里有没有安装</span></span><br><span class="line"><span class="comment"># sudo vim locale </span></span><br><span class="line"><span class="comment"># 在控制台中把文件中的&quot;en-US&quot;改为&quot;en-US.UTF-8&quot; （我修改了两处）</span></span><br><span class="line"><span class="comment"># 保存退出，不会的查一下vim和nano的使用教程，简单看一下如何保存文件就好</span></span><br><span class="line"><span class="built_in">sudo</span> locale-gen --purge</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>执行完<code>reboot</code>以后，虚拟机自动重启</p>
<p>如果执行上面命令的时候，提示你的用户没有在sudoers中
<code>xxx is not in the sudoers</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="comment"># 输入你设置的密码</span></span><br><span class="line">gedit /etc/sudoers</span><br><span class="line"><span class="comment"># 这是图形化编辑器，找到“root ALL=(ALL) ALL”，在下面插入“vboxuser ALL=(ALL) ALL”</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 然后再次执行sudo指令就可以了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 或者直接在TTY中输入root作为你的登录账户进行文件修改</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtualbox设置共享文件夹（Ubuntu）</title>
    <url>//posts/2319536131.html</url>
    <content><![CDATA[<h2 id="环境">环境</h2>
<p>Virtualbox 7.0.20 r163906 (Qt5.15.2)</p>
<p>Ubuntu-18.04.6 desktop</p>
<h2 id="一配置共享文件夹">一、配置共享文件夹</h2>
<ol type="1">
<li>在VirtualBox中，选中Ubuntu 16.04虚拟机，点击“设置”按钮。</li>
<li>在左侧菜单中选择“共享文件夹”，点击右侧的“添加共享文件夹”按钮。</li>
<li>在弹出的对话框中，设置共享文件夹的名称、路径以及访问权限。</li>
<li>完成设置后，点击“确定”保存配置。</li>
</ol>
<h2
id="二在ubuntu虚拟机中挂载共享文件夹">二、在Ubuntu虚拟机中挂载共享文件夹</h2>
<ol type="1">
<li><p>打开终端，以root用户登录。</p></li>
<li><p>创建一个目录，用于挂载共享文件夹。例如，我们可以创建一个名为“shared”的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /mnt/shared</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>mount</code>命令将共享文件夹挂载到该目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount -t vboxsf [共享文件夹名称] /mnt/shared</span><br></pre></td></tr></table></figure>
<p>其中，<code>[共享文件夹名称]</code>是我们在VirtualBox中设置的共享文件夹名称。</p></li>
<li><p>现在，我们就可以在<code>/mnt/shared</code>目录下访问Windows宿主机上的共享文件夹了。</p></li>
</ol>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Virtualbox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm头文件函数全集——史上最全，最贴心</title>
    <url>//posts/540896091.html</url>
    <content><![CDATA[<h2 id="简介">简介：</h2>
<p>algorithm头文件是C++的标准算法库，它主要应用在容器上。
因为所有的算法都是通过迭代器进行操作的，所以算法的运算实际上是和具体的数据结构相分离的
，也就是说，具有低耦合性。
因此，任何数据结构都能使用这套算法库，只要它具有相应的迭代器类型。</p>
<span id="more"></span>
<h2 id="常用函数">常用函数：</h2>
<h3 id="一maxminabs函数">一、max()、min()、abs()函数</h3>
<p>max()：求两个数最大值 min()：求两个数最小值 abs()：求一个数的绝对值
代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">	<span class="comment">//求最大值</span></span><br><span class="line">	<span class="type">int</span> Max = <span class="built_in">max</span>(a,b);</span><br><span class="line">	<span class="comment">//求最小值</span></span><br><span class="line">	<span class="type">int</span> Min = <span class="built_in">min</span>(a,b);</span><br><span class="line">	<span class="comment">//求绝对值</span></span><br><span class="line">	<span class="type">int</span> Abs = <span class="built_in">abs</span>(<span class="number">-3</span>);</span><br><span class="line">	cout &lt;&lt; Max &lt;&lt; Min &lt;&lt; Abs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：433 注意：
1、max()和min()函数中的参数只能是两个，如果想求3个数的最大值，需要嵌套一下
同理：如果想求数组中的最大值，需要在循环中写。
2、写了algorithm头文件后，
max就变成了函数名，在自己定义变量时，要避免使用max，min等。
3、abs()函数只能用于求整型变量的绝对值，而##include<code>&lt;cmath&gt;</code>中的fabs()函数还可用于求浮点型变量的绝对值，不要搞混~</p>
<h4 id="交换函数swap">2、交换函数：swap()</h4>
<p>用来交换x和y的值</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a,b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：43</p>
<h4 id="翻转函数reverse">3、翻转函数：reverse()</h4>
<p><strong>翻转x-y区间的数组、容器的值。</strong></p>
<h5 id="翻转整个数组">1、翻转整个数组</h5>
<p>翻转整个数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line">	<span class="built_in">reverse</span>(a,a<span class="number">+5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：55 44 33 22 11</p>
<h6
id="也可以实现对部分值的翻转像这样">2、也可以实现对部分值的翻转，像这样：</h6>
<p>翻转部分数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line">	<span class="built_in">reverse</span>(a<span class="number">+3</span>,a<span class="number">+5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：11 22 33 55 44</p>
<h6
id="翻转容器若想对容器中所有的数进行翻转则需要用到beginend函数像这样">3、翻转容器：若想对容器中所有的数进行翻转，则需要用到begin()、end()函数，像这样：</h6>
<p>翻转整个容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="comment">//输入： </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="comment">//输出： </span></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：4 3 2 1 0</p>
<h6
id="翻转容器容器的翻转也可以用迭代器来实现指定位数的翻转像这样">4、翻转容器：容器的翻转也可以用迭代器，来实现指定位数的翻转，像这样：</h6>
<p>翻转部分容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="comment">//输入： </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="comment">//输出： </span></span><br><span class="line">	it = v.<span class="built_in">begin</span>(); </span><br><span class="line">	<span class="built_in">reverse</span>(it, it<span class="number">+3</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：2 1 0 3 4</p>
<p>注意： 如果想在翻转时指定位数，则其为半开半闭区间。 如reserve(a+2,
a+4);翻转数组中第2-4之间的数，不包括第二个，但包括第四个。</p>
<h4 id="四排序函数sort">四、排序函数：sort()</h4>
<h6
id="对x-y区间的数组容器进行排序默认升序排列">1、对x-y区间的数组、容器进行排序。默认升序排列。</h6>
<p>数组升序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a,a<span class="number">+5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出：11 22 33 44 55</p>
<h6
id="如果想将数组降序排序就需要写一个简单的函数改变默认的排序功能像这样">2、如果想将数组降序排序，就需要写一个简单的函数，改变默认的排序功能，像这样：</h6>
<p>数组降序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//意思是：若a&gt;b，则a的优先级更大！ 也就是说大的在前面。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a,a<span class="number">+5</span>,cmp);			<span class="comment">//这里需要加上自己自定义的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：55 44 33 22 11</p>
<h6
id="同理如果想对结构体排序也需要自定义优先级像这样">3、同理，如果想对结构体排序，也需要自定义优先级。像这样：</h6>
<p>结构体排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//用sort函数对结构体排序 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="type">int</span> high;</span><br><span class="line">	<span class="type">int</span> weigh;</span><br><span class="line">&#125;student[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//a.high如果小于b.high，则a结构体的优先级更大， 也就是说：high小的结构体排在前面。 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.high &lt; b.high;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		student[i].high = i ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(student, student<span class="number">+10</span>, cmp);		<span class="comment">//将自定义的函数添加上。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; student[i].high &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：0 1 2 3 4 5 6 7 8 9</p>
<h6
id="如果想对容器排序就需要使用迭代器或beginend函数像这样">4、如果想对容器排序，就需要使用迭代器，或begin(),end()函数。像这样：</h6>
<p>容器升序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="comment">//输入： </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">		v.<span class="built_in">push_back</span>(i); </span><br><span class="line">	<span class="comment">//输出： </span></span><br><span class="line">	it = v.<span class="built_in">begin</span>(); </span><br><span class="line">	<span class="built_in">sort</span>(it, it<span class="number">+3</span>);</span><br><span class="line"><span class="comment">//	sort(v.begin(), v.end())</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：3 4 5 2 1</p>
<h6
id="同理如果想对容器降序排序或对容器结构体排序向数组那样操作就可以了">5、同理，如果想对容器降序排序，或对容器结构体排序，向数组那样操作就可以了。</h6>
<p>注意：
1、sort()排序函数的时间复杂度大概在o(nlogn)，比冒泡、简单排序等效率高 。
2、和reverse()函数一样，可以自由指定排序范围，也是半开半闭区间（左闭右开）。</p>
<h4 id="五查找函数find">五、查找函数：find()</h4>
<p>查找某数组指定区间x-y内是否有x，若有，则返回该位置的地址，若没有，则返回该数组第n+1个值的地址。(好烦有木有，为啥要返回地址。还要转化o(╥﹏╥)o)
1、数组中查找是否有某值：一定一定一定要满足代码中这两个条件。
第一个条件是：p-a != 数组的长度。p是查找数值的地址，a是a[0]的地址。
第二个条件是：*p == x; 也就是该地址指向的值等于我们要查找的值。
最后输出p-a+1； p-a相当于x所在位置的地址-a[0]所在位置的地址，
但因为是从0开始算， 所以最后需要+1。</p>
<h6 id="对数组查找">1、对数组查找：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">find</span>(a,a<span class="number">+5</span>,<span class="number">33</span>);				<span class="comment">//定义指针，指向查找完成后返回的地址，5为a2数组长度 </span></span><br><span class="line">  	<span class="keyword">if</span>(((p-a) != <span class="number">5</span>) &amp;&amp; (*p == x))		<span class="comment">//若同时满足这两个条件，则查找成功，输出 </span></span><br><span class="line">  		cout &lt;&lt; (p-a<span class="number">+1</span>);					<span class="comment">//输出所在位置 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：3</p>
<h6
id="对容器进行查找同理也要满足这两个条件">2、对容器进行查找同理：也要满足这两个条件：</h6>
<p>对容器查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it, it1;</span><br><span class="line">	<span class="comment">//输入： </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		v.<span class="built_in">push_back</span>(i); </span><br><span class="line">	<span class="comment">//查找 </span></span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();					<span class="comment">//第一步：求长度</span></span><br><span class="line">	it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);		<span class="comment">//第二步：查找x在容器的位置，返回迭代器1</span></span><br><span class="line">	it1 = v.<span class="built_in">begin</span>();						<span class="comment">//第三步：令迭代器2指向容器头 </span></span><br><span class="line">	<span class="keyword">if</span>(((it-it1)!=size)&amp;&amp;(*it==<span class="number">3</span>))			<span class="comment">//第四步：若同时满足这两个条件，则查找成功，输出 </span></span><br><span class="line">		cout &lt;&lt; (it-it1<span class="number">+1</span>) &lt;&lt; endl;			<span class="comment">//输出所在位置 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出：4</p>
<h4
id="六查找函数upper_boundlower_bound">六、查找函数：upper_bound()、lower_bound()</h4>
<p>1、upper_bound()：查找第一个大于x的值的位置
2、lower_bound()：查找第一个大于等于x的值的位置
同样是返回地址，用法和find()函数一毛一样，限制条件也一毛一样，照着扒就行了。</p>
<h4 id="七填充函数fill">七、填充函数：fill()</h4>
<p>在区间内填充某一个值。同样适用所有类型数组，容器。
1、举例：在数组中未赋值的地方填充9999</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">22</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fill</span>(a<span class="number">+3</span>,a<span class="number">+5</span>,<span class="number">9999</span>);							</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：11 33 22 9999 9999</p>
<p>应用：
常用在大数加法中，因为数太大，需要用字符串保存，如果在运算时需要填充0，就要用这个函数。</p>
<h4 id="八查找某值出现的次数count">八、查找某值出现的次数：count()</h4>
<p>1、在数组中查找x 在某区间出现的次数：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">44</span>&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">count</span>(a, a<span class="number">+5</span>, <span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出：2</p>
<p>2、在容器中查找同理，只是需要用iterator迭代器或begin()、end()函数。</p>
<p>注意：
和前几个函数一样，如果需要指定区间查询，注意是半开半闭区间(左闭右开区间)。</p>
<h4 id="八求最大公因数__gcd">八、求最大公因数：__gcd()</h4>
<p>震惊把！在我最开始知道竟然有这个函数时，我也是震惊的！
另外，用二者乘积除以最大公因数即可得到最小公倍数。
因此没有求最小公倍数的函数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> a = <span class="number">12</span>, b = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> Gcd = __gcd(a,b);</span><br><span class="line">	cout &lt;&lt; Gcd;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>注意： __gcd() 需要写两个下划线！</p>
<h4
id="九求交集并集差集set_intersectionset_unionset_difference">九、求交集、并集、差集：set_intersection()、set_union()、set_difference()</h4>
<h6 id="求交集">1、求交集：</h6>
<p>（1）：将两个数组的交集赋给一个容器(为什么不能赋给数组呢？因为数组不能动态开辟，且inserter()函数中的参数必须是指向容器的迭代器。)：
代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	<span class="built_in">set_intersection</span>(a, a<span class="number">+5</span>, b, b<span class="number">+5</span>, <span class="built_in">inserter</span>(v4,v<span class="number">4.</span><span class="built_in">begin</span>()));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">4.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v4[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>输出：1 2</p>
<p>（2）：将两个容器的交集赋给另一个容器： 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1, v2, v3;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">8</span>; i++) </span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	  </span><br><span class="line">	<span class="built_in">set_intersection</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">inserter</span>(v3,v<span class="number">3.</span><span class="built_in">begin</span>()));  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">3.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v3[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出：3 4</p>
<h6 id="求并集">2、求并集：</h6>
<p>（1）：将两个数组的并集赋给一个容器(为什么不能赋给数组呢？因为数组不能动态开辟，且inserter()函数中的参数必须是指向容器的迭代器。)：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	<span class="built_in">set_union</span>(a, a<span class="number">+5</span>, b, b<span class="number">+5</span>, <span class="built_in">inserter</span>(v4,v<span class="number">4.</span><span class="built_in">begin</span>()));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">4.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v4[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>输出：1 2 3 4 5 33 44 55 （2）：将两个容器的并集赋给另一个容器：</p>
<p>代码： ##include<code>&lt;algorithm&gt;</code>
##include<code>&lt;iostream&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1, v2, v3;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">8</span>; i++) </span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	  </span><br><span class="line">	<span class="built_in">set_union</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">inserter</span>(v3,v<span class="number">3.</span><span class="built_in">begin</span>()));  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">3.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; v3[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：0 1 2 3 4 5 6 7</p>
<h6 id="差集完全同理">3、差集完全同理。</h6>
<p>注意： inserter(c,c.begin()）为插入迭代器
此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>
<h4 id="十全排列next_permutation">十、全排列：next_permutation()</h4>
<p>将给定区间的数组、容器全排列</p>
<h6 id="将给定区间的数组全排列">1、将给定区间的数组全排列：</h6>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		cout&lt;&lt;a[<span class="number">0</span>]&lt;&lt;a[<span class="number">1</span>]&lt;&lt;a[<span class="number">2</span>]&lt;&lt;endl; </span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a,a<span class="number">+3</span>));	<span class="comment">//输出1、2、3的全排列 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>输出： 123 132 213 231 312 321</p>
<h6
id="容器全排列同理只不过将参数换成iterator迭代器或beginend函数">2、容器全排列同理：只不过将参数换成iterator迭代器或begin()、end()函数。</h6>
<p>注意：
和之前的一样，如果指定全排列区间，则该区间是半开半闭区间（左闭右开）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                   _ooOoo_</span></span><br><span class="line"><span class="comment">                  o8888888o</span></span><br><span class="line"><span class="comment">                  88&quot; . &quot;88</span></span><br><span class="line"><span class="comment">                  (| -_- |)</span></span><br><span class="line"><span class="comment">                  O\  =  /O</span></span><br><span class="line"><span class="comment">               ____/`---&#x27;\____</span></span><br><span class="line"><span class="comment">             .&#x27;  \\|     |//  `.</span></span><br><span class="line"><span class="comment">            /  \\|||  :  |||//  \</span></span><br><span class="line"><span class="comment">           /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">           |   | \\\  -  /// |   |</span></span><br><span class="line"><span class="comment">           | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |</span></span><br><span class="line"><span class="comment">           \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">         ___`. .&#x27;  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">      .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.</span></span><br><span class="line"><span class="comment">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">======`-.____`-.___\_____/___.-`____.-&#x27;======</span></span><br><span class="line"><span class="comment">                   `=---=&#x27;</span></span><br><span class="line"><span class="comment">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">         I have a dream! An AC dream!!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>————————————————
版权声明：本文为CSDN博主「来老铁干了这碗代码」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43899069/article/details/104450000</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++运算符优先级归纳</title>
    <url>//posts/3771985588.html</url>
    <content><![CDATA[<p>C++一共有
18个优先级，运算中按优先级进行性计算，当优先级相同时，根据结合性规则来决定。
结合性：
1.从左到右（L-R）：操作数和操作符结合的顺序大部分是从左到右结合性的，例如（）、单独的算术运算符
2.从右到左（R-L）：最典型的是赋值运算符，当赋值符号与算术运算符结合后
，整体也是R-L。另一个最常用的就是逻辑非运算符 “！”。</p>
<span id="more"></span>
<p><strong>在使用的时候，如果不确定，或者运算符太多，就按照自己的思路用括号隔开。
因为在程序中，正确性&gt;可读性&gt;简洁性，万万不可本末倒置</strong></p>
<h1 id="优先级1">优先级1</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250132292.png" /></p>
<h1 id="优先级2">优先级2</h1>
<p>平时常用的最高优先级操作符是从左向右结合的一批操作符，操作数和操作符结合的顺序是从左到右。包括：函数调用、数组下标、取成员、类型转换、后置运算符等。
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250141830.png" /></p>
<h1 id="优先级3">优先级3</h1>
<p>此优先级都是一元运算符（单目运算符），从右向做结合。 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250145920.png" /></p>
<h1 id="优先级4">优先级4</h1>
<p>类成员指针运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250152405.png" /></p>
<h1 id="优先级5">优先级5</h1>
<p>算术运算符中的乘(*)、除(/)、取余(%) <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250156314.png" /></p>
<h1 id="优先级6">优先级6</h1>
<p>算术运算符中的加、减 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250163038.png" /></p>
<h1 id="优先级7">优先级7</h1>
<p>移位运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250168606.png" /></p>
<h1 id="优先级8">优先级8</h1>
<p>比较运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250173087.png" /></p>
<h1 id="优先级9">优先级9</h1>
<p>比较运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250178096.png" /></p>
<h1 id="优先级101112">优先级10、11、12</h1>
<p>按位运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250182373.png" /></p>
<h1 id="优先级1314">优先级13、14</h1>
<p>逻辑运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250186826.png" /></p>
<h1 id="优先级15">优先级15</h1>
<p>三目条件运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250193964.png" /></p>
<h1 id="优先级16">优先级16</h1>
<p>赋值运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250199706.png" /></p>
<h1 id="优先级17">优先级17</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250203048.png" /></p>
<h1 id="优先级18">优先级18</h1>
<p>逗号运算符 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/1682250206228.png" /></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>克鲁斯卡尔算法（Kruskal）详解</title>
    <url>//posts/2434167907.html</url>
    <content><![CDATA[<h2 id="应用场景-公交站问题">应用场景-公交站问题</h2>
<p>看一个应用场景和问题： <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/克鲁斯卡尔算法（Kruskal）详解/1683784970527.jpg"
alt="1" /></p>
<ol type="1">
<li>某城市新增 7 个站点 (A, B, C, D, E, F, G) ，现在需要修路把 7
个站点连通</li>
<li>各个站点的距离用边线表示 ( 权 ) ，比如 A – B 距离 12 公里</li>
<li>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短 ?</li>
</ol>
<h2 id="克鲁斯卡尔算法介绍">克鲁斯卡尔算法介绍</h2>
<ol type="1">
<li>克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法
。</li>
<li>基本思想 ：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1
条边不构成回路</li>
<li>具体做法 ：首先构造一个只含 n
个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</li>
</ol>
<h2 id="克鲁斯卡尔算法图解说明">克鲁斯卡尔算法图解说明</h2>
<p>以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤：</p>
<p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/克鲁斯卡尔算法（Kruskal）详解/1683785025522.jpg"
alt="2" />
<figcaption aria-hidden="true">2</figcaption>
</figure>
<p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/克鲁斯卡尔算法（Kruskal）详解/1683785031002.jpg"
alt="3" /></p>
<h2 id="克鲁斯卡尔算法图解">克鲁斯卡尔算法图解</h2>
<p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/克鲁斯卡尔算法（Kruskal）详解/1683785054264.png"
alt="4" />
<figcaption aria-hidden="true">4</figcaption>
</figure>
<p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。
边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第2步</strong>：将边&lt;C,D&gt;加入R中。
上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第3步</strong>：将边&lt;D,E&gt;加入R中。
上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第4步</strong>：将边&lt;B,F&gt;加入R中。
上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。
<strong>第5步</strong>：将边&lt;E,G&gt;加入R中。
上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第6步</strong>：将边&lt;A,B&gt;加入R中。
上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p>
<p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt;
&lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt;
&lt;A,B&gt;</strong>。</p>
<h2 id="克鲁斯卡尔算法分析">克鲁斯卡尔算法分析</h2>
<p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：
<strong>问题一</strong> 对图的所有边按照权值大小进行排序。
<strong>问题二</strong>
将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>
<p>问题一很好解决，采用排序算法进行排序即可。</p>
<p>问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<p>如何判断是否构成回路-举例说明(如图)</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/克鲁斯卡尔算法（Kruskal）详解/1683785097950.jpg"
alt="5" />
<figcaption aria-hidden="true">5</figcaption>
</figure>
<p>在将&lt;E,F&gt; &lt;C,D&gt;
&lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p>
<p><strong>(01)</strong> C的终点是F。 <strong>(02)</strong> D的终点是F。
<strong>(03)</strong> E的终点是F。 <strong>(04)</strong>
F的终点是F。</p>
<p>关于终点的说明：</p>
<p>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。
因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的<strong>边</strong>的<strong>两个顶点</strong>不能<strong>都指向同一个终点</strong>，否则将构成回路。【后面有代码说明】</p>
<h2 id="克鲁斯卡尔算法的代码说明">克鲁斯卡尔算法的代码说明</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.kruskal;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalCase</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> edgeNum; <span class="comment">//边的个数</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">char</span>[] vertexs; <span class="comment">//顶点数组</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[][] matrix; <span class="comment">//邻接矩阵</span></span><br><span class="line">		<span class="comment">//使用 INF 表示两个顶点不能连通</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			<span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">			<span class="comment">//克鲁斯卡尔算法的邻接矩阵  </span></span><br><span class="line">		      <span class="type">int</span> matrix[][] = &#123;</span><br><span class="line">		      <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">		<span class="comment">/*A*/</span> &#123;   <span class="number">0</span>,  <span class="number">12</span>, INF, INF, INF,  <span class="number">16</span>,  <span class="number">14</span>&#125;,</span><br><span class="line">		<span class="comment">/*B*/</span> &#123;  <span class="number">12</span>,   <span class="number">0</span>,  <span class="number">10</span>, INF, INF,   <span class="number">7</span>, INF&#125;,</span><br><span class="line">		<span class="comment">/*C*/</span> &#123; INF,  <span class="number">10</span>,   <span class="number">0</span>,   <span class="number">3</span>,   <span class="number">5</span>,   <span class="number">6</span>, INF&#125;,</span><br><span class="line">		<span class="comment">/*D*/</span> &#123; INF, INF,   <span class="number">3</span>,   <span class="number">0</span>,   <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">		<span class="comment">/*E*/</span> &#123; INF, INF,   <span class="number">5</span>,   <span class="number">4</span>,   <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">8</span>&#125;,</span><br><span class="line">		<span class="comment">/*F*/</span> &#123;  <span class="number">16</span>,   <span class="number">7</span>,   <span class="number">6</span>, INF,   <span class="number">2</span>,   <span class="number">0</span>,   <span class="number">9</span>&#125;,</span><br><span class="line">		<span class="comment">/*G*/</span> &#123;  <span class="number">14</span>, INF, INF, INF,   <span class="number">8</span>,   <span class="number">9</span>,   <span class="number">0</span>&#125;&#125;; </span><br><span class="line">		      <span class="comment">//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span></span><br><span class="line">		  </span><br><span class="line">		      <span class="comment">//创建KruskalCase 对象实例</span></span><br><span class="line">		      <span class="type">KruskalCase</span> <span class="variable">kruskalCase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KruskalCase</span>(vertexs, matrix);</span><br><span class="line">		      <span class="comment">//输出构建的</span></span><br><span class="line">		      kruskalCase.print();</span><br><span class="line">		      kruskalCase.kruskal();</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">KruskalCase</span><span class="params">(<span class="type">char</span>[] vertexs, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">			<span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">vlen</span> <span class="operator">=</span> vertexs.length;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//初始化顶点, 复制拷贝的方式</span></span><br><span class="line">			<span class="built_in">this</span>.vertexs = <span class="keyword">new</span> <span class="title class_">char</span>[vlen];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">				<span class="built_in">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//初始化边, 使用的是复制拷贝的方式</span></span><br><span class="line">			<span class="built_in">this</span>.matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">					<span class="built_in">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//统计边的条数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">						edgeNum++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="type">int</span> index=<span class="number">0</span>;<span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">			<span class="type">int</span> ends[]=<span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点</span></span><br><span class="line">			<span class="comment">//创建结果数组, 保存最后的最小生成树</span></span><br><span class="line">			Edata[] result=<span class="keyword">new</span> <span class="title class_">Edata</span>[edgeNum];</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//获取图中 所有的边的集合 ， 一共有12边</span></span><br><span class="line">			Edata[] edges = getEdges();</span><br><span class="line">			System.out.println(<span class="string">&quot;图的边的集合=&quot;</span> + Arrays.toString(edges) + <span class="string">&quot; 共&quot;</span>+ edges.length); <span class="comment">//12</span></span><br><span class="line">			<span class="comment">//按照边的权值大小进行排序(从小到大)</span></span><br><span class="line">			Arrays.sort(edges);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edgeNum; i++) &#123;</span><br><span class="line">				<span class="comment">//获取到第i条边的第一个顶点(起点)</span></span><br><span class="line">				<span class="type">int</span> p1=getPosition(edges[i].start);<span class="comment">//p1=4</span></span><br><span class="line">				<span class="comment">//获取到第i条边的第2个顶点</span></span><br><span class="line">				<span class="type">int</span> p2=getPosition(edges[i].end); <span class="comment">//p2 = 5</span></span><br><span class="line">		</span><br><span class="line">				<span class="comment">//获取p1这个顶点在已有最小生成树中的终点	</span></span><br><span class="line">				<span class="type">int</span> n=getEnd(ends,p1);<span class="comment">//m = 4</span></span><br><span class="line">				<span class="comment">//获取p2这个顶点在已有最小生成树中的终点</span></span><br><span class="line">				<span class="type">int</span> m=getEnd(ends, p2);<span class="comment">// n = 5</span></span><br><span class="line">				<span class="comment">//是否构成回路</span></span><br><span class="line">				<span class="keyword">if</span>(n!=m) &#123;<span class="comment">//没有构成回路</span></span><br><span class="line">					ends[n]=m; <span class="comment">// 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">			</span><br><span class="line">					result[index++]=edges[i];<span class="comment">//有一条边加入到rets数组</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span></span><br><span class="line">			<span class="comment">//统计并打印 &quot;最小生成树&quot;, 输出  rets</span></span><br><span class="line">			System.out.println(<span class="string">&quot;最小生成树为&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">				System.out.println(result[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> i : 表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> p1)</span> &#123;<span class="comment">// i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">while</span>(ends[p1]!=<span class="number">0</span>) &#123;</span><br><span class="line">				p1=ends[p1];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> ch 顶点的值，比如&#x27;A&#x27;,&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 返回ch顶点对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vertexs[i] == ch) &#123;<span class="comment">//找到</span></span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//找不到,返回-1</span></span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">		 * 是通过matrix 邻接矩阵来获取</span></span><br><span class="line"><span class="comment">		 * EData[] 形式 [[&#x27;A&#x27;,&#x27;B&#x27;, 12], [&#x27;B&#x27;,&#x27;F&#x27;,7], .....]</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Edata[] getEdges() &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			Edata[] edges = <span class="keyword">new</span> <span class="title class_">Edata</span>[edgeNum];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexs.length;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;vertexs.length;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(matrix[i][j]!=INF) &#123;</span><br><span class="line">						edges[index++] = <span class="keyword">new</span> <span class="title class_">Edata</span>(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> edges;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//打印邻接矩阵</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">&quot;邻接矩阵为: \n&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">					System.out.printf(<span class="string">&quot;%12d&quot;</span>, matrix[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println();<span class="comment">//换行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个类EData ，它的对象实例就表示一条边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edata</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edata&gt;&#123;</span><br><span class="line">	<span class="type">char</span> start;<span class="comment">//边的一个点</span></span><br><span class="line">	<span class="type">char</span> end;<span class="comment">//边的另外一个点</span></span><br><span class="line">	<span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Edata</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.start = start;</span><br><span class="line">		<span class="built_in">this</span>.end = end;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Edate [start=&quot;</span> + start + <span class="string">&quot;, end=&quot;</span> + end + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edata o)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.weight-o.weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————
版权声明：本文为CSDN博主「一只猪的思考」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_45829957/article/details/108001882</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在TTY环境中使用GPG签名</title>
    <url>//posts/2352633213.html</url>
    <content><![CDATA[<p>默认情况下，gpg签名会调用图形化界面去进行签名，但是如果你没有图形化界面，比如codespace与WSL，就需要配置使用TTY来进行gpg签名的密钥验证。</p>
<p>命令很简单，在Linux的用户环境变量中加入下面这一行就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GPG_TTY=$(<span class="built_in">tty</span>)</span><br></pre></td></tr></table></figure>
<p>修改完文件之后，别忘了<code>source</code>一下</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>GPG</tag>
      </tags>
  </entry>
  <entry>
    <title>指向常量的指针和常量指针</title>
    <url>//posts/900007784.html</url>
    <content><![CDATA[<h1 id="指向常量的指针">指向常量的指针</h1>
<p>指向常量的指针，即
<code>pointer to const</code>，即指针指向的是一个常量，你应该把这个词（指向常量的指针）当做一个整体来理解，而不是分开。（当然也有翻译成指针常量的，但我并不喜欢这种翻译方式）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常也将指针本身是一个常量称为顶层 const，将指针所指的对象是个常量称为底层 const</span><br></pre></td></tr></table></figure></p>
<p>它的语法格式是 <code>const</code> 在 *
左边，这一点很重要，因为后面要讲的常量指针是 <code>const</code> 在 *
的右边。下面是它的基本语法格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;   <span class="comment">// pi 是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi; <span class="comment">// cptr 是一个指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，它的另一种写法是交换一下 const 和 double 的位置顺序</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="type">const</span> *cptr = &amp;pi; <span class="comment">// cptr 是一个指向常量的指针</span></span><br></pre></td></tr></table></figure>
<p>下面我们举一个例子来进行具体的讲解 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;   <span class="comment">// pi 是一个常量</span></span><br><span class="line">   <span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi; <span class="comment">// cptr 是一个指向常量的指针</span></span><br><span class="line">   cout &lt;&lt;  *cptr &lt;&lt; endl;   <span class="comment">// 3.14</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里有一个常量
pi，我用 cptr 这个指向常量的指针来指向它，它的内存示意图应该如下: <img
src="https://tommygong.top/image/1682332506472.jpg" />
【注】当我说指针的值（内容）的时候，我说的是
0x456。当我说指针指向的值（内容），我说的是
3.14，下面的语境请随着具体上下文自动脑修。 关于指针常量的两个扩展：
第一个是我们用普通的指针不能指向这个常量 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>; <span class="comment">// pi 是一个常量</span></span><br><span class="line">  <span class="type">double</span> *pnormal = &amp;pi;    <span class="comment">// 用普通指针指向常量 pi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error: invalid conversion from ‘const double*’ to ‘double*’</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>答案显然是不行的，报错提示这是一个非法类型转换。</p>
<p>事实上，有这样的一个指向关系，指向常量的指针可以指向常量和非常量，而普通指针只能指向非常量，如下图所示。
<img src="https://tommygong.top/image/1682332589055.jpg" />
对上图，从逻辑上是这么理解的，假设一个普通指针
<code>common_pointer</code> 指向且只能指向非常量
<code>non_const_var</code>，通过对 <code>common_pointer</code>
的解引用，我们可以修改非常量 <code>non_const_var</code>
的值。但是如果普通指针 <code>common_pointer</code> 指向一个常量
<code>const_var</code>，理论上来说，可以对普通指针
<code>common_pointer</code> 解引用而修改常量 <code>const_var</code>
的值，但常量又不能修改，所以普通指针只能指向非常量。
对于常量指针的逻辑亦是如此。 那么第二个问题是，<code>cptr</code>
指针指向的内容可以修改吗？显然也是不能修改的，因为它此时指向的是一个常量
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;   <span class="comment">// pi 是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi; <span class="comment">// cptr 是一个指向常量的指针</span></span><br><span class="line">cout &lt;&lt;  *cptr &lt;&lt; endl;   <span class="comment">// 3.14</span></span><br><span class="line">*cptr = <span class="number">9.8</span>;              <span class="comment">// error: assignment of read-only location ‘* cptr’</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure> 可以看到报错的提示是， <code>cptr</code>
具有只读属性。特别的是，即使 <code>cptr</code>
指向的是非常量，它也不能修改这个非常量的内容（如下代码），仅记住一点即可，那就是
<code>cptr</code> 自己本身具有的属性就是只读的。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14</span>;   <span class="comment">// pi 是一个变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi; <span class="comment">// cptr 是一个指向常量的指针</span></span><br><span class="line">cout &lt;&lt;  *cptr &lt;&lt; endl;   <span class="comment">// 3.14</span></span><br><span class="line">*cptr = <span class="number">9.8</span>;              <span class="comment">// error: assignment of read-only location ‘* cptr’</span></span><br></pre></td></tr></table></figure>
虽然指针常量不能修改指向地址的值，但是它可以修改指向的地址，如下可以看到指针常量
a 先指向 b 的地址，之后有成功指向 c 的地址 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* a = &amp;b;</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">	a = &amp;c;</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 常量指针
常量指针寓意着指针本身的内容不能被修改。它的语法是 const 在 *
的右边：<code>char *const p = greeting;</code></p>
<p>下面我们用一张图来解释什么叫“指针的值（指针本身的内容）不能被修改”
<img src="https://tommygong.top/image/1682334139694.jpg" />
虽然这幅图已经说明了一切，但我们还是不妨用代码来进一步解释 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span> pi = <span class="number">3.14</span>;          <span class="comment">// pi 是一个变量</span></span><br><span class="line">   <span class="type">double</span> e = <span class="number">2.71</span>;           <span class="comment">// e 是一个变量</span></span><br><span class="line">   <span class="type">double</span> *<span class="type">const</span> cptr = &amp;pi;  <span class="comment">// cptr 本身的内容不能改变</span></span><br><span class="line">   cout &lt;&lt;  *cptr &lt;&lt; endl;    <span class="comment">// 3.14</span></span><br><span class="line">   cptr = &amp;e;                 <span class="comment">// error: assignment of read-only variable ‘cptr’</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码中，cptr 本来是指向 pi，但是当 cptr 转而指向 e
的时候就会报错，因为 cptr
作为指针，它是常量的，它的内容是不可以改变的。</p>
<p>但是 cptr 指向的内容却是可以改变的，这和
<code>pointer to const</code> 不同 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14</span>;          <span class="comment">// pi 是一个变量</span></span><br><span class="line"><span class="type">double</span> e = <span class="number">2.71</span>;           <span class="comment">// e 是一个变量</span></span><br><span class="line"><span class="type">double</span> *<span class="type">const</span> cptr = &amp;pi;  <span class="comment">// cptr 本身的内容不能改变</span></span><br><span class="line">cout &lt;&lt;  *cptr &lt;&lt; endl;    <span class="comment">// 3.14</span></span><br><span class="line">*cptr = e;        </span><br><span class="line">cout &lt;&lt;  *cptr &lt;&lt; endl;    <span class="comment">// 2.71</span></span><br></pre></td></tr></table></figure>
可以看到在执行完上面的程序后，cptr 指向的值（内容）发生了改变。</p>
<h1 id="对比指向常量的指针与常量指针">对比指向常量的指针与常量指针</h1>
<p>也许直接记忆中文的话会很容易绕进去，不如直接记忆它们各自对应的英文会要很多，即指向常量的指针是
<code>pointer to const</code>，常量指针是
<code>const pointer</code>。</p>
<p>对于 <code>pointer to const</code>
来说，显然指针指向的是一个常量（当然它也可以指向一个非常量），对于
<code>const pointer</code>
来说，显然它自己是一个常量，即这个指针是一个常量，它蕴含的意思是这个指针指向的地址永远不可以改变，就好像你永远住在
xx 省 xx 市 xx 路 xx 号一样。</p>
<p>最后还是用一幅图来解释二者的联系与区别 <img
src="https://tommygong.top/image/1682334250249.jpg" />
红色区域是不能改变的值。</p>
<p>【注】在这幅图中，如果我们把 pi 改为非常量，即
<code>double pi = 3.14</code>; 的形式，虽然依旧不能通过 cptr
来修改它的值，如 <code>*cptr = 2.71 // error</code>，但是可以直接修改 pi
的值是没问题的，如
<code>pi = 2.71; // right</code>。这一点我已经在上面的部分讲过，但在这里还想重复提一下。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br><span class="line">   cout &lt;&lt; *cptr &lt;&lt; endl; <span class="comment">// 3.14</span></span><br><span class="line">   <span class="comment">// *cptr = 2.71; error</span></span><br><span class="line">   pi = <span class="number">2.71</span>;</span><br><span class="line">   cout &lt;&lt; *cptr &lt;&lt; endl; <span class="comment">// 2.71</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 拓展
现在我们思考这样一个问题，存在以下代码，它能否通过编译呢？
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="type">char</span>* pc;</span><br><span class="line">	pc = &amp;c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>** pcc = &amp;pc;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 事实是不能的，在 <code>const char** pcc = &amp;pc;</code>
位置会报错
<code>error: invalid conversion from ‘char**’ to ‘const char**’</code>。原因是，我们的二重指针是
<code>const</code> 的，当 pcc 通过 pc 指向 c 后，逻辑上，我们不希望通过
pcc 来改变 c，但是，pcc 在指向 pc 的时候，pc 不是 const 的，意味着 pc
可以随时改变指针的指向。</p>
<p>上面的代码将 pc 设置为 const 就可以正常运行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pc;</span><br><span class="line">	pc = &amp;c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>** pcc = &amp;pc;</span><br><span class="line">	</span><br><span class="line">	c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// a</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针及动态内存管理</title>
    <url>//posts/1679445169.html</url>
    <content><![CDATA[<h2 id="动态持久内存分配">动态持久内存分配</h2>
<p>KEY POINT</p>
<p>new操作符可以在运行时为基本数据类型、数组和对象分配持久的内存空间。</p>
<p>另外，新版c++标准中可以用变量名称作为数组大小。</p>
<p>之前创建动态数组的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;Enter the size of the array: &quot;</span>;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">cin&gt;&gt;size;</span><br><span class="line"><span class="type">int</span>* list = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br></pre></td></tr></table></figure>
<p>就可以被替换为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;Enter the size of the array: &quot;</span>;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">cin&gt;&gt;size;</span><br><span class="line"><span class="type">int</span> list[size];</span><br></pre></td></tr></table></figure>
<h2 id="创建及访问动态对象">创建及访问动态对象</h2>
<p><strong>关键点</strong>：调用对象的构造函数可以动态的创建对象，语法是
<code>new ClassNmae(arguments)</code>
可以使用如下的语句在堆中动态创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName* pObject1 = <span class="keyword">new</span> <span class="built_in">ClassName</span>(); <span class="comment">//这里使用无参构造函数创建对象，并将对象赋予指针pObject1</span></span><br><span class="line">ClassName* pObject2 = <span class="keyword">new</span> <span class="built_in">ClassName</span>(arguments); <span class="comment">//这里使用有参构造函数创建对象，并将对象赋予指针pObject2</span></span><br></pre></td></tr></table></figure>
<p>通过指针访问对象的数据成员以及成员函数需要先进行<strong>解引用</strong>操作，然后使用点操作符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*pObject1).member = value;</span><br><span class="line">(*pObject1).<span class="built_in">memberFunction</span>(arguments);</span><br></pre></td></tr></table></figure>
<p>或者使用箭头操作符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pObject1-&gt;member = value;</span><br><span class="line">pObject1-&gt;<span class="built_in">memberFunction</span>(arguments);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在使用new操作符创建对象时，必须使用delete操作符来释放内存，否则会造成内存泄漏。</p>
<h2 id="this指针">this指针</h2>
<p><strong>关键点</strong>：this指针是一个隐式的指针，指向当前对象，可以用来访问对象的数据成员和成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Circle</span>();</span><br><span class="line">        <span class="built_in">Circle</span>(<span class="type">double</span>);</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle::<span class="built_in">Circle</span>() &#123;</span><br><span class="line">    radius = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">double</span> radius) &#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; radius = radius;<span class="comment">//or (*this).radius = radius;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::setRadius</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; radius = radius &gt;= <span class="number">0</span> ? radius : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数">析构函数</h2>
<p><strong>关键点</strong>
析构函数没有参数，没有返回值，名字是类名前加上~，一般是释放对象的资源。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库Truncate、Delete和Drop的区别</title>
    <url>//posts/1717671185.html</url>
    <content><![CDATA[<h1 id="truncatedelete和drop的区别">Truncate、Delete和Drop的区别</h1>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 29%" />
<col style="width: 27%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>区别点</th>
<th>drop</th>
<th>truncate</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行速度</td>
<td>快</td>
<td>较快</td>
<td>慢</td>
</tr>
<tr>
<td>命令分类</td>
<td>DDL（数据定义语言）</td>
<td>DDL（数据定义语言）</td>
<td>DML（数据操作语言）</td>
</tr>
<tr>
<td>删除对象</td>
<td>删除整张表和表结构，以及表的索引、约束和触发器。</td>
<td>只删除表数据，表的结构、索引、约束等会被保留。</td>
<td>只删除表的全部或部分数据，表结构、索引、约束等会被保留。</td>
</tr>
<tr>
<td>删除条件(where)</td>
<td>不能用</td>
<td>不能用</td>
<td>可使用</td>
</tr>
<tr>
<td>回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
<td>可回滚</td>
</tr>
<tr>
<td>自增初始值</td>
<td>-</td>
<td>重置</td>
<td>不重置</td>
</tr>
</tbody>
</table>
<p>还没有来得及使用实验去验证（待做），后续考虑开放评论区交流。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记</title>
    <url>//posts/2396792509.html</url>
    <content><![CDATA[<h2 id="数据库原理笔记">数据库原理笔记</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/1.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/2.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/3.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/4.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/5.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/6.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/7.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/8.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/9.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/10.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/11.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/12.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/13.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/14.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/15.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/16.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/17.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/18.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/数据库/19.jpg" /></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构堆(Heap)详解</title>
    <url>//posts/2643315206.html</url>
    <content><![CDATA[<p>基本概念：</p>
<p>1、完全二叉树：若二叉树的深度为h，则除第h层外，其他层的结点全部达到最大值，且第h层的所有结点都集中在左子树。</p>
<p>2、满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</p>
<h2 id="什么是堆">什么是堆？</h2>
<p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li><p>堆中某个节点的值总是不大于或不小于其父节点的值；</p></li>
<li><p>堆总是一棵完全二叉树。</p></li>
</ul>
<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/image-20241207144217704.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/image-20241207144233647.png" /></p>
<p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p>
<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。</p>
<p>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i =
1,2,3,4...n/2)</p>
<p>若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。<br />
<strong>注意： 在二叉树中，若当前节点的下标为 i， 则其父节点的下标为
i/2，其左子节点的下标为 i*2，其右子节点的下标为i*2+1；</strong></p>
<h2 id="堆的插入">堆的插入：</h2>
<p>每次插入都是将先将新数据放在数组最后，由于从这个新数据的父结点到根结点必然为一个有序的序列，现在的任务是将这个新数据插入到这个有序序列中——这就类似于直接插入排序中将一个数据并入到有序区间中。</p>
<p>我们通过一个插入例子来看看插入操作的细节。我们将数字 <code>16</code>
插入到这个堆中：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/f5e2bd8c5cd23174ea4733b3de9bed13.png" /></p>
<p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。</p>
<p>第一步是将新的元素插入到数组的尾部，数组变成：[ 10, 7, 2, 5, 1, 16
]；</p>
<p>相应的树变成了：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/476b7bea162959303bc60f29887f7d88.png" /></p>
<p><code>16</code> 被添加最后一行的第一个空位。</p>
<p>不行的是，现在堆属性不满足，因为 <code>2</code> 在 <code>16</code>
的上面，我们需要将大的数字在上面（这是一个最大堆）</p>
<p>为了恢复堆属性，我们需要交换 <code>16</code> 和 <code>2</code>。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/b01e2fe15b0746e37648947e3dc52efe.png" /></p>
<p>现在还没有完成，因为 <code>10</code> 也比 <code>16</code>
小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的
<strong>shift-up</strong>，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。</p>
<p>最后我们得到的堆：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/c4f062e9f353b77e73fa694bab67aac9.png" /></p>
<p>现在每一个父节点都比它的子节点大。</p>
<h2 id="堆的删除">堆的删除：</h2>
<p>堆中每次都只能删除堆顶元素。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于根结点数据的“下沉”过程。</p>
<p>我们将这个树中的 <code>(10)</code> 删除：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/3b1843281df1093f2f51e695a6a22134.png" /></p>
<p>现在顶部有一个空的节点，怎么处理？</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/a73d1b9388cf6190e3965df91c93e314.png" /></p>
<p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/48773339bf25b99d8c17a14c3a9655fc.png" /></p>
<p>现在来看怎么 <strong>shift-down</strong>
<code>(1)</code>。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换
<code>7</code> 和
<code>2</code>。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换
<code>7</code> 和 <code>1</code>，现在树变成了：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/7de49e3f8841aa1d9d7f6c865e316f86.png" /></p>
<p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/b8d775a60047391847a4be533697c7d0.png" /></p>
<h2 id="最大堆">最大堆：</h2>
<h4 id="构造最大堆">1，构造最大堆</h4>
<p>原始数据为a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8,
7}，采用顺序存储方式，对应的完全二叉树如下图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/bd6125df0507026075d897a710a5acd0.png" /></p>
<p><strong>基本思想</strong>：<br />
首先将每个叶子节点视为一个堆，再将每个叶子节点与其父节点一起构造成一个包含更多节点的对。所以，在构造堆的时候，首先需要找到最后一个节点的父节点，从这个节点开始构造最大堆；直到该节点前面所有分支节点都处理完毕，这样最大堆就构造完毕了。<br />
<em>假设树的节点个数为n，以1为下标开始编号，直到n结束。对于节点i，其父节点为i/2；左孩子节点为i*2，右孩子节点为i*2+1。最后一个节点的下标为n，其父节点的下标为n/2。</em><br />
我们边针对上边数组操作如下图所示，最后一个节点为7，其父节点为16，从16这个节点开始构造最大堆；构造完毕之后，转移到下一个父节点2，直到所有父节点都构造完毕。<br />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/038ba2c57f8352ffb48937a4a1cc010e.png" /></p>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strcut MaxHeap</span><br><span class="line">&#123;</span><br><span class="line">	Etype *heap; <span class="comment">//数据元素存放的空间，下标从1开始存数数据，下标为0的作为工作空间，存储临时数据</span></span><br><span class="line">	<span class="type">int</span> HeapSize;<span class="comment">//数据元素的个数</span></span><br><span class="line">	<span class="type">int</span> MaxSize; <span class="comment">//存放数据元素空间的大小</span></span><br><span class="line">&#125;;</span><br><span class="line">MaxHeap H;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeapInit</span> <span class="params">(MaxHeap &amp;H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = H.HeapSize/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		H.heap[<span class="number">0</span>] = H.heap[i];</span><br><span class="line">		<span class="type">int</span> son = i*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(son &lt;= H.HeapSize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(son &lt; H.HeapSize &amp;&amp; H.heap[son] &lt; H.heap[son<span class="number">+1</span>])</span><br><span class="line">				son++;</span><br><span class="line">			<span class="keyword">if</span>(H.heap[<span class="number">0</span>] &gt;= H.heap[son])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				H.heap[son/<span class="number">2</span>] = H.heap[son];</span><br><span class="line">				son *= <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		H.heap[son/<span class="number">2</span>] = H.heap[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>再举一个详细的实例过程：</strong></p>
<p>给定一个整形数组a[]={16,7,3,20,17,8}，对其进行堆排序。首先根据该数组元素构建一个完全二叉树，具体过程如下(从左到右，从上到下按顺序一步一步的详细过程)：<br />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/65201c4eddadcfe4bfaf975baa98c277.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/b393505e2e7c7d61838f28dc08debc3d.png" /><br />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/4b2ff3c1db988e24cbf50772f527612d.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/07f13665a80ec3bc3fde685898c9263b.png" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/35cf22381f11333aba21f372eeebb965.png" /><br />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86(Heap)%E8%AF%A6%E8%A7%A3/7fd9a21e0ebf0d767a8d39d59987369b.png" /></p>
<h4 id="最大堆插入节点">2，最大堆插入节点</h4>
<p>最大堆的插入节点的思想就是先在堆的最后添加一个节点，然后沿着堆树上升。跟最大堆的初始化过程大致相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeapInsert</span> <span class="params">(MaxHeap &amp;H, EType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H.HeapSize == H.MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i = ++H.HeapSize;</span><br><span class="line">	<span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; x&gt;H.heap[i/<span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		H.heap[i] = H.heap[i/<span class="number">2</span>];</span><br><span class="line">		i = i/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	H.heap[i] = x;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大堆堆顶节点删除">3，最大堆堆顶节点删除</h4>
<p>最大堆堆顶节点删除思想如下：将堆树的最后的节点提到根结点，然后删除最大值，然后再把新的根节点放到合适的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeapDelete</span> <span class="params">(MaxHeap &amp;H, EType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H.HeapSize == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = H.heap[<span class="number">1</span>];</span><br><span class="line">	H.heap[<span class="number">0</span>] = H.heap[H.HeapSize--];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>, son = i*<span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(son &lt;= H.HeapSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(son &lt;= H.HeapSize &amp;&amp; H.heap[<span class="number">0</span>] &lt; H.heap[son<span class="number">+1</span>])</span><br><span class="line">			son++;</span><br><span class="line">		<span class="keyword">if</span>(H.heap[<span class="number">0</span>] &gt;= H.heap[son])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		H.heap[i] = H.heap[son];</span><br><span class="line">		i = son;</span><br><span class="line">		son  = son*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	H.heap[i] = H.heap[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小堆">最小堆</h2>
<p>整体操作和最大堆类似，这里不做赘述。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>留园现场课笔记</title>
    <url>//posts/3381953697.html</url>
    <content><![CDATA[<p>因为本来就是苏州人，暑假有时间可再次造访留园，所以这次没有去留园，听直播课讲解以后的一些心得体会。</p>
<span id="more"></span>
<p>园林的空间体验，不会一下看清空间是什么，在第一次空间体验中无法感受到空间的全貌。需要通过两次甚至三次的重复体验才能够感受到完整的空间。
在感受空间的过程中，设计者往往会给出一些线索，比如露出影子的树，去引导你的游览路线。墙上的窗形成的孔隙也是一种线索，通过孔隙将园林中的景观和空间相互联系，同时孔隙之间还会产生联系，在极小的空间内营造出极为丰富的空间体验。</p>
<p>z字型转折，廊道，在功能上毫无用处。但是，这种“无用”的转折可以营丰富且拥有深度的空间。有的转折会漏出两个孔洞，空洞之间会有一个对话的关系。园林有很多曲折的廊道，求曲而不求直，曲折的意义，通过一个转折漏出了空间空隙，并且在孔隙中形成了空间景观。</p>
<p>廊道与柱子构成了虚的空间划分，将廊道和转折所构成的景观分割成了对立空间，从而产生了一种距离感，景不是让你游的，而是让人远离景观去远观画的。同时，空间光线的巧妙安排使得景物一边有自然光线渗入，而人所在的廊道较暗，形成了景物在舞台上，人在观众席上的感觉，进而形成人与景的对话关系。</p>
<p>古木交柯，在空间感觉上一下子就知道是主体。这种主体的感觉是通过空的院子与主院做对比才得到的。</p>
<p>空间序列越走越大就没有反预期，在空间上的收放交替，即将进入大空间却实际进入了小空间等。建筑是带有时间性的艺术创作，形成节奏变化，不能非常规整</p>
<p>正厅前有转折，绕过屏风才能到达，形成了另一种反预期。</p>
<p>似乎逼进水院，但是一个转折之间就到了另外一个地方，空间组织上的反预期</p>
<p>小中见大
边界和孔隙之关系，他们的空间角色一样，目的都是创建同更多孔隙之间的关系
中国传统观念中的返璞归真接近自然，造就了孔隙式园林空间。转折也是为了创造更多的空间层次和孔隙。跳开实体意识到“空”的存在的时候，就可以意识到空的逻辑以及用意，对于孔隙和边界与景的关系就有更加深入的理解与思考。（孔隙和边界形成了人与景的对话关系，同时孔隙之间还会形成对话，孔隙和边界也可以用于营造反预期，在极小的空间里形成丰富的空间体验）</p>
<p>园林解决的是人更高层次更高需求，是人在达到富足之后产生心理需求之后诞生的院子
，所以在实用性上会有所减弱，不能总是用实用的眼光去看园林空间，在园林里所有事情可以无用，在这里，空间变化不是为了使用，而是为了空间体验，比如前面的人走进去某个空间之后，后面的人会好奇你是怎么走进去了</p>
<p>深度的概念 庭院深，景深 是不同的概念
进入留园的过程是不断深入的过程，走得越深的时候感受到更浅的空间，创造可见不可达，也就是创建空间深度，极小空间内实现去而复返</p>
<p>凸空间 在凸空间内的一个站点，可以控制整个空间。</p>
<p>建筑学研究的是空间和空间形态对人的影响，以及过程是如何发生的</p>
<p>留园是一个拥有丰富空间调度的案例，每一个角落都是精心策划的反馈，在运动过程中不断调动深度，形成的空间的层次。</p>
<p>石林小院更像是一个空间魔法盒，走入石林小院，像是进入了迷宫，四周开口，不知道哪里更深。各个小的庭院，深度都是相似的，同时石林小院形成了大量的使用窗和凭栏创造的
可见而不可达。一直在同一深度，扁平化的深度</p>
<p>园林整个组织就是空间反预期 长廊——反预期 五峰仙馆——去而复返
石林小院——同一深度不断游移
都体现了空间密集型调度和舒展与不断收放的调度体验</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>建筑学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>机械工业出版社黑皮书ISBN收集</title>
    <url>//posts/788421571.html</url>
    <content><![CDATA[<h2 id="命名规范">命名规范：</h2>
<p>​ <strong>书名</strong>.[版本].<em>(ISBN#出版社@出版年)</em></p>
<h2 id="书籍列表">书籍列表：</h2>
<ul>
<li><strong>3D计算机图形学</strong>.[原书第3版].<em>(9787111165132#机械工业出版社@2005)</em>.pdf</li>
<li><strong>3D游戏 卷1
实时渲染与软件技术</strong>.<em>(9787111156529#机械工业出版社@2005)</em>.pdf</li>
<li><strong>3D游戏 卷2
动画与高级实时渲染技术</strong>.<em>(9787111157762#机械工业出版社@2005)</em>.pdf</li>
<li><strong>8051微控制器和嵌入式系统</strong>.[原书第2版].<em>(9787111215240#机械工业出版社@2007)</em>.pdf</li>
<li><strong>80x86汇编语言基础教程</strong>.<em>(9787111253822#机械工业出版社@2009)</em>.pdf</li>
<li><strong>80x86汇编语言与计算机体系结构</strong>.<em>(9787111176176#机械工业出版社@2006)</em>.pdf</li>
<li><strong>ARM嵌入式系统编程与优化</strong>.<em>(9787111578031#机械工业出版社@2017)</em>.pdf</li>
<li><strong>C＃程序设计语言</strong>.[原书第4版].<em>(9787111347781#机械工业出版社@2011)</em>.pdf</li>
<li><strong>C++编程思想</strong>.<em>(9787111071167#机械工业出版社@2000)</em>.pdf</li>
<li><strong>C++编程思想 第1卷
标准C++导引</strong>.[第2版].<em>(9787111108078#机械工业出版社@2002)</em>.pdf</li>
<li><strong>C++编程思想 第2卷
实用编程技术</strong>.<em>(9787111171157#机械工业出版社@2006)</em>.pdf</li>
<li><strong>C++编程思想</strong>.[两卷合订本].<em>(9787111350217#机械工业出版社@2011)</em>.pdf</li>
<li><strong>C++程序设计
基础、编程抽象与算法策略</strong>.<em>(9787111546962#机械工业出版社@2016)</em>.pdf</li>
<li><strong>C++程序设计 原理与实践
基础篇</strong>.[原书第2版].<em>(9787111562252#机械工业出版社@2017)</em>.pdf</li>
<li><strong>C++程序设计 原理与实践
进阶篇</strong>.[原书第2版].<em>(9787111562528#机械工业出版社@2017)</em>.pdf</li>
<li><strong>C++程序设计</strong>.<em>(9787111240174#机械工业出版社@2008)</em>.pdf</li>
<li><strong>C++程序设计</strong>.[原书第3版].<em>(9787111485148#机械工业出版社@2014)</em>.pdf</li>
<li><strong>C++程序设计语言
第1～3部分</strong>.[原书第4版].<em>(9787111539414#机械工业出版社@2016)</em>.pdf</li>
<li><strong>C++程序设计语言 第4部分
标准库</strong>.[原书第4版].<em>(9787111544395#机械工业出版社@2016)</em>.pdf</li>
<li><strong>C++程序设计语言</strong>.[特别版].<em>(9787111102021#机械工业出版社@2002)</em>.pdf</li>
<li><strong>C++程序设计语言</strong>.[特别版][十周年中文纪念版].<em>(9787111298854#机械工业出版社@2010)</em>.pdf</li>
<li><strong>C++程序设计原理与实践</strong>.<em>(9787111303220#机械工业出版社@2010)</em>.pdf</li>
<li><strong>C++精解和程序设计</strong>.[原书第5版].<em>(9787111238942#机械工业出版社@2008)</em>.pdf</li>
<li><strong>C++精粹</strong>.<em>(9787111127468#机械工业出版社@2003)</em>.pdf</li>
<li><strong>C++精髓
软件工程方法</strong>.<em>(9787111101000#机械工业出版社@2002)</em>.pdf</li>
<li><strong>C++语言导学</strong>.<em>(9787111498124#机械工业出版社@2015)</em>.pdf</li>
<li><strong>C++语言导学</strong>.[原书第2版].<em>(9787111633280#机械工业出版社@2019)</em>.pdf</li>
<li><strong>C++语言的设计和演化</strong>.<em>(9787111090984#机械工业出版社@2002)</em>.pdf</li>
<li><strong>C程序设计
软件工程环境</strong>.[原书第3版].<em>(9787111237693#机械工业出版社@2008)</em>.pdf</li>
<li><strong>C程序设计教程</strong>.<em>(9787111079521#机械工业出版社@2000)</em>.pdf</li>
<li><strong>C程序设计语言
习题解答</strong>.[第2版][新版].<em>(9787111129431#机械工业出版社@2004)</em>.pdf</li>
<li><strong>C程序设计语言</strong>.[第2版][新版].<em>(9787111128069#机械工业出版社@2004)</em>.pdf</li>
<li><strong>C程序设计语言</strong>.[第2版][新版][典藏版].<em>(9787111617945#机械工业出版社@2019)</em>.pdf</li>
<li><strong>C语言参考手册</strong>.[原书第5版].<em>(9787111122197#机械工业出版社@2003)</em>.pdf</li>
<li><strong>C语言程序设计
问题解答和实例解析方法</strong>.<em>(9787111543343#机械工业出版社@2016)</em>.pdf</li>
<li><strong>C语言程序设计进阶教程</strong>.<em>(9787111568407#机械工业出版社@2017)</em>.pdf</li>
<li><strong>C语言程序设计与问题求解</strong>.[原书第7版].<em>(9787111563846#机械工业出版社@2017)</em>.pdf</li>
<li><strong>C语言的科学和艺术</strong>.<em>(9787111159711#机械工业出版社@2005)</em>.pdf</li>
<li><strong>C语言接口与实现
创建可重用软件的技术</strong>.<em>(9787111130055#机械工业出版社@2004)</em>.pdf</li>
<li><strong>DW2.0
下一代数据仓库的构架</strong>.<em>(9787111288268#机械工业出版社@2010)</em>.pdf</li>
<li><strong>Go程序设计语言</strong>.<em>(9787111558422#机械工业出版社@2017)</em>.pdf</li>
<li><strong>Haskell函数式程序设计</strong>.<em>(9787111529323#机械工业出版社@2016)</em>.pdf</li>
<li><strong>Intel微处理器</strong>.[原书第7版].<em>(9787111228271#机械工业出版社@2008)</em>.pdf</li>
<li><strong>Intel微处理器</strong>.[原书第8版].<em>(9787111304852#机械工业出版社@2010)</em>.pdf</li>
<li><strong>Internet技术基础</strong>.[原书第4版].<em>(9787111237891#机械工业出版社@2008)</em>.pdf</li>
<li><strong>IT项目管理</strong>.[原书第4版].<em>(9787111240235#机械工业出版社@2008)</em>.pdf</li>
<li><strong>IT项目管理</strong>.[原书第7版].<em>(9787111509561#机械工业出版社@2015)</em>.pdf</li>
<li><strong>Java编程思想</strong>.[第3版].<em>(9787111162209#机械工业出版社@2005)</em>.pdf</li>
<li><strong>Java编程思想</strong>.[第4版].<em>(9787111213826#机械工业出版社@2007)</em>.pdf</li>
<li><strong>Java程序设计
对象和软件工程方法</strong>.[原书第2版].<em>(9787111199892#机械工业出版社@2007)</em>.pdf</li>
<li><strong>Java程序设计
基础、编程抽象与算法策略</strong>.<em>(9787111578277#机械工业出版社@2017)</em>.pdf</li>
<li><strong>Java程序设计概念
对象先行</strong>.[原书第8版].<em>(9787111593669#机械工业出版社@2018)</em>.pdf</li>
<li><strong>Java程序设计教程</strong>.<em>(9787111246619#机械工业出版社@2008)</em>.pdf</li>
<li><strong>Java程序设计教程</strong>.[原书第3版].<em>(9787111489900#机械工业出版社@2015)</em>.pdf</li>
<li><strong>Java程序设计与数据结构导论</strong>.<em>(9787111241775#机械工业出版社@2008)</em>.pdf</li>
<li><strong>Java程序设计与问题求解</strong>.[原书第8版].<em>(9787111620976#机械工业出版社@2019)</em>.pdf</li>
<li><strong>Java面向对象程序设计
图形化方法</strong>.<em>(9787111191612#机械工业出版社@2006)</em>.pdf</li>
<li><strong>Java语言程序设计
基础篇</strong>.[原书第8版].<em>(9787111340812#机械工业出版社@2011)</em>.pdf</li>
<li><strong>Java语言程序设计
基础篇</strong>.[原书第10版].<em>(9787111506904#机械工业出版社@2015)</em>.pdf</li>
<li><strong>Java语言程序设计
进阶篇</strong>.[原书第8版].<em>(9787111342366#机械工业出版社@2011)</em>.pdf</li>
<li><strong>Java语言程序设计
进阶篇</strong>.[原书第10版].<em>(9787111548560#机械工业出版社@2016)</em>.pdf</li>
<li><strong>Java语言程序设计与数据结构
基础篇</strong>.[原书第11版].<em>(9787111600749#机械工业出版社@2018)</em>.pdf</li>
<li><strong>Java语言程序设计与数据结构
进阶篇</strong>.[原书第11版].<em>(9787111610038#机械工业出版社@2018)</em>.pdf</li>
<li><strong>Java语言导学</strong>.[原书第5版].<em>(9787111503927#机械工业出版社@2015)</em>.pdf</li>
<li><strong>Java语言导学</strong>.[原书第6版].<em>(9787111573302#机械工业出版社@2017)</em>.pdf</li>
<li><strong>Java语言规范 基于Java SE
8</strong>.<em>(9787111523994#机械工业出版社@2016)</em>.pdf</li>
<li><strong>Linux内核设计与实现</strong>.[第2版].<em>(9787111178651#机械工业出版社@2005)</em>.pdf</li>
<li><strong>LLVM编译器实战教程</strong>.<em>(9787111631972#机械工业出版社@2019)</em>.pdf</li>
<li><strong>MATLAB程序设计</strong>.[原书第3版].<em>(9787111603016#机械工业出版社@2018)</em>.pdf</li>
<li><strong>MATLAB程序设计导论</strong>.<em>(9787111625988#机械工业出版社@2019)</em>.pdf</li>
<li><strong>MATLAB工程计算</strong>.[原书第3版].<em>(9787111607922#机械工业出版社@2018)</em>.pdf</li>
<li><strong>MATLAB数值计算</strong>.<em>(9787111187370#机械工业出版社@2006)</em>.pdf</li>
<li><strong>MIPS体系结构透视</strong>.[原书第2版].<em>(9787111233626#机械工业出版社@2008)</em>.pdf</li>
<li><strong>ML程序设计教程</strong>.[原书第2版].<em>(9787111161219#机械工业出版社@2005)</em>.pdf</li>
<li><strong>Processing编程学习指南</strong>.[原书第2版].<em>(9787111558675#机械工业出版社@2017)</em>.pdf</li>
<li><strong>Python程序设计</strong>.<em>(9787111526278#机械工业出版社@2016)</em>.pdf</li>
<li><strong>Python程序设计</strong>.[原书第2版].<em>(9787111611479#机械工业出版社@2018)</em>.pdf</li>
<li><strong>Python程序设计基础</strong>.[原书第4版].<em>(9787111611745#机械工业出版社@2018)</em>.pdf</li>
<li><strong>Python程序设计与问题求解</strong>.[原书第2版].<em>(9787111626138#机械工业出版社@2019)</em>.pdf</li>
<li><strong>Python计算与编程实践
多媒体方法</strong>.[原书第2版].<em>(9787111387381#机械工业出版社@2012)</em>.pdf</li>
<li><strong>Python科学计算</strong>.[原书第2版].<em>(9787111633907#机械工业出版社@2019)</em>.pdf</li>
<li><strong>Python语言程序设计</strong>.<em>(9787111487685#机械工业出版社@2015)</em>.pdf</li>
<li><strong>R语言与数据挖掘
最佳实践和经典案例</strong>.<em>(9787111475415#机械工业出版社@2014)</em>.pdf</li>
<li><strong>Scala编程思想</strong>.[原书第2版].<em>(9787111517405#机械工业出版社@2015)</em>.pdf</li>
<li><strong>TCP_IP详解 卷1
协议</strong>.<em>(9787111075660#机械工业出版社@2000)</em>.pdf</li>
<li><strong>TCP_IP详解 卷1
协议</strong>.[原书第2版].<em>(9787111453833#机械工业出版社@2016)</em>.pdf</li>
<li><strong>TCP_IP详解 卷2
实现</strong>.(9787111075677#机械工业出版社@2000).pdf</li>
<li><strong>TCP_IP详解 卷2
实现</strong>.<em>(9787111617938#机械工业出版社@2019)</em>.pdf</li>
<li><strong>TCP_IP详解 卷3
TCP事务协议、HTTP、NNTP和UNIX域协议</strong>.<em>(9787111075684#机械工业出版社@2000)</em>.pdf</li>
<li><strong>TCP_IP详解 卷3
TCP事务协议、HTTP、NNTP和UNIX域协议</strong>.<em>(9787111617778#机械工业出版社@2019)</em>.pdf</li>
<li><strong>UNIX编程环境</strong>.<em>(9787111071150#机械工业出版社@1999)</em>.pdf</li>
<li><strong>UNIX操作系统设计</strong>.<em>(9787111078500#机械工业出版社@2000)</em>.pdf</li>
<li><strong>UNIX环境高级编程</strong>.<em>(9787111075790#机械工业出版社@2000)</em>.pdf</li>
<li><strong>UNIX教程</strong>.[第2版].<em>(9787111186021#机械工业出版社@2006)</em>.pdf</li>
<li><strong>Web服务
原理和技术</strong>.<em>(9787111284147#机械工业出版社@2009)</em>.pdf</li>
<li><strong>Web工程
实践者研究方法</strong>.<em>(9787111282501#机械工业出版社@2010)</em>.pdf</li>
<li><strong>编程原本</strong>.<em>(9787111367291#机械工业出版社@2011)</em>.pdf</li>
<li><strong>编码的奥秘</strong>.<em>(9787111080787#机械工业出版社@2000)</em>.pdf</li>
<li><strong>编译程序设计艺术
理论与实践</strong>.<em>(9787111288107#机械工业出版社@2010)</em>.pdf</li>
<li><strong>编译器工程</strong>.<em>(9787111179627#机械工业出版社@2006)</em>.pdf</li>
<li><strong>编译器构造
C语言描述</strong>.<em>(9787111164746#机械工业出版社@2005)</em>.pdf</li>
<li><strong>编译原理</strong>.<em>(9787111123491#机械工业出版社@2003)</em>.pdf</li>
<li><strong>编译原理</strong>.[第2版].<em>(9787111251217#机械工业出版社@2008)</em>.pdf</li>
<li><strong>编译原理</strong>.[第2版][本科教学版].<em>(9787111269298#机械工业出版社@2009)</em>.pdf</li>
<li><strong>编译原理及实践</strong>.<em>(9787111077039#机械工业出版社@2000)</em>.pdf</li>
<li><strong>并行编程模式</strong>.<em>(9787111490180#机械工业出版社@2015)</em>.pdf</li>
<li><strong>并行程序设计</strong>.[第2版].<em>(9787111162605#机械工业出版社@2005)</em>.pdf</li>
<li><strong>并行程序设计导论</strong>.<em>(9787111392842#机械工业出版社@2012)</em>.pdf</li>
<li><strong>并行程序设计原理</strong>.<em>(9787111270751#机械工业出版社@2009)</em>.pdf</li>
<li><strong>并行多核体系结构基础</strong>.<em>(9787111610410#机械工业出版社@2018)</em>.pdf</li>
<li><strong>并行计算导论</strong>.[原书第2版].<em>(9787111149859#机械工业出版社@2004)</em>.pdf</li>
<li><strong>并行计算的编程模型</strong>.<em>(9787111573340#机械工业出版社@2017)</em>.pdf</li>
<li><strong>并行计算机体系结构
硬件_软件结合的设计与分析</strong>.[原书第2版].<em>(9787111078883#机械工业出版社@2002)</em>.pdf</li>
<li><strong>并行计算机组成与设计</strong>.<em>(9787111562238#机械工业出版社@2017)</em>.pdf</li>
<li><strong>并行算法导论</strong>.<em>(9787111133902#机械工业出版社@2004)</em>.pdf</li>
<li><strong>操作系统
精髓与设计原理</strong>.[原书第6版].<em>(9787111304265#机械工业出版社@2010)</em>.pdf</li>
<li><strong>操作系统</strong>.[原书第3版].<em>(9787111163787#机械工业出版社@2005)</em>.pdf</li>
<li><strong>操作系统概念</strong>.[原书第9版].<em>(9787111604365#机械工业出版社@2018)</em>.pdf</li>
<li><strong>操作系统概念精要</strong>.[原书第2版].<em>(9787111606482#机械工业出版社@2018)</em>.pdf</li>
<li><strong>操作系统设计
Xinu方法</strong>.<em>(9787111428268#机械工业出版社@2013)</em>.pdf</li>
<li><strong>操作系统设计
Xinu方法</strong>.[原书第2版].<em>(9787111621911#机械工业出版社@2019)</em>.pdf</li>
<li><strong>操作系统实用教程
螺旋方法</strong>.<em>(9787111588191#机械工业出版社@2018)</em>.pdf</li>
<li><strong>程序设计导论
Python计算与应用开发实践</strong>.[原书第2版].<em>(9787111611608#机械工业出版社@2018)</em>.pdf</li>
<li><strong>程序设计导论
Python语言实践</strong>.<em>(9787111549246#机械工业出版社@2016)</em>.pdf</li>
<li><strong>程序设计基础</strong>.[原书第3版].<em>(9787111596806#机械工业出版社@2018)</em>.pdf</li>
<li><strong>程序设计实践</strong>.<em>(9787111075738#机械工业出版社@2000)</em>.pdf</li>
<li><strong>程序设计语言的形式语义</strong>.<em>(9787111131533#机械工业出版社@2004)</em>.pdf</li>
<li><strong>程序设计语言原理</strong>.[原书第7版].<em>(9787111208532#机械工业出版社@2007)</em>.pdf</li>
<li><strong>程序设计语言原理</strong>.[原书第8版].<em>(9787111239512#机械工业出版社@2008)</em>.pdf</li>
<li><strong>从M2M到物联网
架构、技术及应用</strong>.<em>(9787111541820#机械工业出版社@2016)</em>.pdf</li>
<li><strong>地理信息系统导论</strong>.[原书第3版].<em>(9787111180135#机械工业出版社@2006)</em>.pdf</li>
<li><strong>地理信息系统与科学</strong>.[原书第2版].<em>(9787111206361#机械工业出版社@2007)</em>.pdf</li>
<li><strong>电子商务</strong>.<em>(9787111082163#机械工业出版社@2000)</em>.pdf</li>
<li><strong>多处理器编程的艺术</strong>.<em>(9787111268055#机械工业出版社@2009)</em>.pdf</li>
<li><strong>多处理器编程的艺术</strong>.[修订版].<em>(9787111418580#机械工业出版社@2013)</em>.pdf</li>
<li><strong>多媒体方法技术教程</strong>.<em>(9787111199755#机械工业出版社@2007)</em>.pdf</li>
<li><strong>多语自然语言处理
从原理到实践</strong>.<em>(9787111484912#机械工业出版社@2015)</em>.pdf</li>
<li><strong>分布式操作系统
原理与实践</strong>.<em>(9787111109525#机械工业出版社@2003)</em>.pdf</li>
<li><strong>分布式计算的安全原理</strong>.<em>(9787111108276#机械工业出版社@2002)</em>.pdf</li>
<li><strong>分布式控制系统设计
模式语言方法</strong>.<em>(9787111583905#机械工业出版社@2017)</em>.pdf</li>
<li><strong>分布式实时系统
原理与设计方法</strong>.[原书第2版].<em>(9787111613770#机械工业出版社@2018)</em>.pdf</li>
<li><strong>分布式算法</strong>.<em>(9787111131274#机械工业出版社@2004)</em>.pdf</li>
<li><strong>分布式算法导论</strong>.[原书第2版].<em>(9787111146742#机械工业出版社@2004)</em>.pdf</li>
<li><strong>分布式系统
概念与设计</strong>.[原书第3版].<em>(9787111129561#机械工业出版社@2004)</em>.pdf</li>
<li><strong>分布式系统
概念与设计</strong>.[原书第4版].<em>(9787111224389#机械工业出版社@2008)</em>.pdf</li>
<li><strong>分布式系统
概念与设计</strong>.[原书第5版].<em>(9787111403920#机械工业出版社@2013)</em>.pdf</li>
<li><strong>复杂SOC设计</strong>.<em>(9787111192152#机械工业出版社@2006)</em>.pdf</li>
<li><strong>高级UNIX编程</strong>.[原书第2版].<em>(9787111185215#机械工业出版社@2006)</em>.pdf</li>
<li><strong>高级编译器设计与实现</strong>.<em>(9787111164296#机械工业出版社@2005)</em>.pdf</li>
<li><strong>高效程序的奥秘</strong>.<em>(9787111141112#机械工业出版社@2004)</em>.pdf</li>
<li><strong>高性能并行珠玑
多核和众核编程方法</strong>.<em>(9787111580805#机械工业出版社@2017)</em>.pdf</li>
<li><strong>高性能科学与工程计算</strong>.<em>(9787111466529#机械工业出版社@2014)</em>.pdf</li>
<li><strong>高性能嵌入式计算</strong>.<em>(9787111288220#机械工业出版社@2010)</em>.pdf</li>
<li><strong>高性能嵌入式计算</strong>.[原书第2版].<em>(9787111540519#机械工业出版社@2016)</em>.pdf</li>
<li><strong>工程问题C++语言求解</strong>.[原书第3版].<em>(9787111459071#机械工业出版社@2014)</em>.pdf</li>
<li><strong>工程问题C语言求解</strong>.[原书第4版].<em>(9787111554417#机械工业出版社@2016)</em>.pdf</li>
<li><strong>函数式算法设计珠玑</strong>.<em>(9787111562511#机械工业出版社@2017)</em>.pdf</li>
<li><strong>汇编程序设计与计算机体系结构
软件工程师教程</strong>.<em>(9787111615163#机械工业出版社@2019)</em>.pdf</li>
<li><strong>汇编语言
基于x86处理器</strong>.[原书第7版].<em>(9787111530367#机械工业出版社@2016)</em>.pdf</li>
<li><strong>机器视觉教程</strong>.<em>(9787111167907#机械工业出版社@2005)</em>.pdf</li>
<li><strong>机器学习</strong>.<em>(9787111109938#机械工业出版社@2008)</em>.pdf</li>
<li><strong>机器学习导论</strong>.<em>(9787111265245#机械工业出版社@2009)</em>.pdf</li>
<li><strong>机器学习导论</strong>.[原书第2版].<em>(9787111453772#机械工业出版社@2014)</em>.pdf</li>
<li><strong>机器学习导论</strong>.[原书第3版].<em>(9787111521945#机械工业出版社@2016)</em>.pdf</li>
<li><strong>机器学习基础教程</strong>.<em>(9787111407027#机械工业出版社@2013)</em>.pdf</li>
<li><strong>基于FPGA的系统设计</strong>.<em>(9787111187073#机械工业出版社@2006)</em>.pdf</li>
<li><strong>计算复杂性
现代方法</strong>.<em>(9787111518990#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算复杂性</strong>.<em>(9787111517351#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机安全
原理与实践</strong>.<em>(9787111241492#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机安全
原理与实践</strong>.[原书第3版].<em>(9787111528098#机械工业出版社@2016)</em>.pdf</li>
<li><strong>计算机安全
原理与实践</strong>.[原书第4版].<em>(9787111617655#机械工业出版社@2019)</em>.pdf</li>
<li><strong>计算机安全学</strong>.[原书第2版].<em>(9787111228646#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机程序的构造和解释</strong>.[原书第2版].<em>(9787111135104#机械工业出版社@2004)</em>.pdf</li>
<li><strong>计算机程序的构造和解释</strong>.[原书第2版][典藏版].<em>(9787111630548#机械工业出版社@2019)</em>.pdf</li>
<li><strong>计算机存储与外设</strong>.<em>(9787111557487#机械工业出版社@2017)</em>.pdf</li>
<li><strong>计算机工程的物理基础</strong>.<em>(9787111590743#机械工业出版社@2018)</em>.pdf</li>
<li><strong>计算机科学导论
跨学科方法</strong>.<em>(9787111641414#机械工业出版社@2020)</em>.pdf</li>
<li><strong>计算机科学导论</strong>.[原书第2版].<em>(9787111131595#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机科学导论</strong>.[原书第3版].<em>(9787111511632#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机科学导论</strong>.[原书第4版].<em>(9787111654636#机械工业出版社@2020)</em>.pdf</li>
<li><strong>计算机科学概论</strong>.[原书第3版].<em>(9787111170167#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机科学概论</strong>.[原书第5版].<em>(9787111534259#机械工业出版社@2016)</em>.pdf</li>
<li><strong>计算机视觉
模型、学习和推理</strong>.<em>(9787111516828#机械工业出版社@2017)</em>.pdf</li>
<li><strong>计算机视觉</strong>.<em>(9787111159728#机械工业出版社@2005)</em>.pdf</li>
<li><strong>计算机算法的设计与分析</strong>.<em>(9787111215431#机械工业出版社@2007)</em>.pdf</li>
<li><strong>计算机体系结构
嵌入式方法</strong>.<em>(9787111379041#机械工业出版社@2012)</em>.pdf</li>
<li><strong>计算机体系结构精髓</strong>.[原书第2版].<em>(9787111626589#机械工业出版社@2019)</em>.pdf</li>
<li><strong>计算机图形学</strong>.<em>(9787111241027#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机图形学导论</strong>.<em>(9787111141471#机械工业出版社@2004)</em>.pdf</li>
<li><strong>计算机图形学与虚拟环境</strong>.<em>(9787111148241#机械工业出版社@2004)</em>.pdf</li>
<li><strong>计算机图形学原理及实践
C语言描述</strong>.[原书第2版].<em>(9787111130260#机械工业出版社@2004)</em>.pdf</li>
<li><strong>计算机图形学原理及实践
基础篇</strong>.[原书第3版].<em>(9787111611806#机械工业出版社@2018)</em>.pdf</li>
<li><strong>计算机网络
网络设计的原理、技术和协议</strong>.<em>(9787111228851#机械工业出版社@2007)</em>.pdf</li>
<li><strong>计算机网络
系统方法</strong>.[原书第4版].<em>(9787111251385#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机网络
系统方法</strong>.[原书第5版].<em>(9787111499077#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机网络
一种开源的设计实现方法</strong>.<em>(9787111426042#机械工业出版社@2014)</em>.pdf</li>
<li><strong>计算机网络
自顶向下方法</strong>.[原书第4版].<em>(9787111165057#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机网络
自顶向下方法</strong>.[原书第6版].<em>(9787111453789#机械工业出版社@2014)</em>.pdf</li>
<li><strong>计算机网络
自顶向下方法</strong>.[原书第7版].<em>(9787111599715#机械工业出版社@2018)</em>.pdf</li>
<li><strong>计算机网络教程
自顶向下方法</strong>.<em>(9787111400882#机械工业出版社@2013)</em>.pdf</li>
<li><strong>计算机网络实验教程</strong>.<em>(9787111415855#机械工业出版社@2013)</em>.pdf</li>
<li><strong>计算机网络实用教程</strong>.<em>(9787111081289#机械工业出版社@2000)</em>.pdf</li>
<li><strong>计算机网络与因特网</strong>.<em>(9787111075707#机械工业出版社@2000)</em>.pdf</li>
<li><strong>计算机网络与因特网</strong>.[原书第5版].<em>(9787111268314#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机文化</strong>.[原书第10版].<em>(9787111246879#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机文化</strong>.[原书第13版].<em>(9787111326557#机械工业出版社@2011)</em>.pdf</li>
<li><strong>计算机文化</strong>.[原书第15版].<em>(9787111465409#机械工业出版社@2014)</em>.pdf</li>
<li><strong>计算机文化</strong>.[原书第20版].<em>(9787111608332#机械工业出版社@2018)</em>.pdf</li>
<li><strong>计算机文化导论</strong>.[原书第10版].<em>(9787111282365#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机系统
核心概念及软硬件实现</strong>.[原书第4版].<em>(9787111507833#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机系统
核心概念及软硬件实现</strong>.[原书第5版].<em>(9787111616849#机械工业出版社@2019)</em>.pdf</li>
<li><strong>计算机系统
系统架构与操作系统的高度集成</strong>.<em>(9787111506362#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机系统概论</strong>.[原书第2版].<em>(9787111215561#机械工业出版社@2007)</em>.pdf</li>
<li><strong>计算机系统结构</strong>.[原书第2版].<em>(9787111223566#机械工业出版社@2008)</em>.pdf</li>
<li><strong>计算机信息处理</strong>.<em>(9787111075875#机械工业出版社@1999)</em>.pdf</li>
<li><strong>计算机硬件及组成原理</strong>.<em>(9787111210184#机械工业出版社@2007)</em>.pdf</li>
<li><strong>计算机组成
结构化方法</strong>.[原书第6版].<em>(9787111453802#机械工业出版社@2014)</em>.pdf</li>
<li><strong>计算机组成</strong>.[原书第5版].<em>(9787111142621#机械工业出版社@2004)</em>.pdf</li>
<li><strong>计算机组成及汇编语言原理</strong>.<em>(9787111277859#机械工业出版社@2009)</em>.pdf</li>
<li><strong>计算机组成与嵌入式系统</strong>.[原书第6版].<em>(9787111438656#机械工业出版社@2013)</em>.pdf</li>
<li><strong>计算机组成与设计
硬件_软件接口</strong>.[原书第3版].<em>(9787111202141#机械工业出版社@2007)</em>.pdf</li>
<li><strong>计算机组成与设计
硬件_软件接口</strong>.[原书第4版].<em>(9787111353058#机械工业出版社@2011)</em>.pdf</li>
<li><strong>计算机组成与设计
硬件_软件接口</strong>.[原书第5版].<em>(9787111504825#机械工业出版社@2015)</em>.pdf</li>
<li><strong>计算机组成与设计
硬件_软件接口</strong>.[原书第5版][ARM版].<em>(9787111608943#机械工业出版社@2018)</em>.pdf</li>
<li><strong>计算机组成与设计
硬件_软件接口</strong>.[原书第5版][RISC-V版].<em>(9787111652144#机械工业出版社@2020)</em>.pdf</li>
<li><strong>计算机组成与体系结构
性能设计</strong>.[原书第8版].<em>(9787111328780#机械工业出版社@2011)</em>.pdf</li>
<li><strong>计算机组成与体系结构</strong>.<em>(9787111190486#机械工业出版社@2006)</em>.pdf</li>
<li><strong>计算机组成与体系结构</strong>.[原书第4版].<em>(9787111616368#机械工业出版社@2019)</em>.pdf</li>
<li><strong>计算机组成原理</strong>.<em>(9787111558071#机械工业出版社@2017)</em>.pdf</li>
<li><strong>计算理论导引</strong>.[第2版].<em>(9787111190288#机械工业出版社@2006)</em>.pdf</li>
<li><strong>计算理论导引</strong>.[原书第3版].<em>(9787111499718#机械工业出版社@2015)</em>.pdf</li>
<li><strong>交互设计
超越人机交互</strong>.[原书第4版].<em>(9787111589273#机械工业出版社@2018)</em>.pdf</li>
<li><strong>交互式系统设计
HCI、UX和交互设计指南</strong>.[原书第3版].<em>(9787111522980#机械工业出版社@2016)</em>.pdf</li>
<li><strong>结构化并行程序设计
高效计算模式</strong>.<em>(9787111600640#机械工业出版社@2018)</em>.pdf</li>
<li><strong>经验软件工程
软件工程中的实验研究方法</strong>.<em>(9787111518563#机械工业出版社@2015)</em>.pdf</li>
<li><strong>可编程逻辑控制器</strong>.<em>(9787111184270#机械工业出版社@2006)</em>.pdf</li>
<li><strong>可变目标C编译器
设计与实现</strong>.<em>(9787111552581#机械工业出版社@2016)</em>.pdf</li>
<li><strong>可穿戴计算
基于人体传感器网络的可穿戴系统建模与实现</strong>.<em>(9787111622741#机械工业出版社@2019)</em>.pdf</li>
<li><strong>可定制计算</strong>.<em>(9787111600947#机械工业出版社@2018)</em>.pdf</li>
<li><strong>可用性工程</strong>.<em>(9787111147923#机械工业出版社@2004)</em>.pdf</li>
<li><strong>垃圾回收算法手册
自动内存管理的艺术</strong>.<em>(9787111528821#机械工业出版社@2016)</em>.pdf</li>
<li><strong>离散数学</strong>.[原书第5版].<em>(9787111212638#机械工业出版社@2007)</em>.pdf</li>
<li><strong>离散数学导学</strong>.<em>(9787111153962#机械工业出版社@2004)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第4版].<em>(9787111075776#机械工业出版社@2002)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第5版].<em>(9787111203261#机械工业出版社@2007)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第6版].<em>(9787111350392#机械工业出版社@2011)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第6版][本科教学版].<em>(9787111359500#机械工业出版社@2011)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第7版].<em>(9787111453826#机械工业出版社@2015)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第7版][本科教学版].<em>(9787111555391#机械工业出版社@2017)</em>.pdf</li>
<li><strong>离散数学及其应用</strong>.[原书第8版].<em>(9787111636878#机械工业出版社@2019)</em>.pdf</li>
<li><strong>量子编程基础</strong>.<em>(9787111631293#机械工业出版社@2019)</em>.pdf</li>
<li><strong>量子信息论</strong>.<em>(9787111661238#机械工业出版社@2020)</em>.pdf</li>
<li><strong>逻辑与计算机设计基础</strong>.[原书第4版].<em>(9787111373117#机械工业出版社@2012)</em>.pdf</li>
<li><strong>逻辑与计算机设计基础</strong>.[原书第5版].<em>(9787111570103#机械工业出版社@2017)</em>.pdf</li>
<li><strong>密码工程
原理与应用</strong>.<em>(9787111574354#机械工业出版社@2017)</em>.pdf</li>
<li><strong>密码学
C_C++语言实现</strong>.[原书第2版].<em>(9787111517337#机械工业出版社@2015)</em>.pdf</li>
<li><strong>密码学导引</strong>.<em>(9787111124788#机械工业出版社@2003)</em>.pdf</li>
<li><strong>密码学基础教程
秘密与承诺</strong>.<em>(9787111544364#机械工业出版社@2016)</em>.pdf</li>
<li><strong>面向对象程序设计
C++语言描述</strong>.[原书第2版].<em>(9787111345763#机械工业出版社@2011)</em>.pdf</li>
<li><strong>面向对象程序设计
图形应用实例</strong>.<em>(9787111101437#机械工业出版社@2002)</em>.pdf</li>
<li><strong>面向对象程序设计教程
Java版</strong>.[原书第4版].<em>(9787111213161#机械工业出版社@2007)</em>.pdf</li>
<li><strong>面向对象软件工程</strong>.<em>(9787111255024#机械工业出版社@2009)</em>.pdf</li>
<li><strong>面向对象与传统软件工程
统一过程的理论和实践</strong>.[原书第6版].<em>(9787111179634#机械工业出版社@2006)</em>.pdf</li>
<li><strong>面向对象与传统软件工程</strong>.[原书第5版].<em>(9787111124771#机械工业出版社@2003)</em>.pdf</li>
<li><strong>面向计算机科学的数理逻辑
系统建模与推理</strong>.[原书第2版].<em>(9787111213970#机械工业出版社@2007)</em>.pdf</li>
<li><strong>模式分类</strong>.[原书第2版].<em>(9787111121480#机械工业出版社@2003)</em>.pdf</li>
<li><strong>模式分析的核方法</strong>.<em>(9787111178538#机械工业出版社@2006)</em>.pdf</li>
<li><strong>脑机接口导论</strong>.<em>(9787111539957#机械工业出版社@2016)</em>.pdf</li>
<li><strong>片上多处理器体系结构
改善吞吐率和延迟的技术</strong>.<em>(9787111253815#机械工业出版社@2008)</em>.pdf</li>
<li><strong>普适计算及其商务应用</strong>.<em>(9787111375753#机械工业出版社@2012)</em>.pdf</li>
<li><strong>嵌入式C编程
PIC单片机和C编程技术与应用</strong>.<em>(9787111564447#机械工业出版社@2017)</em>.pdf</li>
<li><strong>嵌入式多核系统软件开发
嵌入式Intel体系结构实用指南</strong>.<em>(9787111291060#机械工业出版社@2010)</em>.pdf</li>
<li><strong>嵌入式计算系统设计原理</strong>.[第2版].<em>(9787111270683#机械工业出版社@2009)</em>.pdf</li>
<li><strong>嵌入式计算系统设计原理</strong>.[原书第3版].<em>(9787111440758#机械工业出版社@2014)</em>.pdf</li>
<li><strong>嵌入式计算系统设计原理</strong>.[原书第4版].<em>(9787111601487#机械工业出版社@2018)</em>.pdf</li>
<li><strong>嵌入式软件设计基础 基于ARM
Cortex-M3</strong>.[原书第2版].<em>(9787111441762#机械工业出版社@2013)</em>.pdf</li>
<li><strong>嵌入式微控制器与处理器设计</strong>.<em>(9787111322818#机械工业出版社@2011)</em>.pdf</li>
<li><strong>嵌入式系统
硬件、软件及软硬件协同</strong>.[原书第2版].<em>(9787111588870#机械工业出版社@2018)</em>.pdf</li>
<li><strong>嵌入式系统导论
CPS方法</strong>.<em>(9787111360216#机械工业出版社@2011)</em>.pdf</li>
<li><strong>嵌入式系统导论
CPS方法</strong>.[原书第2版].<em>(9787111608110#机械工业出版社@2018)</em>.pdf</li>
<li><strong>嵌入式系统的描述与设计</strong>.<em>(9787111164227#机械工业出版社@2005)</em>.pdf</li>
<li><strong>嵌入式系统软件教程</strong>.<em>(9787111169376#机械工业出版社@2005)</em>.pdf</li>
<li><strong>嵌入式与实时系统开发
使用UML、对象技术、框架与模式</strong>.<em>(9787111155928#机械工业出版社@2005)</em>.pdf</li>
<li><strong>人工智能
复杂问题求解的结构和策略</strong>.[原书第4版].<em>(9787111129448#机械工业出版社@2004)</em>.pdf</li>
<li><strong>人工智能
复杂问题求解的结构和策略</strong>.[原书第6版].<em>(9787111283454#机械工业出版社@2010)</em>.pdf</li>
<li><strong>人工智能
计算Agent基础</strong>.<em>(9787111484578#机械工业出版社@2014)</em>.pdf</li>
<li><strong>人工智能
智能系统指南</strong>.[原书第2版].<em>(9787111202127#机械工业出版社@2007)</em>.pdf</li>
<li><strong>人工智能
智能系统指南</strong>.[原书第3版].<em>(9787111384557#机械工业出版社@2012)</em>.pdf</li>
<li><strong>认知计算与深度学习
基于物联网云平台的智能应用</strong>.<em>(9787111584964#机械工业出版社@2017)</em>.pdf</li>
<li><strong>认知无线电基础</strong>.<em>(9787111617211#机械工业出版社@2019)</em>.pdf</li>
<li><strong>软_硬件协同设计</strong>.[原书第2版].<em>(9787111520184#机械工业出版社@2016)</em>.pdf</li>
<li><strong>软件安全
从源头开始</strong>.<em>(9787111540236#机械工业出版社@2016)</em>.pdf</li>
<li><strong>软件测试
一个软件工艺师的方法</strong>.[原书第4版].<em>(9787111581314#机械工业出版社@2017)</em>.pdf</li>
<li><strong>软件测试
原理与实践</strong>.<em>(9787111255062#机械工业出版社@2009)</em>.pdf</li>
<li><strong>软件测试</strong>.[原书第2版].<em>(9787111185260#机械工业出版社@2006)</em>.pdf</li>
<li><strong>软件测试</strong>.[原书第2版].<em>(9787111617990#机械工业出版社@2019)</em>.pdf</li>
<li><strong>软件测试基础</strong>.<em>(9787111293989#机械工业出版社@2010)</em>.pdf</li>
<li><strong>软件测试基础</strong>.[原书第2版].<em>(9787111611295#机械工业出版社@2018)</em>.pdf</li>
<li><strong>软件测试基础教程</strong>.<em>(9787111351887#机械工业出版社@2011)</em>.pdf</li>
<li><strong>软件工程
Java语言实现</strong>.<em>(9787111073550#机械工业出版社@1999)</em>.pdf</li>
<li><strong>软件工程
架构驱动的软件开发</strong>.<em>(9787111533146#机械工业出版社@2016)</em>.pdf</li>
<li><strong>软件工程
面向对象和传统的方法</strong>.[原书第7版].<em>(9787111217220#机械工业出版社@2007)</em>.pdf</li>
<li><strong>软件工程
面向对象和传统的方法</strong>.[原书第8版].<em>(9787111362739#机械工业出版社@2011)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.<em>(9787111072829#机械工业出版社@1999)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.[原书第6版][本科教学版].<em>(9787111234432#机械工业出版社@2008)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.[原书第7版].<em>(9787111335818#机械工业出版社@2011)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.[原书第7版][本科教学版].<em>(9787111353508#机械工业出版社@2011)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.[原书第8版].<em>(9787111548973#机械工业出版社@2016)</em>.pdf</li>
<li><strong>软件工程
实践者的研究方法</strong>.[原书第8版][本科教学版].<em>(9787111555018#机械工业出版社@2016)</em>.pdf</li>
<li><strong>软件工程</strong>.[原书第8版].<em>(9787111204596#机械工业出版社@2007)</em>.pdf</li>
<li><strong>软件工程</strong>.[原书第9版].<em>(9787111334989#机械工业出版社@2011)</em>.pdf</li>
<li><strong>软件工程</strong>.[原书第10版].<em>(9787111589105#机械工业出版社@2018)</em>.pdf</li>
<li><strong>软件工程导论</strong>.[原书第4版].<em>(9787111607236#机械工业出版社@2018)</em>.pdf</li>
<li><strong>软件架构建模和仿真
Palladio方法</strong>.<em>(9787111607229#机械工业出版社@2018)</em>.pdf</li>
<li><strong>软件建模与设计
UML、用例、模式和软件体系结构</strong>.<em>(9787111467595#机械工业出版社@2014)</em>.pdf</li>
<li><strong>软件可靠性方法</strong>.<em>(9787111365532#机械工业出版社@2012)</em>.pdf</li>
<li><strong>软件项目管理</strong>.[原书第4版].<em>(9787111204589#机械工业出版社@2007)</em>.pdf</li>
<li><strong>软件项目管理</strong>.[原书第5版].<em>(9787111309642#机械工业出版社@2010)</em>.pdf</li>
<li><strong>商务智能
管理视角</strong>.[原书第2版].<em>(9787111367277#机械工业出版社@2012)</em>.pdf</li>
<li><strong>设计模式
可复用面向对象软件的基础</strong>.<em>(9787111075752#机械工业出版社@2000)</em>.pdf</li>
<li><strong>设计模式
可复用面向对象软件的基础</strong>.[典藏版].<em>(9787111618331#机械工业出版社@2019)</em>.pdf</li>
<li><strong>设计有效的数据库系统</strong>.<em>(9787111187363#机械工业出版社@2006)</em>.pdf</li>
<li><strong>设计原本 计算机科学巨匠Frederick
P.Brooks的思考</strong>.<em>(9787111325574#机械工业出版社@2010)</em>.pdf</li>
<li><strong>社会计算
社区发现和社会媒体挖掘</strong>.<em>(9787111402879#机械工业出版社@2012)</em>.pdf</li>
<li><strong>深入理解UNIX系统内核</strong>.<em>(9787111491453#机械工业出版社@2015)</em>.pdf</li>
<li><strong>深入理解复杂网络
网络和信号处理视角</strong>.<em>(9787111637257#机械工业出版社@2019)</em>.pdf</li>
<li><strong>深入理解机器学习
从原理到算法</strong>.<em>(9787111543022#机械工业出版社@2016)</em>.pdf</li>
<li><strong>深入理解计算机系统</strong>.[原书第2版].<em>(9787111321330#机械工业出版社@2010)</em>.pdf</li>
<li><strong>深入理解计算机系统</strong>.[原书第3版].<em>(9787111544937#机械工业出版社@2016)</em>.pdf</li>
<li><strong>深入理解云计算
基本原理和应用程序编程技术</strong>.<em>(9787111496588#机械工业出版社@2015)</em>.pdf</li>
<li><strong>神经计算原理</strong>.<em>(9787111206378#机械工业出版社@2007)</em>.pdf</li>
<li><strong>神经网络设计</strong>.<em>(9787111075851#机械工业出版社@2002)</em>.pdf</li>
<li><strong>神经网络与机器学习</strong>.[原书第3版].<em>(9787111324133#机械工业出版社@2011)</em>.pdf</li>
<li><strong>神经网络原理</strong>.[原书第2版].<em>(9787111127598#机械工业出版社@2004)</em>.pdf</li>
<li><strong>实时嵌入式系统软件设计</strong>.<em>(9787111615309#机械工业出版社@2019)</em>.pdf</li>
<li><strong>实时系统与编程语言</strong>.[原书第3版].<em>(9787111139874#机械工业出版社@2004)</em>.pdf</li>
<li><strong>实用IT项目管理</strong>.[原书第3版].<em>(9787111340799#机械工业出版社@2011)</em>.pdf</li>
<li><strong>实用软件工程</strong>.<em>(9787111200086#机械工业出版社@2006)</em>.pdf</li>
<li><strong>事务处理
概念与技术</strong>.<em>(9787111126416#机械工业出版社@2004)</em>.pdf</li>
<li><strong>视觉计算基础
计算机视觉、图形学和图像处理的核心概念</strong>.<em>(9787111622864#机械工业出版社@2019)</em>.pdf</li>
<li><strong>数据仓库</strong>.[原书第4版].<em>(9787111191940#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据集成原理</strong>.<em>(9787111471660#机械工业出版社@2014)</em>.pdf</li>
<li><strong>数据结构
C语言版</strong>.<em>(9787111187981#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据结构
Java语言描述</strong>.[原书第3版].<em>(9787111215530#机械工业出版社@2007)</em>.pdf</li>
<li><strong>数据结构 从应用到实现
Java版</strong>.<em>(9787111231141#机械工业出版社@2008)</em>.pdf</li>
<li><strong>数据结构、算法与应用
C++语言描述</strong>.[原书第2版].<em>(9787111496007#机械工业出版社@2015)</em>.pdf</li>
<li><strong>数据结构与STL</strong>.<em>(9787111139621#机械工业出版社@2004)</em>.pdf</li>
<li><strong>数据结构与抽象
Java语言描述</strong>.[原书第4版].<em>(9787111567288#机械工业出版社@2017)</em>.pdf</li>
<li><strong>数据结构与抽象
Java语言描述</strong>.[原书第5版].<em>(9787111636373#机械工业出版社@2019)</em>.pdf</li>
<li><strong>数据结构与算法
Python语言实现</strong>.<em>(9787111606604#机械工业出版社@2018)</em>.pdf</li>
<li><strong>数据结构与算法分析
C语言描述</strong>.[原书第2版].<em>(9787111127482#机械工业出版社@2004)</em>.pdf</li>
<li><strong>数据结构与算法分析
C语言描述</strong>.[原书第2版][典藏版].<em>(9787111621959#机械工业出版社@2019)</em>.pdf</li>
<li><strong>数据结构与算法分析
Java语言描述</strong>.[第2版].<em>(9787111231837#机械工业出版社@2009)</em>.pdf</li>
<li><strong>数据结构与算法分析
Java语言描述</strong>.[原书第3版].<em>(9787111528395#机械工业出版社@2016)</em>.pdf</li>
<li><strong>数据库管理基础教程</strong>.<em>(9787111526230#机械工业出版社@2016)</em>.pdf</li>
<li><strong>数据库管理系统</strong>.[原书第3版].<em>(9787111192961#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据库管理系统基础</strong>.<em>(9787111073123#机械工业出版社@1999)</em>.pdf</li>
<li><strong>数据库设计教程</strong>.[第2版].<em>(9787111154716#机械工业出版社@2004)</em>.pdf</li>
<li><strong>数据库系统
概念、设计及应用</strong>.<em>(9787111279587#机械工业出版社@2009)</em>.pdf</li>
<li><strong>数据库系统 设计、实现与管理
基础篇</strong>.[原书第6版].<em>(9787111537403#机械工业出版社@2016)</em>.pdf</li>
<li><strong>数据库系统 设计、实现与管理
进阶篇</strong>.[原书第6版].<em>(9787111583882#机械工业出版社@2017)</em>.pdf</li>
<li><strong>数据库系统
数据库与数据仓库导论</strong>.<em>(9787111486985#机械工业出版社@2015)</em>.pdf</li>
<li><strong>数据库系统导论</strong>.[原书第8版].<em>(9787111213338#机械工业出版社@2007)</em>.pdf</li>
<li><strong>数据库系统概念</strong>.[原书第4版].<em>(9787111116257#机械工业出版社@2003)</em>.pdf</li>
<li><strong>数据库系统概念</strong>.[原书第5版].<em>(9787111196877#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据库系统概念</strong>.[原书第5版][本科教学版].<em>(9787111234227#机械工业出版社@2008)</em>.pdf</li>
<li><strong>数据库系统概念</strong>.[原书第6版].<em>(9787111375296#机械工业出版社@2012)</em>.pdf</li>
<li><strong>数据库系统概念</strong>.[原书第6版][本科教学版].<em>(9787111400851#机械工业出版社@2012)</em>.pdf</li>
<li><strong>数据库系统基础教程</strong>.[原书第3版].<em>(9787111268284#机械工业出版社@2009)</em>.pdf</li>
<li><strong>数据库系统全书</strong>.<em>(9787111125419#机械工业出版社@2003)</em>.pdf</li>
<li><strong>数据库系统实现</strong>.[第2版].<em>(9787111302872#机械工业出版社@2010)</em>.pdf</li>
<li><strong>数据库与事务处理</strong>.<em>(9787111157182#机械工业出版社@2005)</em>.pdf</li>
<li><strong>数据库原理、编程与性能</strong>.[原书第2版].<em>(9787111093107#机械工业出版社@2002)</em>.pdf</li>
<li><strong>数据通信
基础设施、联网和安全</strong>.[原书第7版].<em>(9787111453796#机械工业出版社@2015)</em>.pdf</li>
<li><strong>数据通信、计算机网络与开放系统</strong>.[原书第4版].<em>(9787111122128#机械工业出版社@2004)</em>.pdf</li>
<li><strong>数据通信与网络</strong>.[原书第4版].<em>(9787111213543#机械工业出版社@2007)</em>.pdf</li>
<li><strong>数据通信与网络教程</strong>.[原书第3版].<em>(9787111155386#机械工业出版社@2005)</em>.pdf</li>
<li><strong>数据挖掘
概念与技术</strong>.[原书第2版].<em>(9787111205388#机械工业出版社@2007)</em>.pdf</li>
<li><strong>数据挖掘
概念与技术</strong>.[原书第3版].<em>(9787111391401#机械工业出版社@2012)</em>.pdf</li>
<li><strong>数据挖掘
实用机器学习工具与技术</strong>.[原书第3版].<em>(9787111453819#机械工业出版社@2014)</em>.pdf</li>
<li><strong>数据挖掘
实用机器学习技术</strong>.[原书第2版].<em>(9787111182054#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据挖掘导论</strong>.[原书第2版].<em>(9787111631620#机械工业出版社@2019)</em>.pdf</li>
<li><strong>数据挖掘基础教程</strong>.<em>(9787111255437#机械工业出版社@2008)</em>.pdf</li>
<li><strong>数据挖掘技术
市场营销、销售与客户关系管理领域应用</strong>.[原书第2版].<em>(9787111190561#机械工业出版社@2006)</em>.pdf</li>
<li><strong>数据挖掘与R语言</strong>.<em>(9787111407003#机械工业出版社@2013)</em>.pdf</li>
<li><strong>数据挖掘原理</strong>.<em>(9787111115779#机械工业出版社@2003)</em>.pdf</li>
<li><strong>数值方法和MATLAB
实现与应用</strong>.<em>(9787111146186#机械工业出版社@2004)</em>.pdf</li>
<li><strong>数字逻辑设计与计算机组成</strong>.<em>(9787111570615#机械工业出版社@2017)</em>.pdf</li>
<li><strong>数字媒体技术教程</strong>.<em>(9787111481157#机械工业出版社@2014)</em>.pdf</li>
<li><strong>数字设计
系统方法</strong>.<em>(9787111579403#机械工业出版社@2017)</em>.pdf</li>
<li><strong>数字设计和计算机体系结构</strong>.<em>(9787111254591#机械工业出版社@2009)</em>.pdf</li>
<li><strong>数字设计和计算机体系结构</strong>.[原书第2版].<em>(9787111534518#机械工业出版社@2016)</em>.pdf</li>
<li><strong>数字设计和计算机体系结构</strong>.[原书第2版][ARM版].<em>(9787111629252#机械工业出版社@2019)</em>.pdf</li>
<li><strong>数字图像处理
疑难解析</strong>.<em>(9787111155447#机械工业出版社@2005)</em>.pdf</li>
<li><strong>斯坦福算法博弈论二十讲</strong>.<em>(9787111643067#机械工业出版社@2020)</em>.pdf</li>
<li><strong>搜索引擎
信息检索实践</strong>.<em>(9787111288084#机械工业出版社@2010)</em>.pdf</li>
<li><strong>算法 C语言实现 第1～4部分
基础知识、数据结构、排序及搜索</strong>.[原书第3版].<em>(9787111275718#机械工业出版社@2009)</em>.pdf</li>
<li><strong>算法 C语言实现 第5部分
图算法</strong>.[原书第3版].<em>(9787111285052#机械工业出版社@2010)</em>.pdf</li>
<li><strong>算法导论</strong>.[原书第2版].<em>(9787111187776#机械工业出版社@2006)</em>.pdf</li>
<li><strong>算法导论</strong>.[原书第3版].<em>(9787111407010#机械工业出版社@2012)</em>.pdf</li>
<li><strong>算法分析导论</strong>.<em>(9787111164418#机械工业出版社@2005)</em>.pdf</li>
<li><strong>算法基础
打开算法之门</strong>.<em>(9787111520764#机械工业出版社@2015)</em>.pdf</li>
<li><strong>算法基础</strong>.<em>(9787111560920#机械工业出版社@2017)</em>.pdf</li>
<li><strong>算法设计与分析导论</strong>.<em>(9787111225041#机械工业出版社@2007)</em>.pdf</li>
<li><strong>算法设计与应用</strong>.<em>(9787111582779#机械工业出版社@2017)</em>.pdf</li>
<li><strong>统计推荐系统</strong>.<em>(9787111635734#机械工业出版社@2019)</em>.pdf</li>
<li><strong>推荐系统
技术、评估及高效算法</strong>.<em>(9787111503934#机械工业出版社@2015)</em>.pdf</li>
<li><strong>推荐系统
技术、评估及高效算法</strong>.[原书第2版].<em>(9787111600756#机械工业出版社@2018)</em>.pdf</li>
<li><strong>推荐系统
原理与实践</strong>.<em>(9787111600329#机械工业出版社@2018)</em>.pdf</li>
<li><strong>网络</strong>.[原书第2版].<em>(9787111150176#机械工业出版社@2004)</em>.pdf</li>
<li><strong>网络科学
原理与应用</strong>.<em>(9787111359661#机械工业出版社@2011)</em>.pdf</li>
<li><strong>微机接口技术实验教程</strong>.<em>(9787111177760#机械工业出版社@2006)</em>.pdf</li>
<li><strong>微控制器
架构、编程、接口和系统设计</strong>.<em>(9787111270300#机械工业出版社@2009)</em>.pdf</li>
<li><strong>伟大的计算原理</strong>.<em>(9787111567264#机械工业出版社@2017)</em>.pdf</li>
<li><strong>无处不在的算法</strong>.<em>(9787111608691#机械工业出版社@2018)</em>.pdf</li>
<li><strong>无线传感器网络
原理与实践</strong>.<em>(9787111406990#机械工业出版社@2015)</em>.pdf</li>
<li><strong>无线传感器网络原理</strong>.<em>(9787111580003#机械工业出版社@2017)</em>.pdf</li>
<li><strong>无线通信网络与系统</strong>.<em>(9787111581185#机械工业出版社@2017)</em>.pdf</li>
<li><strong>无线网络
理解和应对互联网环境下网络互连所带来的挑战</strong>.<em>(9787111558484#机械工业出版社@2017)</em>.pdf</li>
<li><strong>雾计算与边缘计算
原理及范式</strong>.<em>(9787111644101#机械工业出版社@2020)</em>.pdf</li>
<li><strong>系统编程
分布式应用的设计与开发</strong>.<em>(9787111582564#机械工业出版社@2017)</em>.pdf</li>
<li><strong>系统分析与设计
敏捷迭代方法</strong>.[原书第6版].<em>(9787111556411#机械工业出版社@2017)</em>.pdf</li>
<li><strong>系统分析与设计</strong>.[原书第4版].<em>(9787111258285#机械工业出版社@2009)</em>.pdf</li>
<li><strong>系统分析与设计</strong>.[原书第7版].<em>(9787111288237#机械工业出版社@2010)</em>.pdf</li>
<li><strong>系统分析与设计</strong>.[原书第9版].<em>(9787111479505#机械工业出版社@2014)</em>.pdf</li>
<li><strong>系统分析与设计导论</strong>.<em>(9787111363866#机械工业出版社@2012)</em>.pdf</li>
<li><strong>系统分析与设计方法</strong>.[原书第5版].<em>(9787111122036#机械工业出版社@2003)</em>.pdf</li>
<li><strong>系统分析与设计方法</strong>.[原书第7版].<em>(9787111205517#机械工业出版社@2007)</em>.pdf</li>
<li><strong>系统分析与设计教程</strong>.[原书第7版].<em>(9787111276777#机械工业出版社@2009)</em>.pdf</li>
<li><strong>现代C++程序设计</strong>.[原书第2版].<em>(9787111242123#机械工业出版社@2008)</em>.pdf</li>
<li><strong>现代x86汇编语言程序设计</strong>.<em>(9787111542780#机械工业出版社@2016)</em>.pdf</li>
<li><strong>现代操作系统</strong>.<em>(9787111071174#机械工业出版社@1999)</em>.pdf</li>
<li><strong>现代操作系统</strong>.[原书第3版].<em>(9787111255444#机械工业出版社@2009)</em>.pdf</li>
<li><strong>现代操作系统</strong>.[原书第4版].<em>(9787111573692#机械工业出版社@2017)</em>.pdf</li>
<li><strong>现代计算机系统与网络</strong>.[原书第5版].<em>(9787111611400#机械工业出版社@2018)</em>.pdf</li>
<li><strong>现代密码学及其应用</strong>.<em>(9787111594635#机械工业出版社@2018)</em>.pdf</li>
<li><strong>现代数据库管理</strong>.[原书第6版].<em>(9787111145172#机械工业出版社@2004)</em>.pdf</li>
<li><strong>现代体系结构的优化编译器</strong>.<em>(9787111141228#机械工业出版社@2004)</em>.pdf</li>
<li><strong>现代网络技术
SDN、NFV、QoE、物联网和云计算</strong>.<em>(9787111586647#机械工业出版社@2018)</em>.pdf</li>
<li><strong>现代信息检索</strong>.[原书第2版].<em>(9787111385998#机械工业出版社@2012)</em>.pdf</li>
<li><strong>信息安全工程</strong>.<em>(9787111095873#机械工业出版社@2003)</em>.pdf</li>
<li><strong>信息检索
实现和评价搜索引擎</strong>.<em>(9787111359906#机械工业出版社@2011)</em>.pdf</li>
<li><strong>信息可视化
交互设计</strong>.[原书第2版].<em>(9787111362463#机械工业出版社@2011)</em>.pdf</li>
<li><strong>信息论、编码与密码学</strong>.[第2版].<em>(9787111308881#机械工业出版社@2010)</em>.pdf</li>
<li><strong>信息论基础</strong>.[原书第2版].<em>(9787111220404#机械工业出版社@2007)</em>.pdf</li>
<li><strong>信息论与编码理论
剑桥大学真题精解</strong>.<em>(9787111553526#机械工业出版社@2017)</em>.pdf</li>
<li><strong>信息物理融合系统（CPS）设计、建模与仿真 基于Ptolemy
II平台</strong>.<em>(9787111558439#机械工业出版社@2017)</em>.pdf</li>
<li><strong>信息物理融合系统（CPS）原理</strong>.<em>(9787111559047#机械工业出版社@2017)</em>.pdf</li>
<li><strong>信息物理系统
应用与原理</strong>.<em>(9787111598107#机械工业出版社@2018)</em>.pdf</li>
<li><strong>信息物理系统计算基础
概念、设计方法和应用</strong>.<em>(9787111591450#机械工业出版社@2018)</em>.pdf</li>
<li><strong>信息系统原理</strong>.[原书第6版].<em>(9787111158790#机械工业出版社@2005)</em>.pdf</li>
<li><strong>形式语言与自动机导论</strong>.[原书第3版].<em>(9787111167884#机械工业出版社@2005)</em>.pdf</li>
<li><strong>虚拟机
系统与进程的通用平台</strong>.<em>(9787111256687#机械工业出版社@2009)</em>.pdf</li>
<li><strong>需求分析与系统设计</strong>.[原书第3版].<em>(9787111272809#机械工业出版社@2009)</em>.pdf</li>
<li><strong>需求工程
基础、原理和技术</strong>.<em>(9787111382317#机械工业出版社@2012)</em>.pdf</li>
<li><strong>需求工程
实践者之路</strong>.[原书第4版].<em>(9787111439868#机械工业出版社@2013)</em>.pdf</li>
<li><strong>需求设计
构建用户想要和需要的产品</strong>.<em>(9787111564720#机械工业出版社@2017)</em>.pdf</li>
<li><strong>遥感数字影像处理导论</strong>.[原书第3版].<em>(9787111193777#机械工业出版社@2007)</em>.pdf</li>
<li><strong>遥感数字影像处理导论</strong>.[原书第4版].<em>(9787111592174#机械工业出版社@2018)</em>.pdf</li>
<li><strong>以用户为中心的系统设计</strong>.<em>(9787111579397#机械工业出版社@2017)</em>.pdf</li>
<li><strong>异构系统体系结构
原理、模型及应用</strong>.<em>(9787111606697#机械工业出版社@2018)</em>.pdf</li>
<li><strong>应用逻辑</strong>.[原书第2版].<em>(9787111214045#机械工业出版社@2007)</em>.pdf</li>
<li><strong>应用密码学
协议、算法与C源程序</strong>.[原书第2版].<em>(9787111445333#机械工业出版社@2013)</em>.pdf</li>
<li><strong>永恒的图灵
20位科学家对图灵思想的解构与超越</strong>.<em>(9787111596417#机械工业出版社@2018)</em>.pdf</li>
<li><strong>语言与机器
计算机科学理论导论</strong>.[原书第3版].<em>(9787111226345#机械工业出版社@2008)</em>.pdf</li>
<li><strong>语义网基础教程</strong>.<em>(9787111237341#机械工业出版社@2008)</em>.pdf</li>
<li><strong>语义网基础教程</strong>.[原书第3版].<em>(9787111475446#机械工业出版社@2014)</em>.pdf</li>
<li><strong>云计算
概念、技术与架构</strong>.<em>(9787111461340#机械工业出版社@2014)</em>.pdf</li>
<li><strong>云计算
科学与工程实践指南</strong>.<em>(9787111606727#机械工业出版社@2018)</em>.pdf</li>
<li><strong>云计算设计模式</strong>.<em>(9787111533832#机械工业出版社@2016)</em>.pdf</li>
<li><strong>云计算系统与人工智能应用</strong>.<em>(9787111598831#机械工业出版社@2018)</em>.pdf</li>
<li><strong>云计算与分布式系统
从并行处理到物联网</strong>.<em>(9787111410652#机械工业出版社@2013)</em>.pdf</li>
<li><strong>增强现实
原理与实践</strong>.<em>(9787111643036#机械工业出版社@2020)</em>.pdf</li>
<li><strong>真实世界的算法
初学者指南</strong>.<em>(9787111657453#机械工业出版社@2020)</em>.pdf</li>
<li><strong>专家系统
原理与编程</strong>.[原书第4版].<em>(9787111192039#机械工业出版社@2006)</em>.pdf</li>
<li><strong>自动机理论、语言和计算导论</strong>.[原书第3版].<em>(9787111240358#机械工业出版社@2008)</em>.pdf</li>
<li><strong>自动网络管理系统</strong>.<em>(9787111253938#机械工业出版社@2009)</em>.pdf</li>
<li><strong>组合数学</strong>.[原书第4版].<em>(9787111153603#机械工业出版社@2005)</em>.pdf</li>
<li><strong>组合数学</strong>.[原书第5版].<em>(9787111377870#机械工业出版社@2012)</em>.pdf</li>
<li><strong>最新网络技术基础</strong>.<em>(9787111073529#机械工业出版社@1999)</em>.pdf</li>
</ul>
]]></content>
      <categories>
        <category>资源收集</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>//posts/1252164851.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b2120c56bd0d9e1e2ee12e6ae0221e2e362b32936cebe61f9ee2a936d140a704">4ddc16f5a2dfffa938af489a2218ca07a5c6eeb9357d0e277f3e803b9f324d9180350596852699e8aff3b4158301ff7cf83e0e52d69a1deb624a6b6f36e3fde909f17ab7d46eeff8767bc6f14a7e9a26f2c805ab300e081e054e444a6c452f2ca60cc09072a91a2ddbbfc4be82ee62baaba123c4ef62678013012f86733c928940431a4f482fc9a627c0ff9c13be929035232f1a7b8e3a0700419e94bfd0f1567902d816bcdc6efdafa88bcf17f7cda2d74412aff1b24f8c833c885c0a61416f56785719ede39cf8c1f13e8e224d1427ee85cde9dd77ab581689338220954f106a325bf2739e4054d6b940f41d9ee92c3c443cc5366169b6cc64ba77d92fa1fb4a65bb75b6e2e3f554fe47ba1176ec01db6fff1a9b180713c7ff6591aa42a3918f9f2f3826b375d468f18f238124cd307620f50db2b5146795bd011dba9bfb349df9dfe83d9dd2e0eed4b21ca57e3e8a85359e0e4d0c69e200b5d0e5ec7639cf7b82f6370f3fe7c6633d0365703ed9ce5c4f4a1df701ce79241d3c2a6c3b9ba4012ebd824375d6c375fac4ebc0b8f7ecd852e27adf8169a409e4f1d9709308bb9dd3762f0bbacf48f010a7a800569f69bf0ab64611cd106a7193a6b460a3bdd24b5b9f2b022d039aa07fce2dd349a66dc9142604ea040f0e112342ef217c302c94cdde2b9295e488e861f7f78f312b96a73b4407b5ee09bfdbb48063564c011a315950700ecf70e758096526b7df32af3b0ca408673a55a408180744673032cb755389471f046998b4a9c1e8520c619d8e5eea8cff96ee01c6135ebbc38d25b1066d56f3bc7ab3dfbf85ce37e0a51002634dd3390d862d81abfb93c763bd5fce261f299ab437a851b684040bd46308647cbf88329f3a0e777ebf493d29fa12545d05d87548cf4f30bc854b8da401e30173a5242b5f35689b4ab4826cc4f715c92eae1e061cc5d069315ef1924f49fd4fda77d0be1ae2ad32a3693a3e9859272c7b5fe36b6aec55dcd2e889bbfb8694576def357e1432e8891507aa3ca78e6e5f23d2a3b2e22f9c6e58f300455e67195a21d2fe870d5cefe5aaca5e889fd2eeed6ecb764b2f5104949aac379adf275e8d567a7bd412c293f802be69edd4af8175efe94d037e70b8a8bd715c1e95134b8618cef0b622679dbaa6bcd09833dade40bb52c8a336f104a7fc0ac6e67a65b799869192378194fd9d7585744c8b41f877976b9fc032bf4c7f224bb92784dfb772ae27f4330fb1a457a10beb27a12767b1c2d18ef6d65828ac15abf548c9def004439f662381f0b59994a0ed5a8a82107dea90906c66c7f05938c7690bb6027fcfcc77fcb88901677ccc5043ed6fdfa9129c74bb0bbe2560282fe0fc770d8ea9e6ae2b7b95200b4bc450dab6a928d66937017bd1d9c0c6fa9f364ce53410719ef328b4454d3b96ee89d5f6b221dab56972ff30b1110c888801a2a67cddacfd56ca123f46cf247f2601e4ac399f92628fd47fc4999a204a66b28eb260ec7734e76f0ce3c744d7094bc8a6d6dc8432a13cbfb56d54d9141de720586e17681d194bc9f988f51e2eaa59d1844997e8358428d259e7dac3f33b4cca017551934bfb0de9f25ec202ee3ac0fa8965e5795d671b6a89ef7f72b874b9651d9c027a2ac6c825ebee19caebab4940dabd066804a19b5b1427d1e5db4f3cf652079c4cf822b2639452ba710173da5803841e9d11088f011f09a478b26132b968b43d173d5d7f30c0c6b600bec6aaae5763e393ae1bb53d4014b6113c90ca80d8f87864ec778671b665d12ab3d79c2755d774daf788e4ba8addf61c94e6fecf40b097762f7a893315d4fb0a8a8c99e54fa74150b40c66cb516b9da2ff2f709f5c68b3106fa30fe390f7dbcc48c41dc27a506b30c3add97bd854a67469619d33877b247b21e5d3ae2af517be59844821eb847e9aa4b9c7e907f26458be538dc0caf4f905f1f73f56bb7a2d45073cc233a15fce2936154e15b956a2932966161a0da311ef7c68f3b85e70b353cb8c8c7a360f8a7485952cfe86d7285cb632ebbf19f780322f1e72d2e9e145882c0b069b1799ed85c71bb6fbb70b002ebe0a87bb6e3d350714b2d3c54b795d94f82ce2395957582b071fa88f4e4b73761c4be9a90b8f049dba14f1363e9774e336c6d048374be31d26c8ae99ce1293df51758bdc509b42710860129735a665dbf060546080d756bb2db118dcf16653253228fd884124455b0e956e0afbe7bb50e21de777636565067f4f76e5a11bd6f7a5101d8069b6977da91a29155526061f6705a06821f22ebdfc936acae59c2171e8f87af1c9585a0c6fd092f9097c97f0f9ac9c6282060f6e27021c88090bfc661a49bb9e585339fd1c09a6c7740bfdbe5882557623b8172ab264b8608dd955084d1a485c14b44ed504f2dc9a868d8bb8438512ec5e3d1e2c680d810b1390a90d37294fa94899618339356c6e24ad20afd492660d043ab9721e7716269fe5299a5f895b4bd9e11eff73d7249dd6a2dc3b199de2e228451e978b0a41e78cc77fa8fae1f9c243c5d3600b7c1399edd79e7bc97982fba7a3bf9d42732e3f108881c5b3c915d38399a9b8ce57e45d9ab19d958d301ba4101c4dd7070aefcc713f2708018a6da50d17c5a5dfe49e27e09f0940061d873b918b801172fc16cee9e87a8c0c20b2522540bfece2e5b2a00d6a166c898571afcf49448a598a787b543965fc00b270c65fbe5d45a36ce5c6c61f992df5cb13586382d7620bd7e1590f3d581b7deade11842eed89c946ce0fd36c023face9c6bbf2aafeecd421900308b6a0c5c6ce48b1f9767b9426554a28c5bbf16dfe7b72774019e072fb355ff9f53d00ac2b7cb9d96184ae1732bf5e6f8e4f45ac88f542b3db88426ff5f7347db15afe6ad56070173743def9a8a377afdde4912614511e9b6e1a96818a6805b59226f01bbb0fee8cb6b8c217bae10f329be1b3bca9fee82f1367f5c1b193f0bbf76fa4222e900b5fea887bba7fa0f46e707597ad55a9847a28c7082b9fa70a577eb17f064cc98160cc0d50f8c6166ece2820606d32757e5f27ab2aa03486dfa5ea5893d05044b4d1e94264d7f4993dda2aa6e88d2ac66a92050a47818383346013fa77c8be9078060ba127388de2467ce6f44f84cb08db35b56f94f0e44eae86c5b6691776e0460e0428a695ba9357034e3fbc3d0ad8d0721ab68f1884ef6589cd2258c11e3ee8c79cb6d4f4acd6f17348406809b38a6dcc277123b5cc253c37986f7d6a6e2826328d2c961cc6fb4b9e3908374e76e2280ce91cf40e80b86e8840f963aee69caa2cab6076050b29f2edcde1dd6b84441a011546fc42074b32e9bec164d730705f4df3be5adaf23ab802f2651184e6cbe82ebe6b228876c10fcd6cdf7116214134658d292ce109a684a2f39b31c52c5c6c9896655acbb67b447e1981344a76297f456745746c1f8cd890c17864c1113d0c96a0abb3471fc8a647de62fd5e285e65cf1b2df9388d94b1c690f44450d209740abf05d1446157f9ab25524f9a513f6b4a8f28b450378b38adc5eb55ea1b2ba98e4133f2c12127279f8c381b0970d41e45b935c55db59db910a81512df79bd3f4f3a72437f75a72ea36df572f0682240c21c934a5882af7e48f0519961606d84f6e3b30f3a1f3de31f6c8afc8a92011ac76a7e6d080c0c0b292cd1fdc5459a093af54188c0aa2ca5588e503041c1af14a3f21bba18757312bcd7d1ec2c530845a9bc0b6b5c4f7d36212e82e62300b557554e95084784fae0affb4198b3b298f9e703752f2f6bc67b1617f9c142180a346045a3135465bd8ffc62a522fe630c845e78e95bde4b69d828ecf157e4eca3396f839bb83a0549159d4810b668862e672063a266d72cba068ded839c57303c8b52ff403eb7355339e483b02c445ee8ab9bf92719a1d69e349713ab3016c4529018a650ab69efb14b1715eef8cf4389252fea34bc760200731781f49b4f831b5a2c33bc42df887ca85966115d8c549ea2538bec40be2e947d5f71bba48f71e39e1511d7bc43b0aa39aa083d14bf8bde2d6a2dc3a65e2ae348a74d18160be4c754e1837b2d483fed366aabf8762beebdd2ae8516382988392222c12c16997876deb511e7437f475a691f5709da7522c31f8cb429a4199b21f2a631999bc917c2a84798aa759bc0584923341c7ca57e0491a23a4d88bdf5e7a26c2ab18b4ab3518252a52159cc10473a8224c0fa97f7b3c40c34abd3860fcb2193b6efdbb5961ab9ed94f54d14077f29d4f392d7fbe63dcf20422a39514fa34ef7e6aa4c36e86edfc3c7ad853437e314a8c69496a30745af24d0cd30ce08f0d0ddcc3b62594e3f3e5b1665f65075b1ad4c101579ed93992ae1236abd9f9fec532f6844662416a6993ad34ea4bf068b7b5a1d12b7de5165a59f2b5ab1fe164e85746ddbe26d9e8954dfb2aa8951fd309e7347839995b2ca37ce6e3a325440efab9696200a38aaeec7c76ff98be923d6b408e748fe746a42bbd19b3ea7b0b4b607f8ba379b999a44f06d520dc586e30655100db26c339051097930e0d79afafc1e8618a84e19989e4f0c450994c62ecfbb72c35d74bd13044631d2d56843d768b5604d9a5bc385ef79d33fc092bf14d585127f6204b2abfa6250013480e71ca4c37dd7b03f08bcf4ae45fc0d45b041eaed713c85ed210dfa2560df5d32a68a7facc7f534158d9388e153db613f2e2654eaa111e36ba3d7e0ad1e4b18488cfef559790e522562b0cedbb244fe4ff2b04b385f9d154f4d7df4183770b1226949c4688857ffe4cd33276027b93475ffe75fe230c568a052f386bdbafbabffe6da991b8f36ac46942a403d3c7d0de81b449241d75242e5944dc5acba9903e47837c83ae9c42b6f8bfed477ffacf307d44d1c296c9d21325122d1d4a10e685b0e068445a727929126e8aa083dff8a8d6b5a8173a1fb3fabb608076572a68292bfe37a44bd5411c1e48884b48c02b7fbd3c457aeed982290f131d02b06991dab18b498dc4ec85b6aaed7e28a2c8d6a3fa6a1a58a0448b8490b93d2f421ce0ac215dbc27ec2604144b9ddbc7b462045bfb48940f851c5b21913d795e115f8d327d9a7b76aed5de8f16bbd8d362bd54a5a01ee993eb236777376dd0c32952e5579991fbb4a165a8ed8024664ad97334903ce9ec1dca7fe2ab4ea9c138bec1a1096d7c72217971131b58611bc20ce4f85c10f11f20026d8c5455de95cb0871082e5f16055e7fb718ad7b859a2baaa8624cf0930823e8cbfe5474d0516477a8e6bf021e783ef3468e6e303583f9525a4d04e2d792273f9cd85439a5088268381cd3eca6860cc1f91b89bdf0473a3c578e034477c07d2e1ccedc2a3bf4eac476caa67e4c18f62bf9801ac5d2070cc211b4cc75a990eb6e730b165876e48061f4f2915b032adebd33aae1d675f54427673aa6f43651db131c7838f23d224c8bbc517f3157febf779a981abc345456f061c942cff10e1ab16beeacc38fe6004183bfe078a44ebb988e6ea0871a5c2ab893b445219bf25d1505e7711a90edce6417f76154c158fa15e5f41bfcf0c6135a7018d982323b38e330c88a1d1a27cca8e1cf1ee6b790d5b60a0598a510d478501891c57fb361cf0ae647f735da17126faa81b0e35f822130ab8e0d626693d265b02f970c1d1260b224959f10818c8828565fac72ef065552245b4cb33125411f4ede0b581059be52b1c04573d543da4463c277626f2288192c13d9368d095142909ca16d78d7725dbba603fedb21aa72366ef5258c9166252459e9f63adaa071e00f9db11e84fb79e512efff165bbf080946493ed38f6636a35f7c63004c1e255843fccba92ca8770be7c50f3598a7f661ee51ab5c54646e12049b55f50a1b7b3954e897a10b055a1387c792ca34df12770c8221ef9d84d957f6a2c1634e57916e3dcc56e7738db9e659c383532dc6326d225e41d2b68f5a07c5be317c6c4c0211f002deadfb3118f890995bd45cf7bc3c6f87288eee4a985df6dcf63372db884287430f2dc7be892f6ef1dfd4c291638d45ab138da2de1fec6dda6716501861b50e137090527efd36a7ed954ebfde189753250ab55ff14e967fd199ecaae1d9b7b7f1c4462b7ea25e58e875830289c8365dfeb580e451020de26fe0b58a3c3990034f74ee44d25af925d498652b76cb2495b5006eb78a911ab1927287c2c83ecd4d553d97b22b8a3326f744e5ea4d4faa6904a86e1e8bca6b54c0166f76edc0bed54c8801ab49c245ac70f962888ba449739c8755f922beb7d94f20f9ef460a02a45aeae7c16b7777d01e436823475d8046f1d7e1fdc18ef1ec1da06c2a07743001d789938344f583e9dad41a5acf6ba63360b1061d0533daf707b30f3744c83d247aef141222ad279211ff3b2ae43b22775e3167b6b8b222a90e3be47f6aea2468239630384069231f04578e3a343e81d17c8e7f01762ed6c8c233917b603cbab96c109ce9e581dafa5d99c0899dbf7b3a453842d07338b28ea1214f3bf0082458cf645ba509e05c36d25c087db18736aea565bfb9dbf1c9302cf20c01581eeda464b9c3df6f1f84b3a48e427507270f44d6b29511556fa0e7a68ca44f2ae955cf8163464ddc36a14233011b7117ddae0926a0f7b7862648a52cbab72ea6316974659ce37387ad98754cd1c6f73fa60e258c5dc39768344b0c2a1ec5317935c32a797ffc29cf0d7dcaa7d91547cd809677381fdfb762302d4af54a7a4e55ce295411f94bc20702b6bd432d8c12b35b3567cf1eb782623a9941e4e5fa2a4df23bc0cdf80a6e67b386a87748809eb25e165738a956a2de6e9a93c1791d94c95aabc4883d04d9109dfe3e2fd8c052e200cbd6cb97c6741f04e93cb989db528e6e1c443d19236af5c9ca48cfe5a7612f9c8e8e686aea372c685cf8c39dd6b2668ac4125127ba499ac0d5cf7ade1afdf85936c43c9148265bf5da79c4a8aeda1b305520f068260b030ad147856d79d5448801c6bef78aac791bb0fda61ba88f3ccc7cc0dbdc8105b4256039f78aeb95964f1aa8f6cf6d9e0310e549a18a859e6b9b334d753807f3a4db9ac4c320018ceca07f76ec1aee6adb4100761c246d4838a7463defd1234079bc8bb396014d83ddbdc647aa2fc91d123028be99a83ca984b75286202df8eaec1d6f882f5a4da5fdf831a1c784cf0b8ae790491c3faddc3f7d1ea352bf6aefe4dcecbad8700c7697ac5ccac8c6426d766452766274beb133bb94b480666d5932720f2c9aa4b6c1302b7f228b7086f1fee2921a6dd79665f40d118a58c35cb64493d6032901c544bfba78219a596f1d338d77a7ce8cedd4bc3527debd84741edb12a94addab3f83c2102e14f11a50fab751396464560f36de1b3fd453444442dedc6c74a5e073619c535e98d8e0b6f2bd450874d4c9bf588bc6ababf9ef8431dea9f5210a08bf780a950ecf8becc2405111d770eea25161abb6299b147e5bce03fb7169ee649073581c151756af54f264eefd59992d4a61ca4f91f3e55124a51a67593a416a5f07fb2e4dfc5856eac61ea1ffa8a7263ae33832d9d48425639adfcc17d7613f6f3a9a9623128f2f2d2c6ad6f2dc30eb5f017886446811c1c1c6fd6064131d45ef5e1e216cf9821da3b859756acbae12b6c447d41c13c85bad17ecdb7d4a5bb626ef399778c86339652fe1a9e04844d6499b6e4584d28b6eda687f2563f60755336638bf70ceaf9c15d63626d00d09fb44907c62fb91201a13fd284272fd5d7c9992cbb3fe729e76304e336a088f2a66646f1ef293dfc3368f2f1cfdd0b819ecc00fa2ba0da9b12c2ca81f4e43b6ad89aae1c31f087eeef361b50f13ef73e6fff19c009c0465ce452d76e2066902757d9d9f903f504a4fd80a22d77a773a74a234c954f201cbba81f053a59f6247c1f88dd82674c097761032e6725ce028e2b0ad83547d38ea0e035fbc83e6a1e53151fe1b42421a305a2287b8e92b2c6a148eddf428a50aa91f66af62d46e2a76d3dcc800bd0aab986dcd5d94086143a375eeedaac61ce661b86dc73555a0d3a34bdde896f1b518c46ecb56522f62af9c9fb90e4c92312a55f8c03a2393b4b0278629e385783784c766cb0376553edf7d349476832e82849bc8bb189d3aa0add5477a44b3c7e6083da420a93373906df4c2c704ad16e04758e163b1abfe357b6e20ffbbffac5d75491f1e74c37ac0b14977eedf2639929c67f4ca9ea83782dc7823dcf31b22593fd3e7e550f65c8d278f3427efdae4873731274849b0326a3fb0a317d3b952f176a52f7c9eb4eafe654d5725db302038b2548972def107d12452acbba0afbb9dc0d6b33c09a6d6642705fd32f0a5fa010502c9d2e2248285e0c56a411cea975695b72bc910874744e9b409ae106f66a500ac8419b6415304332c5dd5e1c87c0dbb42f43a47b707d0a211d77937e407ae72a4f0a1eb4e52892af544f67297aa45e9affb714b794f24b7c64b13d1cb4a796078d426c49e7df37f5c55510f3fcfe1e4d6e0fe24bf75b719b2b1422e21083be9c7c4aae575307196ad58b483b3a42d00bf1501606201507633045d9dbc2f12f987313f7fbf6a8b8bbcd8995d2bb20cd6929cc45719cba122b62af21a7a21e710a383a01c579eccb44353a7be3da38e1c583c04e45a8e5d2457de422390cf253896b1345b9448871fd014447a977a16e2e35a545d590e9210a29ffc1cd67b6ed730ae169cab350b50d9e3c4c7321d20bdd80ab5facca4d9fadf836a30c87d8f897b93f1c5a28b9a861d16520e15d650a4d27ad259e10ac65d6a63f3c5865b595b7b86b46830e3bd61027a5282a0bb8d383f92f0f77fb7c19b9212f747b698d7c594e96a77f8e205e9c80da8247bd13b54d034799a8258fb527a9d32b2333a9496d46a10e1d90c03ac36b85fd1e7371e0a57a19b889ee83556329e1d0c6f9fef5449fc21b4e642f8aa96792b1642bbb302e61bc1080a1fc516ba6f76a0844851799bbffff07e6539f12db0a4f59baab5115dece3255682f8d55dacf3e43caad431a6ace29d93daf0ce27eb718446c71f0b37c645c4a6e6d34cf5534f3d1567d83ce8b41a0d0cf871c22f0235980807ccdedc68357e026d4df2a6839b9747448cc517608b5711d6090be2dc5ba8f76146e07d493a8c50b36bfa4c8c9ea1e3c1723d91401939a55024cee854c35b377bd39c8fc65701b230603cf78ff05bd844e3fc214fd117eeb3c8cc651089f0efe0b0087c336a45da29c0ac6ff95647cdfd4f6f967d29873cead210aa8d79e62df8d76cd2ee8b29efabd788a2e9490136995786e1660b5d773a70e520e641d98440e8e577e3050b38c9b757371249ccce689a370cc87724d2428cd82c5cd4545e2f3b013d258c8f2e1cf17f5a4db10cedcc8aef08e2ddfa609f2e3df9c4fe5a11fccadd25078c70fdb486fe63bf2205f3c345923fbd143c135e2cf18cab0ec2fd55255a892fc6adebb84ac4a9a14bd7d20ae8af6c87e80733d8f568ed406bcd037096d3c7c0c691df7a4f26c0e52902a653b3a3122dd56f4eb997786a976bccb2e0b8e761998c17d9b1312b70a3fc0e48f20fe2d0726c8ebae94ae05c8965259d8db91e5c73ef870f61b90a4a47bb10599a7ef4ab71b2136667538f065b941f2b2dcbdca6ef34b5ed1c9075c4a543723c9e2f4ea9bc833e53f0128cd0ca6dd0bf91c8013f7aa53494ffc3cd53a66b4434d9675f08a3ab240e71c33095a113ea294c87e3ca50f23a0a20bd3edde9c9259cd06a2cc9f0f593e06bfc0f77907dbc74c2f0286f5f448f8395980973982627dec95ad3fbb844ba65dc5ea72e8554c79e3c1ea8b2a3cbd8d619d81a751a079feecc6ddef50fdac25ebc0a5e3e1e3c737ce4884b2d0d6cf054b9df7b5b637f7ba9a60f515d60f3d131e7d0b6452b5eacbf79f97502055b4e4241a86ca30fb084bb9981a5b2426c597bafaa3db14110e1201857d11c214f77d697e4082aac56bfe5da76d42c9b6b9db64e26cb00124db2056c8cec28a58bbf83cdf4674821e1169dd228df0b42b079cafb8afaa8e5f6fa33498a8b067a8f2e569658ba4043bd501ac7a649dc76a80136a1147bce18e20d5eba086163dbabd8ae8bc5b1bd0a96164026060fc75045e3371ba113799dd0365c3adf80439561aca3ad7da25c2afcffbe364a51d9d7a2dc763c56578ef1161b8af525aa900464522249579d0ad658d7ec9c7080e6e0aa0774662cfe7fc233a0328eb2be71657cfab49a9ad162399c6880d0d245440daaedda466b2a2934a2bc98c88a99a850e9ed1669964d654027302e51847ffc5c3c155a2cebd85b24db931f0fe8b23672734c7faf6aad168c4ac50ce5763ac12d8bbaba93de25082cc3ea3959b02ac2be72f9a1bc770b78d261fbfcc713ad3e48be50941ed97dfdb16ea13453f8d0de78e57e3b74bfcbaeb3bff58983c98fe7581f66a2ec5087bc778e153e98106e53fb5b439b478b0330edebc41554e5cbc30c7d4a896c0c374cd7151dcc6ce52def68b6d8918b7fdf78ebc6d4b6a679551d9a83c6dfb90a82a8e46315881954c813940f3989e55ceb8a6aa4df6e13e1de4d456cba0563c6e09f5149eccfa1beb36c962ff2457a7b72f22cb763af7e00ae07f15fc6c84d4a4e5bb6d12ced7bdb245d1f329a26446443ece9c3b6384877f27fa247139d6b1bd0f7fb9a587cff46a22a4ea3bd688986c3dd1fe1b1d38bc9b4017f3574e617d31a73a932a9a27e863e0e906399f8eb635d62827d27e51e344384c596bc38d28af27f309fb6b2130cf08310a15294afdbc2a20dec160953b811ee99540e08387624b59aa05c82a5a34c456f9466bbed512435597ed458302dae55d75539dd2a6b68ea07c398057733231c63baa31f78ca80e4fa51528a9861e8d43ef2f14f1b032c66569e1f1946d3592755c7c9ab0cf768655c9551bcefc4adc0c2bfd673b7336cedb80d7c1ad3aa11b6b2b7568f1855226444377e993820bb2ac900c0e6e73c0cad4cd91025aa1d3cfc4f2405338f9d1f58a33bff23c4520510405f1c60a052e0181f5153bec455bf59909f8b36b92e548e712d5a0a286fc23de8435424a5530250f9fce7f357345322edf397354cf615b224ca0b85bbe6a56beb5fabf7534630a4e8e9f0ed082c9f4765d111642775c5718fab84c63c331ab4ce1b46a0657e1daf29704d02ddfb6a2779a648c9c9f9eaf24112dee32231b2773a751838c7aee6cb7ac51231854079c7d752441eff7bbe933e22266d25f05da8ec6df859236d4a5bfec71b283d18d50a319062c428935f16fa0a42688fbcd8eafd4b242c3ef1c68473fbff26455c331c27b5823de0bb1aec519fc15b1109dcd59efca5b4f683064b40a815e472271e9dfe54436ca2f3dd4f14517ea2bddf4f7a317875faec1340543acf404d3246f3dbc6750be5a6cf4cf38959c985f451d23ada2b73baa3c8d2d92bbcdfdaccee44716016ad43ba46b6df743e416d2bbf4dc638482468d72370bc289c269e293b653260135032bbdede612adb9ff557540dac1669815be6c3e7c409568318db677452344e48ae1d1fde18d4d92484f787c908f1dec987bc0b048d36f4a32127e9a62936b87acbd6d5ed07d3d45a9f5d16c289dc090a2a6933442903a299e5627862fc64c10e5abbd95120816fe59a5cab42dea150b9b3b92267c01fdd9c917de06e0a49b613db0d438cf42ae60bc36bdd8e1cc0ab39f6cd2f5ece1457fd3de633024d87df026f8000f064e5b5fe629858036491e15bea57d66a25eb15e815f01da369db7875689df8eb54cdb4d3f7a6310458e42c92957cd7554f1dece5f3ea5db9b25934a228476efa58de5377ef320b6a3329b819da78173aa4a612b0bee8e3a858b8c3bbeda8348217ab73dfd58be0c06d2f1084094fc32df185e2215850f947d4ad333ca711680e799e2beb017cfc8b0f6615f3c705794c4761043df468475f86fe733ef9a2bf2a87eda7c387c1d723385b0065e916f3d603dbf85680042a61f4e9eecdd168ecb02179464869b7205426e2e71750c6ff099fc793b3a011bda19ae892efa8d80702e9e3c0ac428f1e17a62c7950a46563411ee96c07d44fc8f4c8c240284613f19ca4b91b63062b49fcb7008d6e98c48b745dcaacb4bb68fd0c30fc3f461aa0175091226211d6d71a09fbb462274a0cea7fe55506f6d11246315010082a8f4e5fd3812773670b20f7906df84730613e796acf6bb4101d767b6615c5ec1e29e7a391beaca5fb6b4f5037daf3f1f9a41eaafac81f86a75affe869b6a233017431eefbc5290d0b7d4d03367d3790cbfc5e3ad6f9ceb33e85d97c9ecb8d75627e806b98a66270bdba09d938ff58afbd8c9e68dff5cef0ffab3a51c22e199ce3230f8be4b59ef0a9acff225408d3e4216d9d3aa3283ecc938dc8ee175ecf1a0a4d615980e2b26f68e0668b8f8339c13c89bf7c8dcf1b6e538eaeb095ff5697d95620cc992c91a8b77e1551e3734a93c060055674e36ab8bb20a6bf96cbe339ef8739c6e8c9d3affbb819d0246d3082312b5bdce96fc1e4f906bedf5367a87a9e7aa579adfe09db0a3547f75431e55c31000582470763b705886aefb3145a2d79aa45843f23e30068b485c40b72bec2128694c924a3a59ba1471f92410fc395b965bc8c82a21eccc7c3a2ff3cfb3e9bab2b71c3272117dfeb96dca65da0cab6f3167700c2556988dfb37877fc560e9afdbb686ad095f73a7b1978fcb0847d52a8807fc60d771c275b0fc0cf4bfa7cdd54d401ccac900085fa1ad8541097bbceff08beb9df18ed32826d036d9e64dfbc2aa7fbac4a8039fd124e052d37e7ff4b638e4798816d97fb12f8b77289f27f89729f10fa079987b531d97256e18d42496d7f8408a9b2974702ca9384cb64bf29b897bc11233b380f34a70db49b68d7a85391fcdb44c86c3503ec95c529e31fb365e3bd909cc0e7988ca236cdc6e9b0a24465a0bbd9b0112c320f31ae48e5edc803cda20011a55edc0117a6c24bdf408b7ba9ab1da73b81b0d3f6a76d6a421b2341da4e4d4587e545b099c24e0b71400df257c25abc794e34628d2019a53fb27816662a44921a3179f953dfd2df9f285de9a4149380a1de008b2d669e05245515994b4a6c9c416fffa3410d3c38c5e3421dd6d390d911f80493093553d35b18762e6f758002cbabed0a3380839efdc84f13814278fc6254cc44a7fd2e49f797610b89b8d64c6c746ef191797e478910fcd6446a8f8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学A重点整理</title>
    <url>//posts/564726056.html</url>
    <content><![CDATA[<h1 id="离散数学">离散数学</h1>
<p>复习章节：</p>
<p>第一章第7节的对偶不要求，第9节不要求，其他都要求</p>
<p>第二章第6节的前束合取/析取范式不要求，其他都要求</p>
<p>第三章第3节不要求，第8节warshall算法不要求，其他都要求</p>
<p>第四章第3节不要求，其他都要求</p>
<p>第五章第第6节不要求，第8节同余关系不要求，其他都要求</p>
<p>第七章全部要求</p>
<h2 id="第一章-命题逻辑">第一章 命题逻辑</h2>
<h3 id="命题及其表示法">1.1 命题及其表示法</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396486140.png"
alt="1719396486140" /> 真假可知但是不确定，认为是命题 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396505354.png"
alt="1719396505354" /> 悖论</p>
<p>定义：命题 <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396521621.png"
alt="1719396521621" /></p>
<h3 id="联结词">1.2 联结词</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396562870.png"
alt="1719396562870" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396572744.png"
alt="1719396572744" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396589282.png"
alt="1719396589282" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396604061.png"
alt="1719396604061" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396622069.png"
alt="1719396622069" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396649124.png"
alt="1719396649124" /></p>
<h3 id="命题公式与翻译">1.3 命题公式与翻译</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396698173.png"
alt="1719396698173" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396706921.png"
alt="1719396706921" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396727485.png"
alt="1719396727485" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396744140.png"
alt="1719396744140" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396766573.png"
alt="1719396766573" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396797752.png"
alt="1719396797752" /></p>
<h3 id="真值表与等价公式">1.4 真值表与等价公式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397059612.png"
alt="1719397059612" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396858392.png"
alt="1719396858392" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396867675.png"
alt="1719396867675" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396890558.png"
alt="1719396890558" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719396901210.png"
alt="1719396901210" /></p>
<h3 id="重言式与蕴含式">1.5 重言式与蕴含式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397000348.png"
alt="1719397000348" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397011403.png"
alt="1719397011403" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397184608.png"
alt="1719397184608" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397173861.png"
alt="1719397173861" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397235041.png"
alt="1719397235041" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397263940.png"
alt="1719397263940" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397283031.png"
alt="1719397283031" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397319997.png"
alt="1719397319997" /></p>
<h3 id="其他联结词">1.6 其他联结词</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397413879.png"
alt="1719397413879" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397429046.png"
alt="1719397429046" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397446982.png"
alt="1719397446982" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397883528.png"
alt="1719397883528" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397900510.png"
alt="1719397900510" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397919198.png"
alt="1719397919198" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397911476.png"
alt="1719397911476" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719397936387.png"
alt="1719397936387" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398035020.png"
alt="1719398035020" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398058859.png"
alt="1719398058859" /></p>
<h3 id="对偶与范式对偶不要求">1.7 对偶与范式（对偶不要求）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451444458.png"
alt="1719451444458" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451455635.png"
alt="1719451455635" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451469766.png"
alt="1719451469766" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451494895.png"
alt="1719451494895" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451504347.png"
alt="1719451504347" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451516590.png"
alt="1719451516590" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451529768.png"
alt="1719451529768" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451541462.png"
alt="1719451541462" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451550886.png"
alt="1719451550886" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451561657.png"
alt="1719451561657" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451573124.png"
alt="1719451573124" /></p>
<h3 id="推理理论">1.8 推理理论</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398235676.png"
alt="1719398235676" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398256823.png"
alt="1719398256823" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398310762.png"
alt="1719398310762" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398424783.png"
alt="1719398424783" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398476389.png"
alt="1719398476389" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398495378.png"
alt="1719398495378" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398703676.png"
alt="1719398703676" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719398746760.png"
alt="1719398746760" /></p>
<h2 id="第二章-谓词逻辑">第二章 谓词逻辑</h2>
<h3 id="谓词的概念与表示">2.1 谓词的概念与表示</h3>
<p>谓词定义：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399079662.png"
alt="1719399079662" />
<figcaption aria-hidden="true">1719399079662</figcaption>
</figure>
<h3 id="命题函数与量词">2.2 命题函数与量词</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399151575.png"
alt="1719399151575" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399207456.png"
alt="1719399207456" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399232911.png"
alt="1719399232911" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399244737.png"
alt="1719399244737" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399332717.png"
alt="1719399332717" /></p>
<h3 id="谓词公式与翻译">2.3 谓词公式与翻译</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719399685375.png"
alt="1719399685375" />
<figcaption aria-hidden="true">1719399685375</figcaption>
</figure>
<h3 id="变元的约束">2.4 变元的约束</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400088935.png"
alt="1719400088935" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400129445.png"
alt="1719400129445" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400191075.png"
alt="1719400191075" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400198646.png"
alt="1719400198646" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400239281.png"
alt="1719400239281" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400414944.png"
alt="1719400414944" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400422424.png"
alt="1719400422424" /></p>
<h3 id="谓词演算的等价式与蕴含式">2.5 谓词演算的等价式与蕴含式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400463163.png"
alt="1719400463163" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400476155.png"
alt="1719400476155" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400492589.png"
alt="1719400492589" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400500416.png"
alt="1719400500416" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400542868.png"
alt="1719400542868" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400592001.png"
alt="1719400592001" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400644091.png"
alt="1719400644091" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400836292.png"
alt="1719400836292" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400868925.png"
alt="1719400868925" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400885194.png"
alt="1719400885194" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400897821.png"
alt="1719400897821" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719400972755.png"
alt="1719400972755" /></p>
<h3 id="前束范式">2.6 前束范式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401107873.png"
alt="1719401107873" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401196754.png"
alt="1719401196754" /></p>
<h3 id="谓词演算的推理理论">2.7 谓词演算的推理理论</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401407248.png"
alt="1719401407248" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401421016.png"
alt="1719401421016" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401430986.png"
alt="1719401430986" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401492564.png"
alt="1719401492564" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401693994.png"
alt="1719401693994" /></p>
<h2 id="第三章-集合论">第三章 集合论</h2>
<h3 id="集合的概念和表示法">3.1 集合的概念和表示法</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401797262.png"
alt="1719401797262" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401844474.png"
alt="1719401844474" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401880585.png"
alt="1719401880585" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401893548.png"
alt="1719401893548" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401977418.png"
alt="1719401977418" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719401999619.png"
alt="1719401999619" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402006589.png"
alt="1719402006589" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402087856.png"
alt="1719402087856" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402065082.png"
alt="1719402065082" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402074413.png"
alt="1719402074413" /></p>
<h3 id="集合的运算">3.2 集合的运算</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402179779.png"
alt="1719402179779" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402189592.png"
alt="1719402189592" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402203153.png"
alt="1719402203153" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402212330.png"
alt="1719402212330" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719402343808.png"
alt="1719402343808" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403012206.png"
alt="1719403012206" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403024824.png"
alt="1719403024824" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403061883.png"
alt="1719403061883" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403088917.png"
alt="1719403088917" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403112162.png"
alt="1719403112162" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403120052.png"
alt="1719403120052" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403132904.png"
alt="1719403132904" /></p>
<h3 id="序偶与笛卡尔积">3.4 序偶与笛卡尔积</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403176559.png"
alt="1719403176559" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403195410.png"
alt="1719403195410" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403211236.png"
alt="1719403211236" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403260419.png"
alt="1719403260419" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403278142.png"
alt="1719403278142" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403301462.png"
alt="1719403301462" /></p>
<h3 id="关系及其表示">3.5 关系及其表示</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403332677.png"
alt="1719403332677" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403341642.png"
alt="1719403341642" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403564123.png"
alt="1719403564123" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403599839.png"
alt="1719403599839" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403627869.png"
alt="1719403627869" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403656020.png"
alt="1719403656020" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403664243.png"
alt="1719403664243" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403685739.png"
alt="1719403685739" /></p>
<h3 id="关系的性质">3.6 关系的性质</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403717925.png"
alt="1719403717925" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403725232.png"
alt="1719403725232" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403733455.png"
alt="1719403733455" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403749246.png"
alt="1719403749246" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403786141.png"
alt="1719403786141" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403804563.png"
alt="1719403804563" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403816116.png"
alt="1719403816116" /></p>
<h3 id="复合关系和逆关系">3.7 复合关系和逆关系</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403861364.png"
alt="1719403861364" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403878860.png"
alt="1719403878860" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403893825.png"
alt="1719403893825" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403935572.png"
alt="1719403935572" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403944669.png"
alt="1719403944669" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403961554.png"
alt="1719403961554" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403982642.png"
alt="1719403982642" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403990633.png"
alt="1719403990633" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719403997938.png"
alt="1719403997938" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719404049969.png"
alt="1719404049969" /></p>
<h3 id="关系的闭包运算">3.8 关系的闭包运算</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719404086741.png"
alt="1719404086741" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719404210822.png"
alt="1719404210822" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719404219041.png"
alt="1719404219041" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719405176921.png"
alt="1719405176921" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719405187319.png"
alt="1719405187319" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719405201889.png"
alt="1719405201889" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719406055232.png"
alt="1719406055232" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719406203581.png"
alt="1719406203581" /></p>
<h3 id="集合的划分和覆盖">3.9 集合的划分和覆盖</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407067437.png"
alt="1719407067437" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407097215.png"
alt="1719407097215" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407113124.png"
alt="1719407113124" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407132206.png"
alt="1719407132206" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407322511.png"
alt="1719407322511" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407331199.png"
alt="1719407331199" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407340291.png"
alt="1719407340291" /></p>
<h3 id="等价关系与等价类">3.10 等价关系与等价类</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407365336.png"
alt="1719407365336" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407393512.png"
alt="1719407393512" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407512334.png"
alt="1719407512334" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719407534606.png"
alt="1719407534606" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451061224.png"
alt="1719451061224" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451083328.png"
alt="1719451083328" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451141986.png"
alt="1719451141986" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451260706.png"
alt="1719451260706" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451293862.png"
alt="1719451293862" /></p>
<h3 id="相容关系">3.11 相容关系</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451607312.png"
alt="1719451607312" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451660470.png"
alt="1719451660470" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451675786.png"
alt="1719451675786" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451699207.png"
alt="1719451699207" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451712382.png"
alt="1719451712382" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451887626.png"
alt="1719451887626" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451909989.png"
alt="1719451909989" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719451921738.png"
alt="1719451921738" /></p>
<h3 id="序关系">3.12 序关系（⭐）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452597421.png"
alt="1719452597421" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452623772.png"
alt="1719452623772" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452649641.png"
alt="1719452649641" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452639180.png"
alt="1719452639180" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452701229.png"
alt="1719452701229" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452878187.png"
alt="1719452878187" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452913749.png"
alt="1719452913749" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719452945477.png"
alt="1719452945477" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453002498.png"
alt="1719453002498" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453072026.png"
alt="1719453072026" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453091365.png"
alt="1719453091365" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453133016.png"
alt="1719453133016" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453142895.png"
alt="1719453142895" /></p>
<h2 id="第四章-函数">第四章 函数</h2>
<h3 id="函数的概念">4.1 函数的概念</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453244753.png"
alt="1719453244753" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453266570.png"
alt="1719453266570" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453331958.png"
alt="1719453331958" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453353209.png"
alt="1719453353209" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453376625.png"
alt="1719453376625" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453400956.png"
alt="1719453400956" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453442715.png"
alt="1719453442715" /></p>
<h3 id="逆函数和复合函数">4.2 逆函数和复合函数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453521891.png"
alt="1719453521891" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453847397.png"
alt="1719453847397" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453883149.png"
alt="1719453883149" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453896773.png"
alt="1719453896773" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453930829.png"
alt="1719453930829" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719453975723.png"
alt="1719453975723" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454218261.png"
alt="1719454218261" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454208422.png"
alt="1719454208422" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454232770.png"
alt="1719454232770" /></p>
<h3 id="基数的概念">4.4 基数的概念</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454481539.png"
alt="1719454481539" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454554566.png"
alt="1719454554566" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454585086.png"
alt="1719454585086" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454619474.png"
alt="1719454619474" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454635783.png"
alt="1719454635783" /></p>
<h3 id="可数集与不可数集">4.5 可数集与不可数集</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454818175.png"
alt="1719454818175" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454825611.png"
alt="1719454825611" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454833353.png"
alt="1719454833353" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454846067.png"
alt="1719454846067" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454967548.png"
alt="1719454967548" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454972389.png"
alt="1719454972389" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719454995786.png"
alt="1719454995786" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719455008140.png"
alt="1719455008140" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719455018309.png"
alt="1719455018309" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456327232.png"
alt="1719456327232" /></p>
<h3 id="基数的比较">4.6 基数的比较</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456352933.png"
alt="1719456352933" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456373649.png"
alt="1719456373649" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456385912.png"
alt="1719456385912" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456392938.png"
alt="1719456392938" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456401565.png"
alt="1719456401565" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456408643.png"
alt="1719456408643" /></p>
<h2 id="第五章-代数结构">第五章 代数结构</h2>
<h3 id="代数系统的引入">5.1 代数系统的引入</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456508939.png"
alt="1719456508939" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456515641.png"
alt="1719456515641" /></p>
<h3 id="运算及其性质">5.2 运算及其性质</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456547421.png"
alt="1719456547421" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456553679.png"
alt="1719456553679" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456559750.png"
alt="1719456559750" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456566044.png"
alt="1719456566044" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456590551.png"
alt="1719456590551" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456598068.png"
alt="1719456598068" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456604851.png"
alt="1719456604851" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456613687.png"
alt="1719456613687" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456631996.png"
alt="1719456631996" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456639227.png"
alt="1719456639227" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456712700.png"
alt="1719456712700" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456718940.png"
alt="1719456718940" /></p>
<h3 id="半群">5.3 半群</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456741839.png"
alt="1719456741839" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456748487.png"
alt="1719456748487" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456762036.png"
alt="1719456762036" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456771006.png"
alt="1719456771006" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456778722.png"
alt="1719456778722" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456786989.png"
alt="1719456786989" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456797354.png"
alt="1719456797354" /></p>
<h3 id="群与子群">5.4 群与子群</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456822382.png"
alt="1719456822382" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456836286.png"
alt="1719456836286" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456844259.png"
alt="1719456844259" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456850205.png"
alt="1719456850205" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456857606.png"
alt="1719456857606" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456864799.png"
alt="1719456864799" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456874942.png"
alt="1719456874942" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456882704.png"
alt="1719456882704" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456929971.png"
alt="1719456929971" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456936418.png"
alt="1719456936418" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456941780.png"
alt="1719456941780" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456950766.png"
alt="1719456950766" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456959545.png"
alt="1719456959545" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456966726.png"
alt="1719456966726" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719456979297.png"
alt="1719456979297" /></p>
<h3 id="阿贝尔群与循环群">5.5 阿贝尔群与循环群</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457000577.png"
alt="1719457000577" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457006707.png"
alt="1719457006707" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457013980.png"
alt="1719457013980" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457019712.png"
alt="1719457019712" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457026586.png"
alt="1719457026586" /></p>
<h3 id="陪集与拉格朗日定理">5.7 陪集与拉格朗日定理</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457056912.png"
alt="1719457056912" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457066752.png"
alt="1719457066752" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457077256.png"
alt="1719457077256" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457085129.png"
alt="1719457085129" /></p>
<h3 id="同态与同构">5.8 同态与同构</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457106492.png"
alt="1719457106492" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457114179.png"
alt="1719457114179" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457128859.png"
alt="1719457128859" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457146732.png"
alt="1719457146732" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457156223.png"
alt="1719457156223" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457164739.png"
alt="1719457164739" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457169640.png"
alt="1719457169640" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457174259.png"
alt="1719457174259" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457180015.png"
alt="1719457180015" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457184785.png"
alt="1719457184785" /></p>
<h2 id="第七章-图论">第七章 图论</h2>
<h3 id="图的基本概念">7.1 图的基本概念</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457227950.png"
alt="1719457227950" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457240911.png"
alt="1719457240911" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457250626.png"
alt="1719457250626" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457255686.png"
alt="1719457255686" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457271179.png"
alt="1719457271179" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457283875.png"
alt="1719457283875" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457288792.png"
alt="1719457288792" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457298375.png"
alt="1719457298375" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457305839.png"
alt="1719457305839" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457358344.png"
alt="1719457358344" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457364702.png"
alt="1719457364702" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457374244.png"
alt="1719457374244" /></p>
<h3 id="路与回路">7.2 路与回路</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457395862.png"
alt="1719457395862" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457408431.png"
alt="1719457408431" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457415982.png"
alt="1719457415982" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457421072.png"
alt="1719457421072" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457425926.png"
alt="1719457425926" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457434504.png"
alt="1719457434504" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457441146.png"
alt="1719457441146" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457454818.png"
alt="1719457454818" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457447460.png"
alt="1719457447460" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457461891.png"
alt="1719457461891" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457467583.png"
alt="1719457467583" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457471546.png"
alt="1719457471546" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457477047.png"
alt="1719457477047" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457480955.png"
alt="1719457480955" /></p>
<h3 id="图的矩阵表示">7.3 图的矩阵表示</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457494778.png"
alt="1719457494778" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457500405.png"
alt="1719457500405" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457525753.png"
alt="1719457525753" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457531678.png"
alt="1719457531678" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457537062.png"
alt="1719457537062" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457541771.png"
alt="1719457541771" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457557246.png"
alt="1719457557246" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457572093.png"
alt="1719457572093" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457596570.png"
alt="1719457596570" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457632008.png"
alt="1719457632008" /></p>
<h3 id="欧拉图与汉密尔顿图">7.4 欧拉图与汉密尔顿图</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457654960.png"
alt="1719457654960" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457662918.png"
alt="1719457662918" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457669224.png"
alt="1719457669224" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457674427.png"
alt="1719457674427" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457679174.png"
alt="1719457679174" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457687532.png"
alt="1719457687532" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457693599.png"
alt="1719457693599" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457699176.png"
alt="1719457699176" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457704783.png"
alt="1719457704783" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457709283.png"
alt="1719457709283" /></p>
<h3 id="平面图">7.5 平面图</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457740107.png"
alt="1719457740107" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457751224.png"
alt="1719457751224" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457757367.png"
alt="1719457757367" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457762108.png"
alt="1719457762108" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457766437.png"
alt="1719457766437" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457771237.png"
alt="1719457771237" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457775718.png"
alt="1719457775718" /></p>
<h3 id="对偶图与着色">7.6 对偶图与着色</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457800710.png"
alt="1719457800710" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457810616.png"
alt="1719457810616" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457845010.png"
alt="1719457845010" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457868501.png"
alt="1719457868501" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457874665.png"
alt="1719457874665" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457881127.png"
alt="1719457881127" /></p>
<h3 id="树与生成树">7.7 树与生成树</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457897491.png"
alt="1719457897491" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457904148.png"
alt="1719457904148" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457913261.png"
alt="1719457913261" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457920347.png"
alt="1719457920347" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457927167.png"
alt="1719457927167" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457932666.png"
alt="1719457932666" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457938360.png"
alt="1719457938360" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457944291.png"
alt="1719457944291" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457954109.png"
alt="1719457954109" /></p>
<h3 id="根树及其应用">7.8 根树及其应用</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457978754.png"
alt="1719457978754" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457983757.png"
alt="1719457983757" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719457988721.png"
alt="1719457988721" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458006354.png"
alt="1719458006354" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458017008.png"
alt="1719458017008" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458026122.png"
alt="1719458026122" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458030215.png"
alt="1719458030215" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458046515.png"
alt="1719458046515" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458063949.png"
alt="1719458063949" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458069977.png"
alt="1719458069977" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458075469.png"
alt="1719458075469" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719458079893.png"
alt="1719458079893" /></p>
<p>##重点习题</p>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719487416022.png"
alt="1719487416022" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719487449588.png"
alt="1719487449588" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719487470074.png"
alt="1719487470074" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719487908974.png"
alt="1719487908974" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719488917620.png"
alt="1719488917620" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719542537832.png"
alt="1719542537832" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719544183318.png"
alt="1719544183318" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719555130880.png"
alt="1719555130880" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719555311448.png"
alt="1719555311448" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719555734318.png"
alt="1719555734318" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719556759549.png"
alt="1719556759549" /> <img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/离散数学A重点整理/1719574217162.png"
alt="1719574217162" /></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统综合实践PA1</title>
    <url>//posts/1608289224.html</url>
    <content><![CDATA[<h1 id="计算机系统基础综合实践-pa1">计算机系统基础综合实践 PA1</h1>
<h2 id="nemu-是什么">NEMU 是什么?</h2>
<blockquote>
<p><em>PA的目的是要实现NEMU, 一款经过简化的全系统模拟器.</em></p>
<p><em>但什么是模拟器呢?你小时候应该玩过红白机, 超级玛丽, 坦克大战,
魂斗罗… 它们的画面是否让你记忆犹新? (希望我们之间没有代沟…)
随着时代的发展, 你已经很难在市场上看到红白机的身影了.
当你正在为此感到苦恼的时候,
模拟器的横空出世唤醒了你心中尘封已久的童年回忆.
红白机模拟器可以为你模拟出红白机的所有功能. 有了它,
你就好像有了一个真正的红白机, 可以玩你最喜欢的红白机游戏. <a
href="https://github.com/NJU-ProjectN/litenes">这里</a>是jyy移植的一个小型项目LiteNES,
PA工程里面已经带有这个项目, 你可以在如今这个红白机难以寻觅的时代,
再次回味你儿时的快乐时光, 这实在是太神奇了!</em></p>
</blockquote>
<p>这是实验指导书中的一段描述。</p>
<h2 id="前言">前言</h2>
<p>理解程序如何在计算机上运行的根本途径是实现一个完整的计算机系统。</p>
<hr />
<h2 id="实验环境">实验环境</h2>
<p>NEMU 是基于 Linux/GNU 实验环境，所需要的环境如下：</p>
<ul>
<li>操作系统：Ubuntu18.04</li>
<li>编译器：GCC-4.4.7</li>
</ul>
<h2 id="实验内容">实验内容</h2>
<ul>
<li>阶段 1：实现“单步、打印寄存器状态、扫描内存”三个调试功能</li>
<li>阶段 2：实现调试功能的表达式求值</li>
<li>阶段 3：实现监视点</li>
</ul>
<h2 id="开始实验">开始实验</h2>
<hr />
<h2 id="必做任务-1实现正确的寄存器结构体">必做任务
1：实现正确的寄存器结构体</h2>
<p><strong>nemu/include/cpu/reg.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="type">uint32_t</span> _32;</span><br><span class="line">            <span class="type">uint16_t</span> _16;</span><br><span class="line">            <span class="type">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do NOT change the order of the GPRs&#x27; definitions. */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">swaddr_t</span> eip;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; CPU_state;</span><br></pre></td></tr></table></figure>
<p>这是关于匿名结构体和联合体的使用。我们可以在<strong>结构体</strong>中使用<strong>匿名</strong>的方式声明某个联合体（或结构体）。之后就可以直接利用结构体访问成员的方式一样访问结构体中已经声明过的匿名联合体（或结构体）的成员，使用这种方式可以让代码更加简洁。</p>
<h3 id="输出结果">输出结果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nemu@nemu-VirtualBox:~/NEMU$ make run</span><br><span class="line">objcopy -S -O binary obj/kernel/kernel entry</span><br><span class="line">obj/nemu/nemu obj/testcase/mov-c</span><br><span class="line">Welcome to NEMU!</span><br><span class="line">The executable is obj/testcase/mov-c.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span></span><br><span class="line">(nemu) c</span><br><span class="line">nemu: HIT GOOD TRAP at eip = 0x001012db</span><br></pre></td></tr></table></figure>
<hr />
<h2
id="必做任务2实现单步执行打印寄存器扫描内存">必做任务2：实现单步执行、打印寄存器、扫描内存</h2>
<p>这次的任务主要是模拟GDB相关的功能。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="type">char</span> *description;</span><br><span class="line">	<span class="type">int</span> (*handler) (<span class="type">char</span> *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">	&#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display informations about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;si&quot;</span>, <span class="string">&quot;One step&quot;</span>, cmd_si &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;info&quot;</span>, <span class="string">&quot;Display all informations of regisiters&quot;</span>, cmd_info &#125;,</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在相应位置填写所需要的指令。</p>
<h3 id="单步执行">单步执行</h3>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *sencondWord = strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (sencondWord == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		cpu_exec(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sscanf</span>(sencondWord, <span class="string">&quot;%d&quot;</span>, &amp;step);</span><br><span class="line">	<span class="keyword">if</span> (step &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;MISINIPUT\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; step; i++)&#123;</span><br><span class="line">		cpu_exec(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加单步执行的相关代码。这里用了for循环，一条一条指令执行。因为cpu_exec()函数中的宏MAX_INSTR_TO_PRINT限制为10，更改宏或者for循环后，两种方法都可以解决无法执行10条以上指令的问题。</p>
<h3 id="打印寄存器">打印寄存器</h3>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *sencondWord = strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(sencondWord, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\t\t&quot;</span>, regsl[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\t\t%d\n&quot;</span>, cpu.gpr[i]._32, cpu.gpr[i]._32);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;eip\t\t0x%08x\t\t%d\n&quot;</span>, cpu.eip, cpu.eip);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MISINPUT\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加打印寄存器的相关代码。</p>
<h3 id="扫描内存">扫描内存</h3>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *sencondWord = strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="type">char</span> *thirdWord = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">	<span class="type">swaddr_t</span> address;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sscanf</span>(sencondWord, <span class="string">&quot;%d&quot;</span>, &amp;step);</span><br><span class="line">	<span class="built_in">sscanf</span>(thirdWord, <span class="string">&quot;%x&quot;</span>, &amp;address);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; step; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0x%x:&quot;</span>, address);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%08x &quot;</span>, swaddr_read(address, <span class="number">4</span>));</span><br><span class="line">		address += <span class="number">4</span>;</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加扫描内存的相关代码，我把要输出的地址分割成一行输出五个。</p>
<p>这里全部使用到了<strong>char *strtok(char *str, const char
*delim)</strong>
库函数，delim代表了分隔符，str则代表要被分解的一组字符串。该函数会有一个返回值，若没有可检索的字符串，则返回一个空指针，否则返回第一个子字符串。</p>
<h3 id="输出结果-1">输出结果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(nemu) si</span><br><span class="line">  100000:   bd 00 00 00 00                        movl <span class="variable">$0x0</span>,%ebp</span><br><span class="line">(nemu) si 5</span><br><span class="line">  100005:   bc 00 00 00 08                        movl <span class="variable">$0x8000000</span>,%esp</span><br><span class="line">  10000a:   e9 11 12 00 00                        jmp 101220</span><br><span class="line">  101220:   55                                    pushl %ebp</span><br><span class="line">  101221:   b8 60 12 10 00                        movl <span class="variable">$0x101260</span>,%eax</span><br><span class="line">  101226:   89 e5                                 movl %esp,%ebp</span><br><span class="line">(nemu) si 15</span><br><span class="line">  101228:   83 ec 18                              subl <span class="variable">$0x18</span>,%esp</span><br><span class="line">  10122b:   ff e0                                 jmp *%eax</span><br><span class="line">  101260:   55                                    pushl %ebp</span><br><span class="line">  101261:   89 e5                                 movl %esp,%ebp</span><br><span class="line">  101263:   83 ec 18                              subl <span class="variable">$0x18</span>,%esp</span><br><span class="line">  101266:   c7 44 24 0c a3 19 10 00               movl <span class="variable">$0x1019a3</span>,0xc(%esp)</span><br><span class="line">  10126e:   c7 44 24 08 4a 00 00 00               movl <span class="variable">$0x4a</span>,0x8(%esp)</span><br><span class="line">  101276:   c7 44 24 04 5c 19 10 00               movl <span class="variable">$0x10195c</span>,0x4(%esp)</span><br><span class="line">  10127e:   c7 04 24 70 19 10 00                  movl <span class="variable">$0x101970</span>,(%esp)</span><br><span class="line">  101285:   e8 c6 fe ff ff                        call  101150</span><br><span class="line">  101150:   55                                    pushl %ebp</span><br><span class="line">  101151:   89 e5                                 movl %esp,%ebp</span><br><span class="line">  101153:   5d                                    popl %ebp</span><br><span class="line">  101154:                                         ret</span><br><span class="line">  10128a:   e8 d1 fe ff ff                        call  101160</span><br><span class="line">(nemu) info r</span><br><span class="line">eax             0x00101260              1053280</span><br><span class="line">ecx             0x26365f3f              641097535</span><br><span class="line">edx             0x5123097b              1361250683</span><br><span class="line">ebx             0x7d3f57d7              2101303255</span><br><span class="line">esp             0x07ffffc4              134217668</span><br><span class="line">ebp             0x07ffffe0              134217696</span><br><span class="line">esi             0x1d0c876a              487360362</span><br><span class="line">edi             0x4d2976e8              1294563048</span><br><span class="line">eip             0x00101160              1053024</span><br><span class="line">(nemu) x 10 0x100000</span><br><span class="line">0x100000:0x000000bd 0x0000bc00 0x11e90800 0x90000012 </span><br><span class="line">0x100010:0x56e58955 0x08458b53 0x2d0c5d8b 0x40000000 </span><br><span class="line">0x100020:0xeac1da89 0xf0002516 </span><br></pre></td></tr></table></figure>
<p><strong>输出可能会和我稍有不同。</strong></p>
<hr />
<h2 id="必做任务-3实现算术表达式的词法分析">必做任务
3：实现算术表达式的词法分析</h2>
<p>这里主要是完成表达式的计算和对正则表达式的理解。</p>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	NOTYPE = <span class="number">256</span>,</span><br><span class="line">	NUM = <span class="number">1</span>,</span><br><span class="line">	RESGISTER = <span class="number">2</span>,</span><br><span class="line">	HEX = <span class="number">3</span>,</span><br><span class="line">	EQ = <span class="number">4</span>,</span><br><span class="line">	NOTEQ = <span class="number">5</span>,</span><br><span class="line">	OR = <span class="number">6</span>,</span><br><span class="line">	AND = <span class="number">7</span>,</span><br><span class="line">	POINT, NEG</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Add more token types */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先在添加表达式相应的token类型。</p>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *regex;</span><br><span class="line">	<span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">	 * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="string">&quot; +&quot;</span>,	NOTYPE&#125;,				<span class="comment">// spaces</span></span><br><span class="line">	</span><br><span class="line">	&#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,					<span class="comment">// plus</span></span><br><span class="line">	&#123;<span class="string">&quot;\\-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;\\/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;<span class="string">&quot;\\$[a-z]+&quot;</span>, RESGISTER&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span>, HEX&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;[0-9]+&quot;</span>, NUM&#125;,</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="string">&quot;==&quot;</span>, EQ&#125;,						<span class="comment">// equal</span></span><br><span class="line">	&#123;<span class="string">&quot;!=&quot;</span>, NOTEQ&#125;,</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="string">&quot;\\|\\|&quot;</span>, OR&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;&amp;&amp;&quot;</span>, AND&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;!&quot;</span>, <span class="string">&#x27;!&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在结构体rule中添加相应的规则，利用正则表达式来判断输入的字符。</p>
<blockquote>
<p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式
– 语法 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">make_token</span><span class="params">(<span class="type">char</span> *e)</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">				<span class="type">int</span> j;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123; <span class="comment">//清空</span></span><br><span class="line">					tokens[nr_token].str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">switch</span>(rules[i].token_type) &#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">256</span>:</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">1</span>;</span><br><span class="line">						<span class="built_in">strncpy</span>(tokens[nr_token].str, &amp;e[position - substr_len], substr_len);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">2</span>;</span><br><span class="line">						<span class="built_in">strncpy</span>(tokens[nr_token].str, &amp;e[position - substr_len], substr_len);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">3</span>;</span><br><span class="line">						<span class="built_in">strncpy</span>(tokens[nr_token].str, &amp;e[position - substr_len], substr_len);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">4</span>;</span><br><span class="line">						<span class="built_in">strcpy</span>(tokens[nr_token].str, <span class="string">&quot;==&quot;</span>);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">5</span>;</span><br><span class="line">						<span class="built_in">strcpy</span>(tokens[nr_token].str, <span class="string">&quot;!=&quot;</span>);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">6</span>;</span><br><span class="line">						<span class="built_in">strcpy</span>(tokens[nr_token].str, <span class="string">&quot;||&quot;</span>);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="number">7</span>;</span><br><span class="line">						<span class="built_in">strcpy</span>(tokens[nr_token].str, <span class="string">&quot;&amp;&amp;&quot;</span>);</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">						tokens[nr_token].type = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">						nr_token++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">default</span>: </span><br><span class="line">						assert(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用代码框架中的switch语句，规定token的类型，nr_token代表了token的数量，strcpy()和strncpy()负责函数将表达式复制到tokens.str中。需要注意区分<strong>strcpy()</strong>和<strong>strncpy()</strong>两种函数，前者是复制整个字符串，后者是复制前n个字符。每次要把str清空，不然计算表达式的时候会答案会累加。</p>
<hr />
<h2 id="必做任务-4实现算术表达式的递归求值">必做任务
4：实现算术表达式的递归求值</h2>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check_parentheses</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tokens[p].type == <span class="string">&#x27;(&#x27;</span> || tokens[q].type == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (a = p; a &lt;= q; a++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (tokens[a].type == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (tokens[a].type == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (a != q &amp;&amp; j == k)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == k)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写了一个新的函数check_parentheses()，该函数是用来识别表达式中的左括号和右括号是否匹配。这里我依照实验指导书的指示在一开始加了一个判断式，用于判断表达式是否被一对匹配的括号所包围。</p>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dominant_operator</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">	<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> op = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> pri = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = p; i &lt;= q; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">			step++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			step--;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (step == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (tokens[i].type == OR)&#123;</span><br><span class="line">			<span class="keyword">if</span> (pri &lt; <span class="number">51</span>)&#123;</span><br><span class="line">				op = i;</span><br><span class="line">				pri = <span class="number">51</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == AND)&#123;</span><br><span class="line">			<span class="keyword">if</span> (pri &lt; <span class="number">50</span>)&#123;</span><br><span class="line">				op = i;</span><br><span class="line">				pri = <span class="number">50</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == EQ || tokens[i].type == NOTEQ)&#123;</span><br><span class="line">			<span class="keyword">if</span> (pri &lt; <span class="number">49</span>)&#123;</span><br><span class="line">				op = i;</span><br><span class="line">				pri = <span class="number">49</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;+&#x27;</span> || tokens[i].type == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (pri &lt; <span class="number">48</span>)&#123;</span><br><span class="line">				op = i;</span><br><span class="line">				pri = <span class="number">48</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;*&#x27;</span> || tokens[i].type == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (pri &lt; <span class="number">46</span>)&#123;</span><br><span class="line">				op = i;</span><br><span class="line">				pri = <span class="number">46</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (step &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里同样写了一个新的函数dominant_operator()，该函数是用于区分运算符的优先级。首先判断表达式中括号数量是否正确，之后进入if语句根据运算符确定相应的优先级。返回值op为-1时则代表有两个token，是用于后续任务所加的判断。</p>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> op;</span><br><span class="line">	<span class="type">int</span> val1, val2;</span><br><span class="line">	<span class="keyword">if</span> (p &gt; q)&#123;</span><br><span class="line">		assert(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == q)&#123;</span><br><span class="line">		<span class="keyword">if</span> (tokens[p].type == NUM)&#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(tokens[p].str, <span class="string">&quot;%d&quot;</span>, &amp;result);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].type == HEX)&#123;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span>(tokens[p].str[i] != <span class="number">0</span>)&#123;</span><br><span class="line">				result *= <span class="number">16</span>;</span><br><span class="line">				result += tokens[p].str[i] &lt; <span class="number">58</span> ? tokens[p].str[i] - <span class="string">&#x27;0&#x27;</span> : tokens[p].str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].type == RESGISTER)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$eax&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.eax;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ecx&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.ecx;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$edx&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.edx;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ebx&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.ebx;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$esp&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.esp;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ebp&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.ebp;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$esi&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.esi;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$edi&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.edi;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$eip&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">return</span> cpu.eip;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			assert(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_parentheses(p, q) == <span class="literal">true</span>)&#123;</span><br><span class="line">	 	<span class="keyword">return</span> eval(p + <span class="number">1</span>, q - <span class="number">1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		op = dominant_operator(p, q);</span><br><span class="line">	 	<span class="keyword">if</span> (op == <span class="number">-2</span>)&#123;</span><br><span class="line">			assert(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].type == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">sscanf</span>(tokens[q].str, <span class="string">&quot;%d&quot;</span>, &amp;result);</span><br><span class="line">				<span class="keyword">return</span> !result;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].type == RESGISTER) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$eax&quot;</span>))&#123;</span><br><span class="line">					result = cpu.eax;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ecx&quot;</span>))&#123;</span><br><span class="line">					result = cpu.ecx;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$edx&quot;</span>))&#123;</span><br><span class="line">					result = cpu.edx;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ebx&quot;</span>))&#123;</span><br><span class="line">					result = cpu.ebx;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$esp&quot;</span>))&#123;</span><br><span class="line">					result = cpu.esp;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$ebp&quot;</span>))&#123;</span><br><span class="line">					result = cpu.ebp;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$esi&quot;</span>))&#123;</span><br><span class="line">					result = cpu.esi;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$edi&quot;</span>))&#123;</span><br><span class="line">					result = cpu.edi;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p].str, <span class="string">&quot;$eip&quot;</span>))&#123;</span><br><span class="line">					result = cpu.eip;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					assert(<span class="number">0</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		val1 = eval(p, op - <span class="number">1</span>);</span><br><span class="line">		val2 = eval(op + <span class="number">1</span>, q);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (tokens[op].type)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : <span class="keyword">return</span> val1 + val2;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : <span class="keyword">return</span> val1 - val2;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : <span class="keyword">return</span> val1 * val2;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : <span class="keyword">return</span> val1 / val2;</span><br><span class="line">			<span class="keyword">case</span> OR : <span class="keyword">return</span> val1 || val2;</span><br><span class="line">			<span class="keyword">case</span> AND : <span class="keyword">return</span> val1 &amp;&amp; val2;</span><br><span class="line">			<span class="keyword">case</span> EQ : </span><br><span class="line">				   <span class="keyword">if</span> (val1 == val2)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				   &#125;</span><br><span class="line">			<span class="keyword">case</span> NOTEQ :</span><br><span class="line">				   <span class="keyword">if</span> (val1 != val2)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				    &#125;</span><br><span class="line">			<span class="keyword">default</span> : assert(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写eval()函数，该函数用于表达式求值。如果p &gt;
q的话直接assert(0)，把表达式里可能包含的类型全部解释出来之后，先对分裂出来的两个子表达式进行递归求值，然后再根据优先级对两个子表达式的值进行运算。</p>
<hr />
<h2 id="选做任务-1实现带有负数的算术表达式的求值">选做任务
1：实现带有负数的算术表达式的求值</h2>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span> (op == <span class="number">-2</span>)&#123;</span><br><span class="line">			assert(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">-1</span>)&#123;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].type == NEG)&#123;</span><br><span class="line">				<span class="built_in">sscanf</span>(tokens[q].str, <span class="string">&quot;%d&quot;</span>, &amp;result);</span><br><span class="line">				<span class="keyword">return</span> -result;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当op ==
-1的时候，如果token的类型是NEG，则取出表达式并且放在result，最后返回-result即可。</p>
<hr />
<h2 id="必做任务-5实现更复杂的表达式求值">必做任务
5：实现更复杂的表达式求值</h2>
<p>已完成。</p>
<hr />
<h2 id="选做任务-2实现指针解引用">选做任务 2：实现指针解引用</h2>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	 	<span class="keyword">if</span> (op == <span class="number">-2</span>)&#123;</span><br><span class="line">			assert(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">if</span>(tokens[p].type == POINT)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$eax&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.eax, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$ecx&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.ecx, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$edx&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.edx, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$ebx&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.ebx, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$esp&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.esp, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$ebp&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.ebp, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$esi&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.esi, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$edi&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.edi, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tokens[p + <span class="number">2</span>].str, <span class="string">&quot;$eip&quot;</span>))&#123;</span><br><span class="line">					result = swaddr_read(cpu.eip, <span class="number">4</span>);</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当op ==
-1的时候，如果token的类型是POINT，判断是哪一个寄存器后，取出的值放在result，最后返回result。</p>
<p><strong>nemu/src/monitor/debug/expr.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_token; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || (tokens[i - <span class="number">1</span>].type != NUM &amp;&amp; tokens[i - <span class="number">1</span>].type != HEX &amp;&amp; tokens[i - <span class="number">1</span>].type != <span class="string">&#x27;)&#x27;</span>)))&#123;</span><br><span class="line">			tokens[i].type = POINT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || (tokens[i - <span class="number">1</span>].type != NUM &amp;&amp; tokens[i - <span class="number">1</span>].type != HEX &amp;&amp; tokens[i - <span class="number">1</span>].type != <span class="string">&#x27;)&#x27;</span>)))&#123;</span><br><span class="line">			tokens[i].type = NEG;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eval(<span class="number">0</span>, nr_token - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断token属于POINT还是NEG，只要token前一个运算符不是十进制、十六进制以及左括号就把token解释为POINT和NEG。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_p</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	<span class="type">bool</span> *success = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	i = expr(args, success);</span><br><span class="line">	<span class="keyword">if</span> (!success)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加表达式求值打印的指令。</p>
<h3 id="输出结果-2">输出结果</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(nemu) x <span class="number">10</span> <span class="number">0x1234</span></span><br><span class="line"><span class="number">0x00000000</span> <span class="number">0x99848b66</span> <span class="number">0x00002000</span> <span class="number">0x0099a48a</span> <span class="number">0x8b000020</span> </span><br><span class="line"><span class="number">0x00123415</span> <span class="number">0x158b6600</span> <span class="number">0x00001234</span> <span class="number">0x1234158a</span> <span class="number">0x358a0000</span></span><br><span class="line">(nemu) p <span class="number">0xc0100000</span> - (($edx+<span class="number">0x1234</span><span class="number">-10</span>) * <span class="number">16</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">-1072711848</span></span><br><span class="line">(nemu) p (!($ecx != <span class="number">0x00008000</span>) &amp;&amp; ($eax == <span class="number">0x00000000</span>)) + <span class="number">0x12345678</span> </span><br><span class="line"><span class="number">305419897</span></span><br><span class="line">(nemu) p <span class="number">-5</span> + *($eip)</span><br><span class="line"><span class="number">536904070</span></span><br><span class="line">(nemu) w ($eip==<span class="number">0x100224</span>)</span><br><span class="line">Watch point <span class="number">0</span>: ($eip==<span class="number">0x100224</span>)</span><br><span class="line">(nemu) c</span><br><span class="line">Hint watchpoint <span class="number">0</span> at address <span class="number">0x00100224</span></span><br></pre></td></tr></table></figure>
<p><strong>上述测试命令是启动 nemu 并运行 100 步（si
100）之后输入的命令</strong></p>
<hr />
<h2 id="必做任务-6实现监视点池的管理">必做任务
6：实现监视点池的管理</h2>
<p>这次的任务主要是对链表的相关操作进行一个复习。</p>
<p><strong>nemu/src/monitor/debug/watchpoint.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WP* <span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">	WP *temp;</span><br><span class="line">	temp = free_;</span><br><span class="line">	free_ = free_-&gt;next;</span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		head = temp;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		WP* temp2;</span><br><span class="line">		temp2 = head;</span><br><span class="line">		<span class="keyword">while</span> (temp2-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp2 = temp2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp2-&gt;next = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个new_wp()，该函数用于从代码框架中的free_链表返回一个闲置的监视点结构。有两种情况，一种是head链表为空时，直接head
=
temp，否则的话要设置一个变量用来查找head最后一个节点，利用尾插法把闲置的节点插上。</p>
<p><strong>nemu/src/monitor/debug/watchpoint.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP *wp)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (wp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		assert(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (wp == head)&#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		WP* temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next != wp)&#123;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	wp-&gt;next =free_;</span><br><span class="line">	free_ = wp;</span><br><span class="line">	wp-&gt;result = <span class="number">0</span>;</span><br><span class="line">	wp-&gt;expr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个free_wp()，将wp归还至free_链表当中。有三种情况，第一种如果当前返回的节点为空，直接assert(0)，第二种的情况head就是wp，否则的话要在head中找到与之相对应的wp，之后用头插法把wp插到free，最后把wp的属性清空。</p>
<hr />
<h2 id="必做任务-7实现监视点">必做任务 7：实现监视点</h2>
<p>实现类似GDB的监视点功能。</p>
<p><strong>nemu/src/monitor/debug/watchpoint.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkWP</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> *success = <span class="literal">false</span>;</span><br><span class="line">	WP *temp = head;</span><br><span class="line">	<span class="type">int</span> expr_temp;</span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		expr_temp = expr(temp-&gt;expr, success);</span><br><span class="line">		<span class="keyword">if</span> (expr_temp != temp-&gt;result)&#123;</span><br><span class="line">			check = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Hint watchpoint %d at address 0x%08x\n&quot;</span>, temp-&gt;NO, cpu.eip);</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Watchpoint %d: %s\n&quot;</span>,temp-&gt;NO,temp-&gt;expr);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Old value = %d\n&quot;</span>,temp-&gt;result);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;New value = %d\n&quot;</span>,expr_temp);</span><br><span class="line">		temp-&gt;result = expr_temp;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个checkWP()函数，该函数用于判断监视点是否触发。首先进行表达式求值，每当NEMU执行完一条指令，则若触发了用户所设的监视点，程序便会暂停下来，否则打印监视点、旧值和新值。</p>
<p><strong>nemu/src/monitor/debug/cpu-exec.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> check watchpoints here. */</span></span><br><span class="line"><span class="type">bool</span> change = checkWP();</span><br><span class="line"><span class="keyword">if</span> (change)&#123;</span><br><span class="line">	nemu_state = STOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkWP()返回值用来判断是否触发监视点，如果触发了就更改nemu_state的状态。</p>
<p><strong>nemu/src/monitor/debug/watchpoint.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printf_wp</span><span class="params">()</span>&#123;</span><br><span class="line">	WP *temp = head;</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No watchpoints\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Watch point %d: %s\n&quot;</span>, temp-&gt;NO, temp-&gt;expr);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的链表输出操作。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WP* <span class="title function_">delete_wp</span><span class="params">(<span class="type">int</span> p, <span class="type">bool</span> *key)</span>&#123;</span><br><span class="line">	WP *temp = head;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;NO != p)&#123;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		*key = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的链表删除操作。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(sencondWord, <span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		printf_wp();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MISINPUT\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果分隔后的第一个字符是w就打印监视点的功能。这里貌似不能定义另一个函数来打印监视点，和之前的会有冲突，所以直接在cmd_info添加判断。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_d</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	<span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">sscanf</span>(args, <span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">	WP* q = delete_wp(p, &amp;key);</span><br><span class="line">	<span class="keyword">if</span> (key)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Delete watchpoint %d: %s\n&quot;</span>, q-&gt;NO, q-&gt;expr);</span><br><span class="line">		free_wp(q);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No found watchpoint %d\n&quot;</span>, p);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加删除指令。</p>
<h3 id="输出结果-3">输出结果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(nemu) info w</span><br><span class="line">No watchpoints</span><br><span class="line">(nemu) w 0x100000</span><br><span class="line">[nemu/src/monitor/debug/expr.c,98,make_token] match rules[6] = <span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span> at position 0 with len 8: 0x100000</span><br><span class="line">Watch point 0: 0x100000</span><br><span class="line">(nemu) si</span><br><span class="line">  100000:   bd 00 00 00 00                        movl <span class="variable">$0x0</span>,%ebp</span><br><span class="line">[nemu/src/monitor/debug/expr.c,98,make_token] match rules[6] = <span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span> at position 0 with len 8: 0x100000</span><br><span class="line">Watchpoint 0: 0x100000</span><br><span class="line">Old value = 0</span><br><span class="line">New value = 0</span><br><span class="line">(nemu) w 0x888888</span><br><span class="line">[nemu/src/monitor/debug/expr.c,98,make_token] match rules[6] = <span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span> at position 0 with len 8: 0x888888</span><br><span class="line">Watch point 1: 0x888888</span><br><span class="line">(nemu) info w</span><br><span class="line">Watch point 0: 0x100000</span><br><span class="line">Watch point 1: 0x888888</span><br><span class="line">(nemu) d 0</span><br><span class="line">Delete watchpoint 0: 0x100000</span><br><span class="line">(nemu) info w</span><br><span class="line">Watch point 1: 0x888888</span><br></pre></td></tr></table></figure>
<h2 id="思考题">思考题</h2>
<p><strong>思考题仅作为个人思考，若有错误欢迎指出。</strong></p>
<p><strong>opcode_table 到底是一个什么类型的数组？</strong></p>
<p><code>opcode_table</code> 是一个函数指针数组。具体来说，它是一个包含
256 个元素的数组，每个元素都是一个指向 <code>helper_fun</code>
类型函数的指针。<code>helper_fun</code>
类型的函数是一个接受一个<code>swaddr_t</code> 类型参数并返回一个
<code>int</code> 类型值的函数。</p>
<p><strong>在 cmd_c()函数中, 调用 cpu_exec()的时候传入了参数-1 ,
你知道为什么吗?</strong></p>
<p>-1作为无符号数是正无穷大，保证了你的程序能够执行完</p>
<p>框架代码中定义 wp_pool 等变量的时候使用了关键字 static，static
在此处的含义是什么? 为什么要在此处使用它?</p>
<p>可以避免命名冲突，<code>static</code>
变量在程序的整个生命周期内保持存在，并且在程序开始时分配内存，程序结束时释放内存。它们在第一次初始化后，其值在后续函数调用中保持不变。使用static可以将这些变量限制在
<a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>watchpoint.c</code></a>
文件中，有助于实现数据封装，防止其他文件直接修改这些变量，确保数据的完整性和一致性。</p>
<p><strong>查阅 i386 手册</strong></p>
<p>EFLAGS 寄存器中的 CF 位（Carry Flag）是 EFLAGS
寄存器中的一个标志位，用于指示进位情况。在加法操作中，CF 为 1
表示有进位发生；在减法操作中，CF 为 1 表示有借位发生。具体描述见 i386
手册的 “EFLAGS Register” 部分。 Page 33-34</p>
<p>ModR/M 字节用于指定操作数的寻址模式，包括 MOD、REG 和 R/M
三个部分。它定义了操作数的具体位置和类型。详细信息见 i386 手册的
“Instruction Formats” 章节。Page 241-242</p>
<p>mov 指令的具体格式 MOV
指令用于在寄存器和内存之间传输数据。其格式包括操作码、ModR/M 字节、SIB
字节（如需要）、立即数（如有）。具体格式及其操作方式见 i386 手册的
“Instruction Set Reference” 章节。 Page 247-248</p>
<p><strong>shell 命令</strong></p>
<p>count:</p>
<p>find nemu -name '<em>.c' -o -name '</em>.h' | xargs awk 'NF' | wc
-l</p>
<p><strong>Make 文件</strong></p>
<p>-Wall 和 -Werror 是 GCC
编译器中的两个选项，用于控制编译器发出的警告信息和错误处理方式。它们的作用如下：
-Wall</p>
<p>-Wall 选项用于启用编译器的所有常见警告。它代表“Warn
all”，尽管它并不是启用所有可能的警告选项，而是启用了一组常见且有用的警告。使用
-Wall
可以帮助开发者发现潜在的问题和代码中的潜在错误，这些警告通常是编译器检测到的可能的错误或不良编程习惯。
-Werror</p>
<p>-Werror
选项将所有的警告视为错误。这意味着编译器在遇到任何警告时都会停止编译过程，并返回一个错误。这个选项可以确保所有的警告都被处理和修复，因为它们会阻止程序编译成功，直到问题被解决为止。</p>
<p><strong>nemu用什么类型来模拟主存？为什么使用这种类型？</strong></p>
<p>主存是使用一个四维数组来模拟的。具体来说，主存是用一个 <a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>uint8_t</code></a>
类型的四维数组 <a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>dram</code></a>
来模拟的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> dram[NR_RANK][NR_BANK][NR_ROW][NR_COL];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NR_COL (1 &lt;&lt; COL_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_ROW (1 &lt;&lt; ROW_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_BANK (1 &lt;&lt; BANK_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_RANK (1 &lt;&lt; RANK_WIDTH)</span></span><br></pre></td></tr></table></figure>
<p>这些宏定义通过位移操作计算出每个维度的大小。例如，<a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>NR_COL</code></a>
是通过 <a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>1 &lt;&lt; COL_WIDTH</code></a>
计算出来的，其中 <a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>COL_WIDTH</code></a>
是 10，因此 <a
href="vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>NR_COL</code></a>
的值是 1024。</p>
<p><code>uint8_t</code>
表示一个无符号的8位整数（即一个字节），这是计算机内存的基本存储单位。使用
<code>uint8_t</code>
可以精确地模拟内存中的每个字节。<code>uint8_t</code>
只占用一个字节的空间，比其他数据类型（如 <code>int</code> 或
<code>float</code>）更节省内存。这对于模拟大容量的主存非常重要。<code>uint8_t</code>
是无符号的，这意味着它只能表示非负整数（0 到
255）。这符合内存地址和数据的实际情况，因为内存中的每个字节通常表示为无符号值。</p>
<p><strong>nemu是如何开始执行用户程序的？</strong></p>
<p>通过函数load_entry来加载用户的程序，读取一个名字为entry的文件，以二进制只读模式读取，获取文件大小之后，将程序的data和text字段放入ENTRY_START的模拟内存的位置。然后cpu.eip置为ENTRY_START，虚拟机开始执行程序。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统综合实践PA2</title>
    <url>//posts/3335903858.html</url>
    <content><![CDATA[<h1 id="计算机系统基础综合实践-pa2">计算机系统基础综合实践 PA2</h1>
<h2 id="x86-指令系统">x86 指令系统</h2>
<p>PA2的任务是实现基本x86指令，i386手册——<a
href="http://css.csail.mit.edu/6.858/2013/readings/i386.pdf">INTEL 80386
PROGRAMMER’S REFERENCE MANUAL 1986
(mit.edu)</a>里全面地列出了所有指令的细节。</p>
<h2 id="前言">前言</h2>
<p>此次实验目的是为了能够了解汇编语言中指令的各处细节，掌握IA-32指令格式，并且对NEMU平台中的指令周期了解地更加全面。PA2会开始涉及到一些计算机系统基础的知识。</p>
<h2 id="实验内容">实验内容</h2>
<ul>
<li>阶段 1: 编写 helper 函数, 在 NEMU 中运行第一个 C 程序——mov-c.c</li>
<li>阶段 2: 实现更多的指令，并通过测试</li>
<li>阶段 3：完善简易调试器</li>
<li>阶段 4：实现 loader</li>
<li>最后阶段: 实现黑客运行时劫持实验（选做）</li>
</ul>
<h2 id="开始实验">开始实验</h2>
<hr />
<h2 id="x86指令格式">x86指令格式</h2>
<p><strong>指令格式</strong></p>
<p>x86指令的格式由这几个部分组成。除了Opcode一定出现以外，其他都是可选的。当Opcode前缀为66时，表示16位操作数，否则表示32位操作数。</p>
<p><strong>MOV</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/odJSiul48aTM61Q.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>i386手册里的都是Intel格式，objdump的默认格式为AT&amp;T。这里以mov为例，功能描述里r/m表示为寄存器或内存，r/m后面的数值表示为多少位的寄存器，Opcode为89的有两种形式，而前面提到Opcode前缀就是用来区分16位和32位的，例如开始如果出现66
8B，则应该被解释成MOV
r16,r/m16。Sreg表示段寄存器，moffs表示段内偏移，段的概念会以后提到。+rb
+rw
+rd则表示8位，16位，32位寄存器，可以通过按数值加法来确定唯一的寄存器。</p>
<p><strong>ModR/M Table</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/8FBG6UvHwaRQxkf.png"
alt="pa2-1.png" />
<figcaption aria-hidden="true">pa2-1.png</figcaption>
</figure>
<p>ModR/M域分成三个部分，Mod为2位，所以Mod可以指定4种寻址方式，每一种选择里还对应着不同的选择，这些便是由R/M来决定，而R/M为3位，所以又可以选择8种寻址方式。所以Mod
+
R/M可以组合成32种寻址方式，其中为8种为寄存器寻址，另24种为存储器寻址。Reg/Opcode则可以表示成8个寄存器或者对于Opcode的一个补充。以上为32位ModR/M的表。</p>
<p><strong>SIB Table</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/WqXkFDJhBmsj2aC.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>R/M代表的是寄存器还是内存，是由Mod决定的，当mod =
3时，r/m表示的是寄存器操作，否则为内存操作。ModR/M表中画横线的部分表示要使用到索引寻址，这时候便会使用到SIB，SIB由三个部分组成，Base代表基址寄存器，Index表示变址寄存器，SS表示比例系数。举个例子，例如
mov [ebx + eax * 2], ecx
，ebx为Base，eax为Index，2为SS。以上为SIB的表。</p>
<p>至于Displacement和Immediate则分别表示成偏移数和立即数，这两个都是按照小端序排列。例如，mov
0x1a2b[ebx + eax * 2], ecx ，其中的0x1a2b表示Displacement。</p>
<p><strong>这里的图都是还未被修正过的，图中画蓝线的部分是错误的，需要自行对照勘误表</strong></p>
<h3 id="补充">补充</h3>
<p>由于一个字节为8位，最多只能表示成256个形式，一旦指令形式的数目大于256时，这时候就需要用到转移码的概念或者利用Reg/Opcode中的Opcode来补充指令。</p>
<ul>
<li>x86中分别有两字节转移码和三字节转移码，当Opcode前一个字节为0x0f或者前两个字节为0x0f和0x38的时候，表示需要再读入一个字节来确定唯一的指令形式。</li>
<li>当Reg/Opcode域被当作Opcode来解释的时候，这些指令会被划分为不同的指令组，在同一个指令组的指令则需要通过Reg/Opcode域中的Opcode来唯一确定。</li>
</ul>
<hr />
<h2 id="必做任务-1运行用户程序-mov-c">必做任务 1：运行用户程序
mov-c</h2>
<p>首先需要查找<a
href="http://css.csail.mit.edu/6.858/2013/readings/i386.pdf">i386</a>手册中指令的相关篇幅，通过指令的Opcode决定指令的具体形式。之后根据实验给出的代码框架，实现指令需要创建三个文件，分别为xxx-template.h、xxx.c、xxx.h。最后必须在<strong>nemu/src/cpu/exec/all-instar.h</strong>包含所创建的指令头文件，并且在<strong>nemu/src/cpu/exec/exec.c</strong>中依照Opcode在正确的位置添加与之相对应的指令。<strong>PA2代码框架中所定义的宏极为重要，在实现指令时可以省去很多重复的步骤，需要仔细阅读实验指导书并且理解。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(nemu) c</span><br><span class="line">invalid opcode(eip = 0x001012c5): e8 c6 fe ff ff e8 d1 fe ...</span><br><span class="line"></span><br><span class="line">There are two cases <span class="built_in">which</span> will trigger this unexpected exception:</span><br><span class="line">1. The instruction at eip = 0x001012c5 is not implemented.</span><br><span class="line">2. Something is implemented incorrectly.</span><br><span class="line">Find this eip value(0x001012c5) <span class="keyword">in</span> the disassembling result to distinguish <span class="built_in">which</span> <span class="keyword">case</span> it is.</span><br><span class="line"></span><br><span class="line">If it is the first <span class="keyword">case</span>, see</span><br><span class="line"> _ ____   ___    __    __  __                         _ </span><br><span class="line">(_)___ \ / _ \  / /   |  \/  |                       | |</span><br><span class="line"> _  __) | (_) |/ /_   | \  / | __ _ _ __  _   _  __ _| |</span><br><span class="line">| ||__ &lt; &gt; _ &lt;| <span class="string">&#x27;_ \  | |\/| |/ _` | &#x27;</span>_ \| | | |/ _` | |</span><br><span class="line">| |___) | (_) | (_) | | |  | | (_| | | | | |_| | (_| | |</span><br><span class="line">|_|____/ \___/ \___/  |_|  |_|\__,_|_| |_|\__,_|\__,_|_|</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> more details.</span><br><span class="line"></span><br><span class="line">If it is the second <span class="keyword">case</span>, remember:</span><br><span class="line">* The machine is always right!</span><br><span class="line">* Every line of untested code is always wrong!</span><br><span class="line"></span><br><span class="line">nemu: nemu/src/cpu/exec/special/special.c:24: inv: Assertion `0<span class="string">&#x27; failed.</span></span><br><span class="line"><span class="string">Makefile:63: recipe for target &#x27;</span>run<span class="string">&#x27; fail</span></span><br></pre></td></tr></table></figure>
<p>修改NEMU根目录下Make
File中的用户程序后，执行NEMU会发现报错，错误原因是还没有实现0xe8为首字节的指令。下面会给出两个实现指令的过程，剩余指令就不给出了。</p>
<hr />
<h3 id="实现call指令">实现call指令</h3>
<p><strong>nemu/src/cpu/exec/control/call-template.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/template-start.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> instr call</span></span><br><span class="line"></span><br><span class="line">make_helper(concat(call_i_, SUFFIX)) &#123;</span><br><span class="line">	<span class="type">int</span> len = concat(decode_i_, SUFFIX)(eip + <span class="number">1</span>); <span class="comment">//calculate the length of instr (include opcode)</span></span><br><span class="line">	reg_l(R_ESP) -= DATA_BYTE; <span class="comment">//esp - 4 (push)</span></span><br><span class="line">	MEM_W(reg_l(R_ESP), cpu.eip + len + <span class="number">1</span>); <span class="comment">//write current eip next address to esp (mov)</span></span><br><span class="line">	cpu.eip += (DATA_TYPE_S)op_src-&gt;val; <span class="comment">//length from eip to function</span></span><br><span class="line">	print_asm(<span class="string">&quot;call: 0x%x&quot;</span>, cpu.eip + len + <span class="number">1</span>); <span class="comment">// eip update</span></span><br><span class="line">	<span class="keyword">return</span> len + <span class="number">1</span>; <span class="comment">// return opcode + behind</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make_helper(concat(call_rm_, SUFFIX)) &#123;</span><br><span class="line">	<span class="type">int</span> len = concat(decode_rm_, SUFFIX)(eip + <span class="number">1</span>);</span><br><span class="line">	reg_l(R_ESP) -= DATA_BYTE;</span><br><span class="line">	MEM_W(reg_l(R_ESP), cpu.eip + len + <span class="number">1</span>);</span><br><span class="line">	cpu.eip = (DATA_TYPE_S)op_src-&gt;val - len - <span class="number">1</span>;</span><br><span class="line">	print_asm(<span class="string">&quot;call: %s&quot;</span>, op_src-&gt;str);</span><br><span class="line">	<span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/template-end.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>编写call指令模板文件。call指令可以大致分成三个步骤。</p>
<ul>
<li>esp = esp - DATA_BYTE，栈腾出位置。</li>
<li>[esp] = 返回地址 ，把返回地址压入栈中。</li>
<li>eip跳转到函数地址。</li>
</ul>
<p>这里涉及了对指针ESP、帧指针EBP、栈函数调用栈、栈帧等各方面的理解。栈指针ESP永远指向系统栈中最上面一个栈帧的栈顶，而帧指针EBP则永远指向系统战中最上面一个栈帧的栈底，这两个指针的作用主要是用来保存（或恢复）堆栈。后续有个选做任务也是和这个的类似。</p>
<p><strong>nemu/src/cpu/exec/control/call.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;call-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;call-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;call-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line">make_helper_v(call_i)</span><br><span class="line">make_helper_v(call_rm)</span><br></pre></td></tr></table></figure>
<p>编写call指令实例化文件。</p>
<p><strong>nemu/src/cpu/exec/control/call.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">make_helper(call_i_v);</span><br><span class="line"></span><br><span class="line">make_helper(call_rm_v);</span><br></pre></td></tr></table></figure>
<p>编写call指令头文件。</p>
<hr />
<h2 id="eflags寄存器">EFLAGS寄存器</h2>
<p><strong>EFLAGS寄存器结构</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/bPO1iHDalk9jp3g.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>一些指令执行的时候会更新EFLAGSZ中某些标志位的值，例如test指令，这是一个32位寄存器。第1、3、5、15以及22到31位会被保留，其余的标志位有些可以被特殊的指令直接被修改，但是并没有任何一条指令可以查看或者修改整个寄存器。</p>
<ul>
<li>CF：进位标志，如果运算的结果最高位产生了进位或借位，其值为1，否则为0。</li>
<li>PF：奇偶标志，计算运算结果里1的奇偶性，偶数为1，否则为0。</li>
<li>AF：辅助进位标志，取运算结果最后四位，最后四位向前有进位或借位，其值为1，否则为0。</li>
<li>ZF：零标志，相关指令结束后判断是否为0，结果为0，其值为1，否则为0。</li>
<li>SF：符号标志，相关质量结束后判断正负，结果为负，其值为1，否则为0。</li>
<li>TF：单步标志，当其值为1时，表示处理器每次只执行一条指令。</li>
<li>IF：中断使能标志，表示能否响应外部中断，若能响应外部中断，其值为1，否则为0。</li>
<li>DF：方向标志，当DF为1，ESI、EDI自动递减，否则自动递增。</li>
<li>OF：溢出标志，反映有符号数运算结果是否溢出，如果溢出，其值为1，否则为0。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/rblRGK4Bo69ca5E.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>代码框架已经为我们实现好了EFLAGS寄存器的结构，但是需要为EFLAGS寄存器初始化。i386手册第十章有给出EFLAGS寄存器的初始值。</p>
<hr />
<h3 id="实现test指令">实现test指令</h3>
<p><strong>nemu/src/monitor/monitor.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">restart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">/* Set EFLAGS. */</span></span><br><span class="line">	cpu.eflags.val = <span class="number">0x00000002</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将EFLAGS寄存器初始为0x00000002。</p>
<p><strong>nemu/src/cpu/exec/logic/test-template.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/template-start.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> instr test</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_execute</span><span class="params">()</span> &#123;</span><br><span class="line">  DATA_TYPE ret = op_dest -&gt; val &amp; op_src -&gt; val; <span class="comment">// cmp two statement bit</span></span><br><span class="line">  cpu.eflags.SF = ret &gt;&gt; ((DATA_BYTE &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>); <span class="comment">// left 31 bit, SF == 1, negative number</span></span><br><span class="line">  cpu.eflags.ZF = !ret; <span class="comment">// Zf == 1, zero number</span></span><br><span class="line">  cpu.eflags.CF = <span class="number">0</span>; <span class="comment">//test excustive CF = 0</span></span><br><span class="line">  cpu.eflags.OF = <span class="number">0</span>; <span class="comment">//test excustive OF = 0</span></span><br><span class="line">  ret ^= ret &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  ret ^= ret &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  ret ^= ret &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ret &amp;= <span class="number">1</span>; <span class="comment">// if last bit == 1, odd number</span></span><br><span class="line">  cpu.eflags.PF = !ret; <span class="comment">// PF == 1, even number, Pf == 0, odd number</span></span><br><span class="line">  DATA_TYPE result = op_dest -&gt; val &amp; op_src -&gt; val;</span><br><span class="line">  update_eflags_pf_zf_sf((DATA_TYPE_S)result);</span><br><span class="line">  cpu.eflags.CF = cpu.eflags.OF = <span class="number">0</span>;</span><br><span class="line">  print_asm_template1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make_instr_helper(i2a)</span><br><span class="line">make_instr_helper(i2rm)</span><br><span class="line">make_instr_helper(r2rm)</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/template-end.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>编写test指令模板文件。由于test指令执行需要更新标志位，这里可以手动为EFLAGS寄存器的各个标志位赋值，也可以利用代码框架提供的函数update_eflags_pf_zf_sf()更新pf、zf、sf这三个标志位。</p>
<p><strong>nemu/src/cpu/exec/logic/test.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu/exec/helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_BYTE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test-template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DATA_BYTE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for instruction encoding overloading */</span></span><br><span class="line"></span><br><span class="line">make_helper_v(test_i2a)</span><br><span class="line">make_helper_v(test_i2rm)</span><br><span class="line">make_helper_v(test_r2rm)</span><br></pre></td></tr></table></figure>
<p>编写test指令实例化文件。</p>
<p><strong>nemu/src/cpu/exec/logic/test.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H__</span></span><br><span class="line"></span><br><span class="line">make_helper(test_i2a_b);</span><br><span class="line">make_helper(test_i2rm_b);</span><br><span class="line">make_helper(test_r2rm_b);</span><br><span class="line"></span><br><span class="line">make_helper(test_i2a_v);</span><br><span class="line">make_helper(test_i2rm_v);</span><br><span class="line">make_helper(test_r2rm_v);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编写test指令头文件。</p>
<h3 id="输出结果">输出结果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objcopy -S -O binary obj/kernel/kernel entry</span><br><span class="line">obj/nemu/nemu obj/testcase/mov-c</span><br><span class="line">Welcome to NEMU!</span><br><span class="line">The executable is obj/testcase/mov-c.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span></span><br><span class="line">(nemu) c</span><br><span class="line">.nemu: HIT GOOD TRAP at eip = 0xc0101325</span><br></pre></td></tr></table></figure>
<p>成功运行用户程序mov-c。</p>
<hr />
<h2 id="必做任务-2实现更多指令">必做任务 2：实现更多指令</h2>
<p>此次任务需要通过所有testcase下目录的程序，除了这五个hello-inline-asm、
hello、integral、quadratic-eq、print-FLOAT。这个可以说是整个PA代码量最大的一次任务，需要反复查阅i386手册。</p>
<hr />
<h2 id="浮点数">浮点数</h2>
<p><strong>单精度浮点数结构</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/H7a7342f3dcc641c7a8bf3541376b015dJ.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>浮点数遵循着IEEE 754标准。</p>
<blockquote>
<p><a href="https://github.com/fang0jun/Blog/issues/27">浮点数详解(IEEE
754标准） · Issue #27 · fang0jun/Blog · GitHub</a></p>
</blockquote>
<hr />
<h2 id="定点化浮点数">定点化浮点数</h2>
<p>x86架构上引进了协处理器x87架构，所以就可以处理浮点数运算相关的指令。但是NEMU中不实现类似x87架构的指令系统，所以引进了一个概念，”浮点数定点化”，是通过32位整数来模拟浮点数，就是为了让NEMU实现类似浮点数的机制，称作定点数。</p>
<p><strong>定点数结构</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/2dNeVOFmCjIU69s.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>sign为1位，负数，其值为1，否则为0。</li>
<li>integer为15位，表示实数中整数的部分，如果整数部分超过15位则会发生溢出。</li>
<li>fraction为16位，表示实数中小数的部分，只保留小数16位。</li>
</ul>
<p>实数转为定点数的时候需要乘2^16，相反亦是如此。例如实数1.5，1.5 * 2^16
= 98304 ，也就是0x18000。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/AwxaM9m4vXJkItQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>0x18000 / 2^16 = 1.5
，这样就完成了实数和定点数相互转换的过程。实数转定点数会失去表数范围和精度，但是这样的做法可以换取速度，只不过这里的例子恰好没有让实数失去精度。</p>
<hr />
<h2 id="必做任务3实现-binary-scaling">必做任务3：实现 binary
scaling</h2>
<p>此次任务需要通过integral和quadratic-eq这两个程序，这两个程序涉及到了浮点数的使用。NEMU中可以识别浮点数，但是却没有与之相对应的浮点数运算指令。而我们需要做的是把浮点数转为定点数，并且实现基本运算。</p>
<p><strong>nemu/lib-common/FLOAT.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FLOAT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FLOAT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;trap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">F2int</span><span class="params">(FLOAT a)</span> &#123;</span><br><span class="line">	a &amp;= <span class="number">0xffff0000</span>;</span><br><span class="line">	<span class="keyword">return</span> a &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> FLOAT <span class="title function_">int2F</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt;&lt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> FLOAT <span class="title function_">F_mul_int</span><span class="params">(FLOAT a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> FLOAT <span class="title function_">F_div_int</span><span class="params">(FLOAT a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>定点数转整数只要取出低四位然后右移16位就可以了，右移16位就是等于/
2^16，整数转定点数直接 * 2^16。定点数和整数的乘法和除法不用 *
2<sup>16，因为当中的定点数的结果已经是*
2</sup>16了，再乘的话就等于乘上两个2的16次方了。</p>
<p><strong>nemu/lib-common/FLOAT/FLOAT.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FLOAT.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FLOAT <span class="title function_">F_mul_F</span><span class="params">(FLOAT a, FLOAT b)</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c = (<span class="type">long</span> <span class="type">long</span>)a * (<span class="type">long</span> <span class="type">long</span>)b;</span><br><span class="line">	<span class="keyword">return</span> (FLOAT)(c &gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FLOAT <span class="title function_">F_div_F</span><span class="params">(FLOAT a, FLOAT b)</span> &#123;</span><br><span class="line">	FLOAT p, q;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;idiv %2&quot;</span> : <span class="string">&quot;=a&quot;</span>(p), <span class="string">&quot;=d&quot;</span>(q) : <span class="string">&quot;r&quot;</span>(b), <span class="string">&quot;a&quot;</span>(a &lt;&lt; <span class="number">16</span>), <span class="string">&quot;d&quot;</span>(a &gt;&gt; <span class="number">16</span>))</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FLOAT <span class="title function_">f2F</span><span class="params">(<span class="type">float</span> a)</span> &#123;</span><br><span class="line">	<span class="type">int</span> b = *(<span class="type">int</span> *)&amp;a;</span><br><span class="line">	<span class="type">int</span> sign = b &gt;&gt; <span class="number">31</span>;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">exp</span> = (b &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	FLOAT c = b &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exp</span> != <span class="number">0</span>) &#123;</span><br><span class="line">		c += <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exp</span> -= <span class="number">150</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">-16</span>) &#123;</span><br><span class="line">		c &gt;&gt;= <span class="number">-16</span> - <span class="built_in">exp</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">-16</span>) &#123;</span><br><span class="line">		c &lt;&lt;= <span class="built_in">exp</span> + <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sign == <span class="number">0</span> ? c : -c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FLOAT <span class="title function_">Fabs</span><span class="params">(FLOAT a)</span> &#123;</span><br><span class="line">	FLOAT b;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		b = a;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b = -a;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>两个定点数相乘要用long
long的类型，绝对值的话直接把小于0的数乘上个负数。剩余有两点需要注意，一个是浮点数如何转换成定点数，需要了解<a
href="https://aa10n.github.io/计算机系统基础/NEMUPA2/#浮点数">浮点数</a>具体的结构，另一个则是运用内联汇编。</p>
<blockquote>
<p><a
href="https://blog.csdn.net/weixin_35834894/article/details/108875451">gcc
内联汇编格式以及详解_坚持的力量-CSDN博客</a></p>
</blockquote>
<p>之后根据实验指导书中需要修改的地方都修改后，便可运行integral和quadratic-eq这两个程序。</p>
<hr />
<h2 id="必做任务-4为表达式求值添加变量的支持">必做任务
4：为表达式求值添加变量的支持</h2>
<p>这里涉及到了一些ELF文件里的一些细节，在下面有一个任务也是要去理解elf文件。</p>
<p><strong>nemu/src/monitor/debug/elf.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getValue</span><span class="params">(<span class="type">char</span>* str,<span class="type">bool</span>* success)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_symtab_entry; i++)&#123;</span><br><span class="line">        <span class="comment">//STT_OBJECT代表符号的类型是一个数据对象，例如变量、数组、指针（符号的类型在低四位）</span></span><br><span class="line">		<span class="keyword">if</span> ((symtab[i].st_info &amp; <span class="number">0xf</span>) == STT_OBJECT || (symtab[i].st_info &amp; <span class="number">0xf</span>) == STT_FUNC)&#123; </span><br><span class="line">            <span class="comment">//字符串表+符号偏移量 = 符号所在地址STT_FUNC代表符号的类型是一个函数（符号的类型在低四位）</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(strtab + symtab[i].st_name, str) == <span class="number">0</span>)&#123; </span><br><span class="line">				<span class="keyword">return</span> symtab[i].st_value;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*success = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getFuncName</span><span class="params">(<span class="type">swaddr_t</span> eip)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nr_symtab_entry; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>((symtab[i].st_info &amp; <span class="number">0xf</span>) == STT_FUNC )&#123;</span><br><span class="line">				<span class="keyword">if</span>(eip &gt;= symtab[i].st_value &amp;&amp; eip &lt;= symtab[i].st_value + symtab[i].st_size)  &#123;</span><br><span class="line">				<span class="keyword">return</span> strtab + symtab[i].st_name;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STT_OBJECT代表符号的类型是一个数据对象，例如变量、数组、指针，STT_FUNC则代表符号的类型是一个函数。符号的类型在低四位，所以这边要与上一个0xf用来对比地址低4位。字符串表（st_name）加上符号偏移量（strtab）等于符号所在地址。在符号表中取出相应函数的地址和函数名(选做任务)，之后在<strong>nemu/src/monitor/debug/expr.c</strong>添加相应的规则后，便可在表达式中使用变量了。</p>
<hr />
<h2 id="栈帧链">栈帧链</h2>
<p><strong>栈帧链</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5_PA2/stack_frame_structure.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>栈帧链大致的概念就是，在若干次函数调用时会在堆栈中形成栈帧。在调用函数之前，调用函数的当前栈帧会保存自己的信息，此时ESP指向当前栈帧底部、EBP指向当前栈帧顶部。而调用函数之后，首先会把被调用函数的参数和调用函数的返回地址压入栈，并且被调用函数现在有了一个自己的栈帧，此时EBP和ESP分别指向被调用函数的栈帧底部和栈帧顶部。</p>
<hr />
<h2 id="选做任务-1打印栈帧链">选做任务 1：打印栈帧链</h2>
<p>这里需要理解栈帧和函数过程调用。</p>
<p><strong>nemu/src/monitor/debug/ui.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">swaddr_t</span> prev_ebp;</span><br><span class="line">	<span class="type">swaddr_t</span> ret_addr;</span><br><span class="line">	<span class="comment">//uint32_t args[4];</span></span><br><span class="line">&#125;PartOfStackFrame ;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getFuncName</span><span class="params">(<span class="type">int</span> eip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_bt</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">	PartOfStackFrame frame;</span><br><span class="line">	frame.ret_addr = cpu.eip;</span><br><span class="line">	<span class="type">swaddr_t</span> temp_ebp = cpu.ebp;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp_ebp)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;#%d\t0x%x\t%s\t0x%x\t0x%x\t0x%x\t0x%x\n&quot;</span>, count++, frame.ret_addr, getFuncName(cpu.eip), swaddr_read(temp_ebp + <span class="number">8</span>, <span class="number">4</span>), swaddr_read(temp_ebp + <span class="number">12</span>, <span class="number">4</span>), swaddr_read(temp_ebp + <span class="number">16</span>, <span class="number">4</span>), swaddr_read(temp_ebp + <span class="number">20</span>, <span class="number">4</span>));</span><br><span class="line">		<span class="comment">//current_sreg = R_SS;</span></span><br><span class="line">		frame.prev_ebp = swaddr_read(temp_ebp, <span class="number">4</span>);</span><br><span class="line">		frame.ret_addr = swaddr_read(temp_ebp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">		temp_ebp = frame.prev_ebp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>只需要打印出函数名、返回地址以及前四个参数。利用一个变量temp_ebp记录当前ebp的值，需要记录当前ebp和上一个栈帧链的返回地址（存在当前ebp上面，参数存在当前ebp上上面），最后更新temp_ebp，此时temp_ebp指向当前栈帧底部，ret_addr指向栈帧顶部，当ebp不为空则表示当前还有栈帧。</p>
<hr />
<h2 id="elf文件">ELF文件</h2>
<p>ELF文件提供了两个视角，分别为面向链接的<strong>section</strong>视角和面向执行的<strong>segment</strong>视角。里面很多细节，直接上链接。</p>
<blockquote>
<p><a
href="https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html">ELF文件解析（一）：Segment和Section
- JollyWing - 博客园 (cnblogs.com)</a></p>
<p><a
href="https://www.cnblogs.com/jiqingwu/p/elf_explore_2.html">ELF文件解析（二）：ELF
header详解 - JollyWing - 博客园 (cnblogs.com)</a></p>
<p><a
href="https://www.cnblogs.com/jiqingwu/p/elf_explore_3.html">ELF格式探析之三：sections
- JollyWing - 博客园 (cnblogs.com)</a></p>
</blockquote>
<hr />
<h2 id="必做任务-5实现-loader">必做任务 5：实现 loader</h2>
<p><strong>kernel/src/elf/elf.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">loader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> fix the magic number with the correct one */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint32_t</span> elf_magic = <span class="number">0x464c457f</span>;</span><br><span class="line">	<span class="type">uint32_t</span> *p_magic = (<span class="type">void</span> *)buf;</span><br><span class="line">	nemu_assert(*p_magic == elf_magic);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Load each program segment */</span></span><br><span class="line">	<span class="comment">//panic(&quot;please implement me&quot;);</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	ph = (<span class="type">void</span>*)(buf + elf-&gt;e_phoff);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++) &#123;</span><br><span class="line">		<span class="comment">/* Scan the program header table, load each segment into memory */</span></span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">			<span class="type">uint32_t</span> pa = ph-&gt;p_vaddr;</span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> read the content of the segment from the ELF file </span></span><br><span class="line"><span class="comment">			 * to the memory region [VirtAddr, VirtAddr + FileSiz)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ramdisk_read((<span class="type">void</span> *)pa,ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> zero the memory region </span></span><br><span class="line"><span class="comment">			 * [VirtAddr + FileSiz, VirtAddr + MemSiz)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span>*)pa+ph-&gt;p_filesz,<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);</span><br><span class="line">			</span><br><span class="line">			ph ++;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要正确定义ELF的Magic
Word用来识别文件是否为ELF格式，这里用了框架代码中给出的函数ramdisk_read()用于读出ramdisk里的内容，然后把segment的代码正确加载。最后依照实验指导书中指示需要修改的部分后修改，即可完成此次任务，算是为PA3开一个头。</p>
<hr />
<h2 id="选做任务2-实现黑客运行时劫持实验">选做任务2：
实现黑客运行时劫持实验</h2>
<p>有时间再做，好像是有点类似csapp的lab。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>//posts/3674948368.html</url>
    <content><![CDATA[<h2 id="计算机网络笔记">计算机网络笔记</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/1.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/2.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/3.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/4.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/5.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/6.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/7.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/8.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/9.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/10.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/11.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/12.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/13.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/14.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/15.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/16.jpg" />
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/计算机网络/17.jpg" /></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>论文参考数据来源</title>
    <url>//posts/292630706.html</url>
    <content><![CDATA[<p>国家哲学社会科学文献中心：<a
href="https://www.ncpssd.org">https://www.ncpssd.org</a>
国家哲学社会科学学术期刊数据库：<a
href="https://www.nssd.org">https://www.nssd.org</a>
中国知网：国内最大学术数据库，包括期刊、学位论文、统计年鉴等：<a
href="https://epub.cnki.net/kns">https://epub.cnki.net/kns</a>
万方数据，仅次于中国知网，包括期刊，学位论文等：<a
href="https://www.wanfangdata.com.cn">https://www.wanfangdata.com.cn</a>
人大复印资料：期刊、论文等：<a
href="http://pub.exuezhe.com/index.html">http://pub.exuezhe.com/index.html</a>
维普：期刊、论文等：<a href="http://cqvip.com">http://cqvip.com</a>
国家统计局：<a
href="https://www.stats.gov.cn">https://www.stats.gov.cn</a>
中国人民银行：<a
href="https://www.pbc.gov.cn">https://www.pbc.gov.cn</a> 财政部：<a
href="https://www.mof.gov.cn">https://www.mof.gov.cn</a>
国研网（国务院发展研究中心)：<a
href="https://www.drcnet.com.cn">https://www.drcnet.com.cn</a>
中经网（国家信息中心）：<a
href="https://www.cei.gov.cn">https://www.cei.gov.cn</a>
中经网统计数据库：<a
href="https://db.cei.gov.cn">https://db.cei.gov.cn</a>
中经网产业数据库：<a
href="https://cyk.cei.gov.cn">https://cyk.cei.gov.cn</a>
世界经济数据库：<a href="https://wdb.cei.cn">https://wdb.cei.cn</a>
一带一路统计数据库：<a
href="https://vdvl.cei.cn">https://vdvl.cei.cn</a> 锐思数据库：<a
href="https://www.resset.cn">https://www.resset.cn</a>
中宏网（国家发改委）：<a
href="https://www.macrochina.com.cn">https://www.macrochina.com.cn</a>
万得（WIND）金融终端：<a
href="https://www.wind.com.cn">https://www.wind.com.cn</a>
国泰安数据服务中心：<a
href="https://www.gtarsc.com">https://www.gtarsc.com</a>
CCER金融研究数据库：<a
href="https://www.ccerata.com">https://www.ccerata.com</a> EPS数据库：<a
href="https://epsnet.com.cn">https://epsnet.com.cn</a> CEIC数据库：<a
href="https://ceicdata.com">https://ceicdata.com</a></p>
]]></content>
      <categories>
        <category>资源收集</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>贝塞尔曲线</title>
    <url>//posts/3426030149.html</url>
    <content><![CDATA[<h2 id="贝塞尔曲线">贝塞尔曲线</h2>
<p><strong>贝塞尔曲线</strong>（读作
[bezje]）是一种使用数学方法描述的曲线，被广泛用于计算机图形学和动画中。在矢量图中，贝塞尔曲线用于定义可无限放大的光滑曲线。</p>
<p>贝塞尔曲线由至少两个控制点进行描述。Web
技术中使用的是三次贝塞尔曲线，即使用四个控制点 P0、P1、P2 和 P3
描述的曲线。</p>
<p>在绘制二次贝塞尔曲线的过程中，需要先作两条辅助线：P0 到 P1 和 P1 到
P2；第三条辅助线从其起点稳步移动到第一辅助线上，终点在第二辅助线上。在这条辅助线上，有一个点从其起点稳步移动到其终点。这个点描述的曲线就是贝塞尔曲线。以下是一个动画示例，展示了曲线的创建过程：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/bezier_2_big.gif"
alt="绘制一条贝塞尔曲线" />
<figcaption aria-hidden="true">绘制一条贝塞尔曲线</figcaption>
</figure>
<h3 id="一般化">一般化</h3>
<p><span
class="math inline">\(n\)</span>阶贝塞尔曲线可如下推断。给定点<span
class="math inline">\(P_0,P_1,P_2,\cdots,P_n\)</span>，其贝塞尔曲线即</p>
<p><span class="math display">\[
\displaystyle \mathbf {B} (t)=\sum _{i=0}^{n}{n \choose i}\mathbf {P}
_{i}(1-t)^{n-i}t^{i}={n \choose 0}\mathbf {P} _{0}(1-t)^{n}t^{0}+{n
\choose 1}\mathbf {P} _{1}(1-t)^{n-1}t^{1}+\cdots +{n \choose
n-1}\mathbf {P} _{n-1}(1-t)^{1}t^{n-1}+{n \choose n}\mathbf {P}
_{n}(1-t)^{0}t^{n}{\mbox{ , }}t\in [0,1]
\]</span></p>
<h3 id="术语">术语</h3>
<p>一些关于参数曲线的术语，有</p>
<p><span class="math display">\[
{\displaystyle \mathbf {B} (t)=\sum _{i=0}^{n}\mathbf {P} _{i}\mathbf
{b} _{i,n}(t),\quad t\in [0,1]}
\]</span></p>
<p><span class="math inline">\({\displaystyle \mathbf {b} _{i,n}(t)={n
\choose i}t^{i}(1-t)^{n-i},\quad i=0,\ldots n}\)</span></p>
<p>又称作<em>n</em>阶的<a
href="https://zh.wikipedia.org/w/index.php?title=伯恩斯坦多項式&amp;action=edit&amp;redlink=1">伯恩斯坦基底多项式</a>，定义<span
class="math inline">\(0^0\)</span> = 1。</p>
<p>点<span
class="math inline">\(P_i\)</span>*称作贝塞尔曲线的<strong>控制点</strong>。多边形以带有线的贝兹点连接而成，起始于<span
class="math inline">\(P_0\)</span>并以<span
class="math inline">\(P_n\)</span>终止，称作<strong>贝兹多边形</strong>（或<strong>控制多边形</strong>）。贝兹多边形的<a
href="https://zh.wikipedia.org/wiki/凸包">凸包</a>（convex
hull）包含有贝塞尔曲线。</p>
<h2 id="构建贝塞尔曲线">构建贝塞尔曲线</h2>
<h3 id="线性曲线">线性曲线</h3>
<p>线性贝塞尔曲线函数中的<em>t</em>会经过由<span
class="math inline">\(P_0\)</span>至<span
class="math inline">\(P_1\)</span>的<span
class="math inline">\(B(t)\)</span>所描述的曲线。例如当<em>t=0.25</em>时，<span
class="math inline">\(B(t)\)</span>即一条由点至<span
class="math inline">\(P_0\)</span>至<span
class="math inline">\(P_1\)</span>路径的四分之一处。就像由0至1的连续<em>t</em>，描<span
class="math inline">\(B(t)\)</span>述一条由<span
class="math inline">\(P_0\)</span>至<span
class="math inline">\(P_1\)</span>的直线。</p>
<h3 id="二次曲线">二次曲线</h3>
<p>为建构二次贝塞尔曲线，可以中介点<strong>Q</strong>0和<strong>Q</strong>1作为由0至1的<em>t</em>：</p>
<ul>
<li>由<strong>P</strong>0至<strong>P</strong>1的连续点<strong>Q</strong>0，描述一条线性贝塞尔曲线。</li>
<li>由<strong>P</strong>1至<strong>P</strong>2的连续点<strong>Q</strong>1，描述一条线性贝塞尔曲线。</li>
<li>由<strong>Q</strong>0至<strong>Q</strong>1的连续点<strong>B</strong>（<em>t</em>），描述一条二次贝塞尔曲线。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/B%C3%A9zier_2_big.gif"
alt="https://upload.wikimedia.org/wikipedia/commons/3/3d/B%C3%A9zier_2_big.gif" />
<figcaption
aria-hidden="true">https://upload.wikimedia.org/wikipedia/commons/3/3d/B%C3%A9zier_2_big.gif</figcaption>
</figure>
<h3 id="高阶曲线">高阶曲线</h3>
<p>为建构高阶曲线，便需要相应更多的中介点。对于三次曲线，可由线性贝塞尔曲线描述的中介点<strong>Q</strong>0、<strong>Q</strong>1、<strong>Q</strong>2，和由二次曲线描述的点<strong>R</strong>0、<strong>R</strong>1所建构：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/B%C3%A9zier_3_big.gif"
alt="https://upload.wikimedia.org/wikipedia/commons/d/db/B%C3%A9zier_3_big.gif" />
<figcaption
aria-hidden="true">https://upload.wikimedia.org/wikipedia/commons/d/db/B%C3%A9zier_3_big.gif</figcaption>
</figure>
<p>对于四次曲线，可由线性贝塞尔曲线描述的中介点<strong>Q</strong>0、<strong>Q</strong>1、<strong>Q</strong>2、<strong>Q</strong>3，由二次贝塞尔曲线描述的点<strong>R</strong>0、<strong>R</strong>1、<strong>R</strong>2，和由三次贝塞尔曲线描述的点<strong>S</strong>0、<strong>S</strong>1所建构：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/B%C3%A9zier_4_big.gif"
alt="https://upload.wikimedia.org/wikipedia/commons/a/a4/B%C3%A9zier_4_big.gif" />
<figcaption
aria-hidden="true">https://upload.wikimedia.org/wikipedia/commons/a/a4/B%C3%A9zier_4_big.gif</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/BezierCurve.gif"
alt="https://upload.wikimedia.org/wikipedia/commons/0/0b/BezierCurve.gif" />
<figcaption
aria-hidden="true">https://upload.wikimedia.org/wikipedia/commons/0/0b/BezierCurve.gif</figcaption>
</figure>
<h2 id="升阶">升阶</h2>
<p><em>n</em>次贝塞尔曲线可以变换为一个形状完全相同的<em>n+1</em>次贝塞尔曲线。
这在软件只支持特定阶次的贝塞尔曲线时很有用。 例如，<a
href="https://zh.wikipedia.org/wiki/Cairo_(繪圖)">Cairo</a>只支持三次贝塞尔曲线，你就可以用升阶的方法在Cairo画出二次贝塞尔曲线。</p>
<p>我们利用<span class="math inline">\({\displaystyle \mathbf {B}
(t)=(1-t)\mathbf {B} (t)+t\mathbf {B}
(t)}\)</span>这个特性来做升阶。我们把曲线方程式中每一项<span
class="math inline">\({\displaystyle \mathbf {b} _{i,n}(t)\mathbf {P}
_{i}}\)</span>都乘上 (1 − <em>t</em>) 或
<em>t</em>，让每一项都往上升一阶。以下是将二阶升为三阶的示例</p>
<p><span class="math display">\[
{\displaystyle {\begin{aligned}&amp;{}\quad (1-t)^{2}\mathbf {P}
_{0}+2(1-t)t\mathbf {P} _{1}+t^{2}\mathbf {P}
_{2}\\&amp;=(1-t)^{3}\mathbf {P} _{0}+(1-t)^{2}t\mathbf {P}
_{0}+2(1-t)^{2}t\mathbf {P} _{1}\\&amp;{}\qquad +2(1-t)t^{2}\mathbf {P}
_{1}+(1-t)t^{2}\mathbf {P} _{2}+t^{3}\mathbf {P}
_{2}\\&amp;=(1-t)^{3}\mathbf {P} _{0}+3(1-t)^{2}t{\frac {\mathbf {P}
_{0}+2\mathbf {P} _{1}}{3}}+3(1-t)t^{2}{\frac {2\mathbf {P} _{1}+\mathbf
{P} _{2}}{3}}+t^{3}\mathbf {P} _{2}\end{aligned}}}
\]</span></p>
<p>对任何的<em>n</em>值，我们都可以使用以下等式</p>
<p><span class="math display">\[
{\displaystyle {n+1 \choose i}(1-t)\mathbf {b} _{i,n}={n \choose
i}\mathbf {b} _{i,n+1},\quad (1-t)\mathbf {b} _{i,n}={\frac
{n+1-i}{n+1}}\mathbf {b} _{i,n+1}}
\]</span> <span class="math display">\[
{\displaystyle {n+1 \choose i+1}t\mathbf {b} _{i,n}={n \choose i}\mathbf
{b} _{i+1,n+1},\quad t\mathbf {b} _{i,n}={\frac {i+1}{n+1}}\mathbf {b}
_{i+1,n+1}}
\]</span> <span class="math display">\[
{\displaystyle {\begin{aligned}\mathbf {B} (t)&amp;=(1-t)\sum
_{i=0}^{n}\mathbf {b} _{i,n}(t)\mathbf {P} _{i}+t\sum _{i=0}^{n}\mathbf
{b} _{i,n}(t)\mathbf {P} _{i}\\&amp;=\sum _{i=0}^{n}{\frac
{n+1-i}{n+1}}\mathbf {b} _{i,n+1}(t)\mathbf {P} _{i}+\sum
_{i=0}^{n}{\frac {i+1}{n+1}}\mathbf {b} _{i+1,n+1}(t)\mathbf {P}
_{i}\\&amp;=\sum _{i=0}^{n+1}\left({\frac {i}{n+1}}\mathbf {P}
_{i-1}+{\frac {n+1-i}{n+1}}\mathbf {P} _{i}\right)\mathbf {b}
_{i,n+1}(t)=\sum _{i=0}^{n+1}\mathbf {b} _{i,n+1}(t)\mathbf {P&#39;}
_{i}\end{aligned}}}
\]</span></p>
<p>式中<span class="math inline">\({\displaystyle \mathbf {P}
_{-1}}\)</span>和<span class="math inline">\({\displaystyle \mathbf {P}
_{n+1}}\)</span>可以任意挑选。</p>
<p>因此，新的控制点为 <span class="math display">\[
{\displaystyle \mathbf {P&#39;} _{i}={\frac {i}{n+1}}\mathbf {P}
_{i-1}+{\frac {n+1-i}{n+1}}\mathbf {P} _{i},\quad i=0,\ldots ,n+1.}
\]</span></p>
]]></content>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>//posts/737419435.html</url>
    <content><![CDATA[<h1 id="rational类">Rational类</h1>
<p><strong>关键点</strong>：Rational是用来描述有理数的工具。
由于计算机对于浮点数存储机制的底层硬件局限，c++中的double无法准确的存储1/3，因此需要自定义Rational类来存储有理数，进行更加精确的运算。
另外，double类型可以表示的数据范围大于int类型，但是在精度上，double在表示大数时不如int类型。
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/运算符重载/2023-09-11_19-53-50.png" /></p>
<h1 id="运算符函数">运算符函数</h1>
<p><strong>关键点</strong>：运算符函数是类的成员函数，用于重载运算符。
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/运算符重载/2023-09-11_19-48-35.png" /></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>通过UMAF禁/启用XHCI</title>
    <url>//posts/4203464694.html</url>
    <content><![CDATA[<h1 id="利用umaf进入高级bios设置">利用UMAF进入高级bios设置</h1>
<p><strong>注意</strong> :
擅自修改可能会对电脑硬件造成不可逆转的损坏，请确保你明白你在干什么。</p>
<p><a href="https://github.com/DavidS95/Smokeless_UMAF"
title="需要科学上网">github链接</a></p>
<p>将文件考入移动介质，禁用电脑安全启动。</p>
<p>从BootManager中选择移动介质，进入以后将语言改为英文，不然会一堆菱形符号</p>
<p>下面是对XHCI的操作截图</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/通过UMAF禁-启用XHCI/IMG_4505.JPG"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/通过UMAF禁-启用XHCI/IMG_4506.JPG"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/通过UMAF禁-启用XHCI/IMG_4507.JPG"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/通过UMAF禁-启用XHCI/IMG_4510.JPG"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/luziyi/jsdelivr@main/image/通过UMAF禁-启用XHCI/IMG_4511.JPG"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>电脑硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习（一）概述</title>
    <url>//posts/4248933722.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b3c2d0ef427147cf8412a9a5a7622f552ea7dfbd2b2ad623f9e7e98aba7c4e4e">29e06521fec60bbbd8d8e44ffa9ac2d1a81490c76eb0b606c1d22a999691f723bf97807d2c95dffa9a086eb57030dd4e217cb102e391f1a9c967a8be235c0a50342a6f6f68bd71f4dbfb10f1eee456fd49190b25b81658bd8845d1d02baded2e27fa849ac32687b866da7992ec170e29519a739ee777485587fa66e0635db101d6ec21d199e0eba5fe34235c7e6955d7606c02ccba296403ddc50ae2bc626f8fe398cbb7d58bf06bc53d46addf1c85c4113bebbe127fb3334dc7b3cf8495a7bf4f55d9a40c7bf5a5afbc28af8de7a41d145b24f41e9618829303fc332af438841fa8e6672c17130eca84fb5b6f6137c34d70723334df20859ebe061049edc302fbdc354c5d0b016bd83399fef422012189f4064a1a7db2ca4d0a7806724834e70668b85f83e40bb28f930a63d1d370559e079c563edaeaa37721d83d811bd6580863d8b46e728c520de15399f9326bd66a8bfcac8ee34dcb7048b066fb156317df8f45c9a4bb2c556623cb97ef2265c6dbe82a6dc0c1a9a7a72259165eda2d66f5e0d3e2902b8146bc760ab0985d8eb4e149c586eed8bf33a9fa2fd26519d1490d2e9653e932131a0652a61ab7949ee833fa30aaf6f7f1e4061c479d61e2d69fce15b82221e3b0bb92a587ed9f07bb9d489758992e6f5e350bfdedcf8f7a5629474dfbab5266b5ac0978fe1cf50c7e0ee7092b4de81160f26ebe764f5a46ae9168df33975aa09114261f90a848a589dccc0ba7112ee41d88891b1bbc8fa61e6f4346e1d885e678a2ccce42c2d2e8e7efdbffe08f0a728e0533dd6ec03360d851a9b6ae247f103fdf7d8403fc67718941e2a836a60db732a51565e315f4479e063586886c687cd5be53f2ad8922bd900fd7742f7883aa1d1751cfd0d2e248c2a8bfd367066b1d6f1abfe9a46788ba730a339400e9074d0b6545bf70ca16b683f603705a822baa16424fbcbc74e1b4271b2638f236be5c35f2900b81be9776b60227ddbd6c586aa2b63d1c063acf8da5f82e1a9674a73d240400fd9a2a697af090403dc2e9b409695a0ba811806b6b0c30b3d9a9a58dc85a00bb5acd324b08541969e382e7fb33b927701e7582f2d7afdede20e2c78242b16e20e61d3fa60196b26923bf9b645b32db7300803d6e15e3b6c7b283ff59fb9c870118850a2aa9d79b234152e3134167f22ee6bcce68929324aadd39056f8dde7bc500c936a2a02c6af0a8bf32c8807b2e3e98be582618cae025bdef31aefa550a1ab8e8d6fe611e2ed9782e6210983ffa4446f86c808e168b0a22159b08e81b0ceb84ae58caaee8be7f40d7dc1a0e14240559c70855e14e8b17708ab3fc653b75ba617e2bb57d9b5c759c07721b1e2fa7b7a7cc8e4e2409ccedb06e08fe8786b40723c87be86ec9ebd4b49e7d8a322a44606b6e16991248503c4cd519e52e198f7f9adc1c137ee7a8d48ab5d424337bf913d3e593227cfc3754bcc955c2e1f899817fef8d0b7216351502bd1ca3fb80898d508b57cd4d5017fd8549f4f08625bdc673463cd8c9cc6bbe294123f142c18ea5b449fcc57f26991357e6e24b2d854ac2c150798dd4b8d39cb26268c22abda598eb26b79cb8820b69bc56d30bc441790ac5222c4e8f079602c552903464559b765116e2fe52aa46e53858bab0e08cb8c2d074adc09fdba0d1b9c6735cd46361139875564ba16c8edfec0946c29c38633a5ed15dbdcb6d7a31bf4a0a0f7b495b18defd1e147549372bae5f2d4b354a472c83070d7dd92b87e506ab63df2cca96ebe7ffd603f1e0ba291c3a4c3cbf7863d7d96dd38227ded86cc6e1b1b690a4ab9d828ffc8cfbbd44d0a01fe8c1b3d3191d837c2ac5572f746967c935d0f740f5762eeb88980927a133429f66c4095d66d70a00ebd46233d09773540a2a87f180797d2ee029769087fba3107b7350744d0435fcd6989b61f7d4e41a5fa99fa6e64646e43e1fc8daebdd5994e07c178bc9e2d64c89ffd9d66607055a469fdb4df302d91ab648afdfeb3413521b70eef7f4b639b476bbe1fa2510fe18be9050dd637e8dc7a01c933e1e93eb7c790c861ec64e224031b58a04495250c999d7d27885ddf7cdf02dcc7d51fbf0288e5d1724a865c24a84027b5d7c4b00d640fa0cf75986f67557581b96c97b9c048b031319e5b784813142af3985aaf10b4335d094215ab9b5baccd8ea0f4904356f02531d1e86f8783723df02fb9a348894a1fd77e41402c818fda746915681e5a326f512961e7c9c753d8acf26b707a578f3c4e8e679d9fedcb1143652135ae2981e90ca7f0c07477a3dddfdb0a8551fabb2b1ddb1ec8530cc3c6941f987402e36c60cc2dd5f119b9e28ee463d6deea725fc01593fe80b2f37abbd4a2689c5a1d7de9742aaec17808224cfdce36b4534527561be43e15c6bcea7d4eb0353a3334aa956e740ff7d798d51fb904c8969cba00f56efa105caff376696117f31bc7e3e07aa1890e1c0294c007c891192b769523ed27509e031065bdfb9104b34a61e8f95090ef8ffde9910dd9c750770376c149873788b8ef638c964daa6ef544c6adcc448365c8ae79020f3f50b89b6924a78bbe272c2122eca4e7046c9073abb2189b361247ad2420b00a63af1da8b7d11c7141e9888d01fe69367abb28cb585dc91bded2248448fb11cfb1377cbc55d9a7ded85cfaed41c1f9b64fe3e16b895e8e2152afd7bec807c85f2471e94a68934db0f6832ce6150e23c8b5f37912e74c852fe4a75174d71709b8f5baa01f4fe61e8b4726ac46b37e3415977d91eb3c02dca9b054cb0951baf6af230590a33aff735e0af1aa8b6bf8fa45cd24c12447fffa313cb6abe874a7d73881f311f14d8ed961d957345028f29228de894d6e896716bd397dd24b0dbbdac6af473f9c775663422a38c51448a950dce287982a51be1e6a63938d85b7d6362c2d5e47e06616842db7801828523f24723558d620c045919294322502e16a0a188a9dc8248796737169e4ee4a9dfdd7b622d95100a163151d1d6ccec88524b926ef6b62a87dcfc72a5ec916c1464c53da82e87c11008ec8c024f662f5f879a4d4efa29f9390fbc73b7b6458e9df046c4fd34c4da7bdeacc9eb12ea3b59f1f33b94686d10d802051b243ab43edfa7047b34e5faef740943b86ae115c50a3d04cfa486cdbb55c4394621743bad4c1b6fbe3485cdc40669b09891545db9fa861cba9184193337ad15708dd53db503936ed50a334ae4974f4fb49e16349ccb1464bc65346675e3bd7452584955fb288090e39e897c4b481b0c490ae9da758387e9f6da07c43b0f63c49734115646784445c601f297b76769087abb80b8b98ffb32dd38288cf5aaf4d735dde00e42d808752817d65150cc5ea59b0c265024131bee6e966ac726c4aad1ad9baa84f2d3188968888fcfea760a73b5edc8970faa658f7d512a108e5939a4013520e2fde722f8e037ccf7d4be9b93a07571adac3f840c9cf82c7e67f0546d94582375902b48c39a8e7303acb8a91b4a88749cd720f3e7e5533804366f93baaa95b7c95232cdbd71d0855759e0bf216f01f247b31b3aa867a496e3154dc95d662e34efb4e030a3e1426457bdd5d977ab9303017ad972ec44fc0b71d8fd0f4a46f485ed92839ce33120b0c164d2b9ab2c05e287b6492bd1b1497e16883ba338a4300def20089441017041859dcd0c0d16d0a558849c08119ca82378c5ab5da5d7926552f01c79c22b2d574468e03de7925dedf29fd46584fb1827a54cb587482529db797c6624fe0e2de0ed834f254771448e8dabef1bd2fab7f706462fec602559d39dea236772374724cb1215b2e79016acb183b9aec56ae94fb5794b35516fcd65652d266b203e134a95f884675b4f341c5c0a4f95349f69e6c8fdd1d3971f82be7d986b04311c3276bebd70b525e2209e69e7c3f5536e60f4a1f4c94e543c44ee7388ee3d1dc70252135c1b9a27e3f96089f8b2335460d64859a7ee1b3e330858f4f91386b8326ac8d720c5becf304127401c152ded3cc816aed6bb9928f9791f7f2a4d407cea83b3839de897940250d0cf9cc804452eaf8eccd1494965803dc6ba97fd096746c1f53cae852f9b3fb76352e30affb4a6865539a8a924cc798c9ccad523598653b1099acfd4c72a4e4f409dfba9a8f543382b7c66897b8333c1eb2bbe842a3b87deca161f12b6d391253622fe773cfdb74652820b8c829140759d25bff7f5216180c378399fac0821c8087767d231e787bd05a8aea238eb364726cb73622ce941c4dcebca2ddf7e245d57767b15bb22978a14b35abe5946cc645f93634cdd6f7824e4f8af1cb5ade373b04f90281d69ce06e0a3a657704d2022f3014a1e8139beaebe08b327400cad79b09efacddf8b7c70f8a3de8ac6871ca2b1c1aee2c3e313b26538b55e1343420556c39e00e1546e26263fe794882e6a216cb76196584f8f9cc04bfc95e55eb9584ea2c7f0f12660cc1f6dde54a53395f23bf8c1965772f9d644c713a7bc1662885ec759667c6b178b05ae7d49ed989dafd6b7e36e34fffead64dde6b2fa03d8d11ba40a7b207d4bb5e5fdb1da0813b6f9d33759e2b90225f8e23e41fb94038715da8843917416f44860ac1507e53fc2eb9102853df9b0f3d58cd56a8a16785c01a442ccdefeb84b19324e4be2df8e91fafccef8af24e28157d62ed9c9475051b31f80a912c4df8bcee1dd8fee13082faa325f078d96b822d9403b825ca41323c88be7e54ca5ea93f9b48178ea5291fa16bbb1e7e4dbb4f5b611cfa677292b7eded112618ec68b619d80511a8678cf0c0ad8ecd8b3cf004dd443e90516a10733c9705557571e5b5de922df96bcb0e46cb66e521eff76819ed994a14e93379cf26973d3ce158e6558262ae3239019da0c6177b687b4b4bf058ad1c8559cf4522faa0d17e3af7aea13f172ccd8a8acd5be8a3333fc7f6cebaa0e1ba378bbe279c40a8d84ad9b3c8e74981aa25562608615fd48bf0241400ed85abbf54499420547a17f24062f596ff8cae3dddb8669c487fce7834b987bb5df005de77c028a241ebf08c725697bea6034d3748a3c07c0e76da6f228512dcdad45a4401355835ed95eaacbf9277305858f5c3695d89c12770664b7b255d705c1ac8b07462bcdc90cea9d273f02468aacf54159180f756ef123af986745d630a548e0dba98d650e97f92892c42def7a36837e258f1e6afe14f188d96683039b4e9e69f19bb6b9c1ec6cc9ea77d97d2fa6838987d5148c97f0d52b6bda89b6c143d0606f2c658a6753b30ab3fa553267413a8241855bede34abf8b688a7db20bb5e4e47e4cfbd6afc8619e7f10361b11393c7505dee6d052111637687413f2c70706286eb2fc803166ba545752b7cdc483918caf40033f92390f0eb42902837e220854813ef47eeb461e5dcb2d8094b8cc952e6e76a594453e601a941e1cbaff3bf37b24e7a84b1278f5bd7a70f9a31c0def6fc049d5683e7e3bb1772e727df6f811c958444523abe9e5f224cc7616a74772e0e907437c6b315ae40e9b751fe292e862e5fe52b9e7906a94cab7d5efdec0446783569c4b7f97fd245a3dc7ca0fe24a74f3c3eb87e513efe49323817acb2dec599bf745d4d4d8c0de3264cc59c02a7c6f1c9175e3370b3a1342196645182f3764d6fc5130261a7e6ea3b75c4110eeeb5c6c8369c2fcb8677525249949f2508addd9b9e7daa93a5f6409bd07118d3c029afef37288460ec0a0f2b4263cda1471b0bca5970b11a2c1710af1f66126507ddd85acb2cb8520457c979c0d80e4c3f51f7f275cacae932b50df454742add629a8bde9471ebcc15e80c539a202bbe7f748d0c709ea1bdfd9378337eb6298bea2e2d08f4eb1a4960412ecee975a30e0931d7e657b12f153030b8499e27d0daa57c0168a0440c295e1ec5686718cb242bbfc569186ffa79bbe85417dfb9de6c3ea4927bbb18b7a155cbfaace10b5dfb0fed9c05380957e0fb2c04e11aa15e71eaacb5a633a0549a75b5a0f76a7e488f03d9f7f8ecf176b1127543636be0f2ecfa08a4612c7e1166e2f6b31c076db292862476358936856b8a5ad2f625f324914f13e9e4044a67980dc43b24552a902e9a95f3ff4173a09060a1daa5959a6297d731be2bee4e7fe4e1e3c08e0ce658d58706f56e70784bfe1ef8e13e5560caa05fa41f6757f965e80adfbd4bbd28b848ec9f5c6c8f97081f8ab436e617cec96fd25611a4beb02ae752b70cc82d943d10cde3edf2404d7d4af0c6c65be2e9bb050724ec50538f40eab0868c6ae4182196fe6392af125b73d82848a73c0fa1c548addca7a24346aa4e4d40c875a0552b4c2f5fb143b0f1e473a81c8b5461d7ecc13dec6a738645da46ae72afd54074310f7652698c6514f0b763eced8550a62c03639202586b7e4a2b5d3c8fbbaab562339e58bdd49cf831e476218107a5f09f47a6be1eed587a1f3a04fe4639c1a3f9a342b7a7fec66de795e496725265635df778be96a77094f9881d0a8ee39f9b296a826d92f43f344e13b4841f399149d23681187e9d0cba0277e60f7004c6cd83f7986a24d9602d5a0bf8c07d6c62cfe883c260be257ad9fdf2e14f56a87400912e0db7a0359248f5f6856dccc78070afef426a43116691daec534030aefb361b15a53c746e7885766e23c5b1669a6d1cd9da2938304025e3c9a6afa5eb68de80b24a91170847430c23c97160e62e84bba41400e55f80ff068e3c0eee6fb5821d8b4d02a2b82bb1ff9e3e355f0c06dbfcd7bcc66552df130814597561650545b5bf7e75f8c398ef421d0069ab0ad31ab0bcad7d7d15fb3c8ccb7bd5e5cb1c29e4c0cd7f9389be88e14d6c333b36e1172707382aa84e88ca4623cd20edc76d36365400da436533f5b1628ee8d83b1d94ef6e8586375c219c1dc612e215877cf66e7c0666cf351f02c0fa8a1542097cc50d4db33c19a2e7975809267764fd6dc70abaffd563a27ce8e0adad75cc0644c97e67d1e003a99324d4b144e0cee227bc2bcbb6d174f58458aebd452c92c381e60b3eb6a939b328c495d49b4f9d2d38e051692b5c6f1115de1a727fc1f7aee23ca6c6f2db9910bf9b450e4b1fe6aa2ffb92e8e8ea3b69fbe1c4f57e19dca59cbc5680f1ee2efb06911de1f2a28d5551b459d9b077fa27be2830176bb0ba3330f03f67a88756a5d43501fed7d49c8590065a66a126a8208e95a5bc6c3affc54d7ea41fd0edc64b56b8168c86408144c3782a0cdff037d4849a66d93c311408e3f83551a2949244bb47e91664806e258f9abb4852c24c98509ea78df4ab4e94d4bc780349950e6b20904f4b8ebceced43b44634749272773d475e83482a9b9966edf52dda8a3431877d8137295a79682c1b98798ad1654611af02ded0581119fe8f95ea0b8dabe3e708385c667a3e505fe3770170fcf668a8a97d0bbef01bea323e963a495a2caa196d2ccb9a191996291236e88403f9df6201f1c0b94f13cc56c8dbc0b23b251a1c5936889bd21dd7fb458a2a2c2d96a2025fc1f7e6789b542e59debaa5f733c2a846f96b0db1993ae2acb47dafb74b3138505bc6732d741cb0d8564ead2c290d63cac7e35477536ad05eae0a7483cb204dcc54f770d3651777a635a4f0125a8d03dfbdbdfdf9a2b31e4cfc860a9ce1d050d3983c045805dcceb05213312975cf16fa51f8abdca59187ab9ffed2bebc177c4e745db69ad4644cbfeb8e1bdf8972eef87b9181a2c115f28690ff91ebcd11587b73cb3547312cc54e541d3c19f4e892a5ce37a9ff1a863ee3093e914926bcba6dfc4ebc16f2dba792e588a77f3b152cc635fca4a82823d87dcdb757655d09743319dd15f1b748bcead36f470ba9f6712588714fa9b0c49a873d17e9b8c2a6730823bc3a36aeb28c250df73f8343d24e46029cc2c6f5b345e611db5ac7f1403ec9e336fc1b5f6abedc871095006cafefc80b1c6866dde32a958389bfb3d77e174f10ef1a0c7df75ebd898e79a6ab5673c3538529990115a99e7753a7b4835f753ff414f06e7f2585f88b60188e676a5e61cce301153b784e28e5ba86ea62fc78e74a863558ad40ff1376b9c8488046bb7dcf460867eb2380475093e573430a0cb922d46e15ee1c8b731f8a56b69869e6a22d7ce84ce35e096ecad3629f7dc8352235df487517039091b763b13ec3b1f51a5565e356d799b0cff9d023f5d14a33e8976e6dc2ae8a04c5b559d58f8d9db6cbcbbf543a6499df9dec52c7a895f644f4fb6b7933fa03e5dd18d81646f51c2475d6ce8ccd0dcac7302f24d23624f6435a65817f6e6f09bbadbd4e49f4efac4a0b02cba1907a0085b83547e9c689b4758e8970d9be0e81293d25ee799148b72df079f02be3e2fd94ec035c39e38a26a2d842afe89247484cbb52fe8d3b92e423a84952765a04324241e966f1086e37b08c1b55d4125a03ffbceb4b6b7a4a234373122f275361658146e9bca4a8b9e8a05f02f47c8e9b9a888ca91b2aa764a3b6d65320431325f3728e859431679e92d3547b80f7c9f8e6fe0436c018d70c5b7e560cc704795bd271ce005b33b27ee2f1115a1434b5b0b581c33eaf287e387f93dc9da32b7e0e57c98954540e9433e8c09a7ab17eefbc55d32b61ef72abdd59a562e9f52c172a929229931e3a4bb2391e07f3b097077a75bbc73268bc2fc685a1c85bad3352110b9adf403417bb518464cc31f0d66cad8e582674e873d5b3ffed860dcfed117c9ff205abb57b36beb8bc374e3b42b3c0a9e5da34713d5e540aa2c634fb14015d2ddb66b561ee2438a2b6753bd70851dcf0df8f456986b514132c2adc20db82450c86df7b58841e6b2ea346c5094e263616dab2d2c65eaec7e3a8bef04bbf63cd1166bd1bee3b6523dcf7246e3d16ea1c1ee46b32728e577367d49032494aa80d5f74379bfbf2fd24b21d2b456e6e7fd754c787e75a44763985fdfa4007c59153d56e147f1233a688c054e8c621c4aed8f6178d9c2e1b5523aec052e41f777024aa5fc8d6fa861836e20ff17f8fedb3038fdd1aa45b70747baea4521e0df36645cbebce8cf92623d3ead14748d489ba09614a7c83b2f062ab169d3a40f1e1651f048f287a3bf52ccbdba4b757b6191f1efdcee4c7bde14f6dd3c70478b1c0877248719bb3a9eadc67f7742089a2bf52f84e8de9bd014a94d0e378c55e7c3779b8dcfe060075866c0a3463acf5d4644e090021874b71eb39e10f33e30e0df613d906a82dca54b8a4f0432d0665261fe3ea06cfd5d3291a2ce1657128b91b11c146a01d4bde28bb769be153e084eed76af8c0be8c19c54929a7271696b08fff205cb5ec895842e6172749f37d0f082a75e92e0de60fac3b3c2322a8e84d2d28ac513442ace82029bbb1505c945f74fee15b463193dbc33996bf085b6f44a74c53fa0ac805cf12a7cefcbcc43995aa649a55cf9901b16e42cafccbbcfc4f79915628dbd1967ee905584657605bdac3e8912dc52409aeca86f6ce1697d57b7a26bf6e24c5030822b04927fc48def75ca2c138a3b25eb0276b33021be8dbdeab78c11f022c906ac8d3dcb40463d4528926bdcad7bb824950ab3a751639cce2e3cb223969e407b106c3459ef6c142b977517f7ea15dc1f54bdd4d2af0cfa528cd6b278e5395d5719c2f2c945f656b5ac8304f72ade7898c7ffe187d2c46c87d86dbdcdcc1fe9b09770183cdddbe447f68bdaf9358dcb92d131b1f130cca70774c9d236b753273dd7826416482a36746aa96582cd034db0f4bbbf33f5d3e045af2a24151ed61b3d34f01c3a8f9e71e3b21ec82e2c569091f89352da38de392fd1085ae2b0b0ddae2aac8524da823cae5fcba35262940c744d2b37b85b1c6295a8a2bacc7861b36b8a52e3cec17272e7a5fde31f5740c3ef49580a390c6fad3f3bc8c4c7d922c650b74600e287fd8bd9ce173ac7b52f6d46bbc2cef44c97f9d50648571c15a6719ea0b87892b7ce8b0d022c93f2c59f276dc0951b12608adad8522a03ded92564de6e5c9b5884ef6a4b307043afb43cbc98b0090761e2959073172b3b60e9c23b705aa5b983f23621faf04ac546e7ea0239d7250ea4dfdd3a226e10c70a05903d70fdf9529c70db0947ba8e2426c283cf42f6e44bfb9aab11856af4164d0a9d9832dc35e882a0cd74bdca13be86651933dc4fb3d1849f790c8252966f9ba42467f9401d3713cefc6dd4bfe86e8663bc20249880c3b2aa782d01697e55ab710c7d7dc969ec44cf4ae09ce1d3cebe37d2fde58e98bae504e3a125b22f73c910d2eb411a03a20780446860c6e29030a30b22e65f1725ab0308bddfd2ad0000f2fb2daa5306acefd16c89283b7f557e725c94f321754e4fff1802db12c6186709c790497c6bd426e6c6bd28928bb094b4f027094e5505e1ec62cee5b731d29632bb5efaa7347e1b4ff0569ff3bb298c6344107a679a3a408f80f06573b9956c745bd40d52196d44bd81733257726d30f09f4747d223813ce9805fb233fff346f28a9e8531fca5353a23d902e9cf6719ae73bbc621447cad6bdbe99a81c7a9c5c9650f4ced0c95c9a402f998616a276834570408915eddcdc2912b0c47c05d1e06e6a62b3b03be10e23e7fe6553be56c79c4bcef986f9383237e1aa525bf7fd977850ac694a037da50b01e4ce263977e93578d8577f4459f83a9b2c2cc2ab54a17e0fedf2563dc2601cfeef4011fb6add984fa440a3a0a6759426e26499a3acbd055cb2f99ac25f9126f10a823f1fd165910bef415514fd87fc8c384e09db9e9ab655eef2618cf5a83a5f1678cf007f39946cf11a92cced2ea28b38504f6a7fd3a0aa6cfff77edf60a6cf1cd45d013065c141246485f8a2e7bf519272fe9dea40ea791625f0be2cc41a7f7e18d472d99d375ccb8201e7c704cd82f100468dd41312936168ad160980ce2cf5b15438e84ae0273486b27f3b4773ccd37932ca6142e50927e62136a64561a8d8f840903eb4c9b5fac13880dbef0d77b601ae6726da72e874661c25e1bed6e90d248ca0ac636c81d185164bd84be583ab6bc40a4944f2bb505ac3b2adf0af71d1d4ba4137471a273122aac3aacb5194fb01d70d6e557b6e0c99acc640b75bcf9639c0e1f8bacb0644d100ffb6a7cba02d7da613793cc6266204611214f796222b3bfa29efedbea97ccb622b5733e308221960b0fef9ccd877631d968568ee7e0c48fd626915a80d480b64d31679a19c731bad618c0099173720a19e670dad15849b983f6dfe4aff816d51a04929b5ee43c9b303c13e2af4dfbd69ddaaff85b3539354454f873a79cb9b5687c5b0b4862a9b6b9224389c1f4536ca3b97113e7c1fff42e6ce42a8039a11d3dae9e29e5541376c8249858544fa4b9fc1bb3ce4a98f2558598a48612dabe3273eac91a5464eb27ff4b1cb7a8ff1d0f835cf3bca895d586b2a860941803d390eee44c433644fd606a797c92403987423701dfe71ab887d2e52e604b8903f1fa1727b31061c440a9eef64ecc4b72f1e51bf4bfb31d0ced8f0a584198dd33ae2b3ee456a1a800d2956cc68b722b5134a1806206254ac0197062ef9eb467a3656ec6dc955e131362e4429cd230603479e544ed2e3fc7a35cc5b18b5300d7cab8b8461b7a5c1cd23af5462fb07ecf757666ef5611152a6ceec7d4d1793f94f4e0fd6a0d5a8be16d1a702599966e15a66add07bcd12ea9dee78f4bfb66495f51fe56016ad68c3b4f70c33d9298059eff97bd5bee0ae854858a2a2b65a5da2cce590781dff04f77a60a54524ad674cdb4ec05be6fe170be0d55919837274e9ac48eb5ae096f17f2cdc58db504f2801276884288d8508cf6dc195cdf2f8b6a85a1aee21a14eb40c77fab66ef21c61fb75fb4e94f22e9eaae799644cc74b49e72ed5f77eecbefba96ea6355f0c787f0b584a439ab670ae3adbc5392a6312a86eb602a9b465b533ce07dd72681c0d43039d5861201c2335d6f774f742627f5f7b17909c08770a5d8af6c4ea2a6cb67ff625703a46b9a4bb782e9ca481b7bf64b615fa60d1f13e9a92d46374761e79b0cbe1eb6c8f9f93d5a3c29e3ccebac570a19e01a0d8c1df5db049dec174e1b1ff5145a0dfa1429a813ec523f72519f120b3a82379846cc9542d6e0750fa6b407ce836977722b36ebcad1c781963a57d58f135f7c4cf8171b79778bf65bc8972a60415786831d38c8eac6a8d5652ce98ab5d0ba40556c1dbd2f24b7b15dfd9aca35e0deaacaf69a35220d4c041fe6a336adfd1f1495ad4db7866e342d9bfcf1c3b93ed6aadfe73174250d0654d0cda3329cb831c6ed965c281f6c1f48143214abd8944de6dffef30ae78594a948429adfe881bb2c6df4b2604fa37f7cd42191c1499e219916a99e328fb037a04e0f17c10d6c7cf4af74fd0b4a5cd5881faa5e0f25b4ce550d4099b144fa4d31767dd4a269e6b7529ef2c20bd507b950227aae8bad43afa3987d76db0b83514c4c92b5e0372bfcdde260fca804c705cdd4c298cadbfbb0c96d131cf96725526ffd07ba25a437f208b5cf6e05e88bc0a113008809bf57f06dd6515f70f914c391845447ad411577cf8702ee487e7d10182d7ae6f0caf70c76b240fd5fe5ac07c1b7a8ae4f894623239e1abd3015be48b54d81765fce690d38ec12c67e31d615d7c371ecda4a4b00a00d0d8f072f76164cba4da88393045dd28c7802defadffcd989c9816605ccdf1a159a17c2217d2738f544132a0fa1d8f020d12e035151a7b01ce0948c12ecd2869b63a6dd78cf7c8d75583b7d338087494fdb1a66094d99fbf8febf93aabf285d3aa93ca36294e29697e5529444b47b701a8d9d9a7571f3f2ca6cdff0add1dd1da22a00e5817d3a99ee461beacebc736d4a2e0e55d4cb14b34532af8119725de166f772acb5be9ee29a7109f5d480a8c5df1bebc7243c20dd3a98d5924ee6847d8f6f6614ad383a76863be2615bdb3470dfba6577d2d9743491374502e7ac38c086cd94cbb4e5ecf8dbfd23779774e8bd9c356b4069d42f37ea5f5e77b0f24f84ee9bde81759bd475efff5bc853f2704cebc7d699bb7f1d5a41502772a6393b234d09756269451bab8a16fdbea0ce5e199eb9564aff18da274cd29b9f1803c81d4271d55e9b9a0a644c9884d795cf03b4241c244d0676b8dcadcefff4ae13daca4c0a78064dc3d4e40e0c210bdf4ace2f2192ba8799e1076d1a95d9ca44bce015eab3d4f5b83c83d20866a73d1a25fe9723778cdfd201d416a9a607e4b723a8c55592ef13d7d372934881ea03ac24a51e4393961920d301b0dc4ceb18228a3fa77799da9780f786f028c9fc56589ee824fbaff0fa19bffef823d1001daa85a557df32f6c3ab003df8f801e492906a3795307ba20f693397ca54129dd5e60a243ccf1d4db509a9dcf40c727ce200e227343b3ac467b7f594f5bb74c45f4654d7ceeda326dad154f952d2cbac01b59209e036816b93338f7b3904af9551426db21eb29ebebfef98cfb150ce04e678b482b1154dafda61c9f9fb0ff99a1586f0d85c3c6649d7bed79c4a8113d242fc19ffe10cf28d95cdddd10bbd88228baa7b51cb56ca640ed7ea0b21f516819914fa9453a54b3641411a6fbe6bd98008c0defd1ea6245afaeb8a836a347b11b5e125321b8995c077c850dc5e3529d51db1c5de1221a5e05c9326590199fb0d137abc84c0c50d62bf09fb5429def63480e517a6323bee08e914ce48395a062d3821c5860e74ada6320424025d2587181c6f3207e10b2110fa45ebaaad47100d38214f1e991f55434e91927b67d3febe35217d12b0a81b730e35184e8f57b2c01e71eb79cd2e6f9b6624055b619b1e2178dba88ee0866f2c0c117e75d692f6657b689813d15b73ce0a3cc6d34fdd3a266c962206a8fefc22d4892eeb94c9ab10026e00d9c05b0657e531109fbecad607cb678d68e847f4497db70d8f5bf4f093a3964d2a250c2055b79a02b80fa98ff6b428f792bca95b409cfb26d0ceb67308a8f99deee288c4376ca56789216d78f9b9b3c254ef90e06f35a3eeb82ace9e107f407d42be4a08164f69b4a4d0f941b797d1731f1cc14738f5dcbbaf0f4bd5e0e4c62cb2f57d99993d0b51cb09f299ae6a63d441f342b7a6938b2a58e4951413e51bbe049872c736cecd0288187713d324cbb380a75777c278317f3d5df21d2d7d5e5144e33a76a305615259b749494e76ce9fe4dc196df0475537e8d97127b5bbb3779f66464ca79ca4233d7669aa9dabbcef67e8561b2ba256d5866e0e0c0a869781453d3a72396cd6b6d05cf4b7842115c30592e1e5130861e7f1f63841fd4c057220309cfb111da6ad4986fb961fcc95527aa9e73ac723cf06bc6de91852bb7f2c0732ab4c316af9013c0ceb97ab03f8f2e1287c800f288c2ff11a39c0992767a3d6d7a68369d71dfc52ad61732df623b5b7a6f5bb6cb321a10c5757e2f5f0c67b570d73542031073d80020e16e3c5a751a574198da7578cd255741a57bce634d54935dc890bba74a1f61ebc6869760e362552b1befd7d478c583d3a2ef36384198d365725ae88192215758eb628374e4e1aa794ecd6f2df4a906b43cdf7d2d3d159251251def801905cf61cb21a7e665f958e4bcb6046165e338c91b09f81d4eface42babe4cf1fd6a054f4562dff9e07d0da9ce90dd3cd361abd14c21c1e91458e8b4f0fb00ea5b45d48e2e82c72211f2e5201e795f827d8a8c44a27bb0b34153528b9040d759e7a998131b5487a4c0cbf247177647855a60ff4889cc4e7a6db588e8f527c1e5e420e73291a3a8531c1a78590600d945d6758944894662021a34e3754f0447c3df9646a0c592ee96131c68fce0e8009c02382fb1953355f8a0c164ec9f08b6c8380238177f90a53cb52668aaca7525cdebec0fefbee6780835e29c5bf1eba853622513006daf45168d1aa079f8ea6cda91cb46ad8ad34ac37a7ce447fbf259cd4741468f727f5a9f1670878b031401c147f3ace4775bbc90a1a146dd21236581832f5da7b3f8c416d66747b445518d9db5ef6a78c94306d69f7ef5b60d48c094a21b34df378e3df65ec33623da7517c478e1cafa78f7049dafa2d60b8fb8cdb0bfea3cbb9929f9ac17299ea6dae0c6509b9a0007a2223dceb5e099aec157f1d78192f2775d40c010bd3aa002d789c772f5307138e057266b7b34ef8086566a13d4ad55c0fa408a98a2dd6468b1afee5d6a5dda42723243848c2af94b999fcf39905823a8bdfd800035a22b83e225673eb67bb2fc97253efae1f3361afae44417d32f0a0d69a8cfe4679cb109a8a689114464073fbb81fc26e6921628c20354fcc3dd34f01c1909e8c0e4fa8df7a4bcaafb2700618dcdaf96ffc59683c3febbd4753a594d1951bae07f51224b47014d698dd957fb078a77dc87b3cee3504091a8d0813df49ab2b84f5aa8ad92c95753521fa13e6e52b2798431534d8e58a850ff9d12d0d1f84ec9fa5487dd25d4bbc0da1ed8aafc823b0be132fad31df63422c8e7332b00bcff03fa76d891ffe8a3d534a047001996204ca2813716da9cd83197054b5189356c6565680b9de2693766d3c7533dc27f6d0287cd7baad0d266ff9ca140523410508f6f35ad80983d511360e37d7e9da1eac4e47ecfd5ce9b6d3e13afefb6c87c79edf0dd68cb39e1423b0fa99196482cdef92ade58fdfe9dd509993548aa94712eb2d2a1f6abd77bb64b92eee9d1edd9cc949dbde2fb702ddbb30c7805b2b5506ecb84ecb195a53f56bae9570c104744190882fce5d920fda7877d328623da1d0061b26cce2dca2b8441fce30fdb757bb3afac0784a54f832e29a5860f3e7027d9196a036537d921ddf23eef2d5827be038d36c91a37de6fb4a7a9784b479bb1f64c9dd4b4e51b68d58784b76bf611a4ed43bab2876be96105a0e4ede858b8c26680667aa829a23a58c825393c221cbed14dd80af74242e85009babe616074951cc8ea91ad37654f258a5bf61230809a7c5ee59effba06acf3987f50eba7901d6738aa0e0ccfa7b7f97ee8ae75a966e05f3918f6dd7a0f1e3df21c7c02a26edf94581a1e03a9304014ccd132679986c657f177a23f138e0d8f175df23b683fcc59ccf327b5582ab0e899670af1095f251c40d2d4bde9a95218c42dbb84f23e1beacbaa3c69a9d8d2c03fe0b8c9bfaea3748b15bdd199a005a0c84e6b8417a4bbbd9bdc28e2c8cf2e68ac00ad2c924d1893447dc7a7376bdd65bb9d3a8616064c335831cf2826b3311368a2e40978503a8f3d0131d8a8f3ab8631164ae2cccbc65b13ce8da4fbf52cf022aaf71e1af097ce4fd33e3f6448fb4c903589ad9a906257241ca1a6ab9cd22b048f581e392e00e0ab833b1edf286be8d15bfd525e7c3572da811f1a92d5386a38c885d383106ebc1bc219d420c103c33881dd0329c6561a802c089f26b2790d57e2b8861ffbbd0bc37f51c805dfe720a5ce5938ed0003a8000ac9cabbead4c14ef71777cb74f7f21838b2a1d7ff47509709362f8658f8a004b49c7edf0e072821eeeb89f317f35dc8090e0f84f8c6cacb8d5f5f34a2afe6b5c4b82b4865220dfcbaee86ad2406ec0fbe03878295c2b2902bcc4b2e4bd8b89b54865f5b552e8eaa5f7938dedea31d9dbebeea4431a9cbad2e82d825d8941c65963971eb03763a6bde37abb8ca43d267b032f80999a130444064da2d6b0bd765b3bc5a9d1b7ce7a9ae4a1533beabfa42c891175fb5e9a86e02ac26abcd475e3fa6850ed89f213138f1be2522b5564a5fdeec3faff99b0b63a9fea0ea46ad4358fb8440194e7d2242fd42794de916c3e291b97fad69302c86ab846ee717594a1e64edcdf3c54443059443cd23c19c4a5287fd748d1483925b024acdce1b04640fbe6bf01a4f30f8fa576e3dfb6cf077efd19fa85d01c8fd40617bd8c47e6995573dd112b6050da7b2c612aca36fc51a16110a666bad65da92010279f58cad6ee70ac1bc9c99c65e1a371a7dbf4eace02474b0148b295c1fe24bf178b6463e8ff114299b39734febf99558792547473460725f356d889fd37aee3bdebe15a402fde75e0c0810e67ceda9531ed2f06e31dccce650608e8e87b3c9e9f6419e2468b8ad9a5d6729684516397cd5d1455079c0fccd7c21313be0cb49f3c2f0b51dfb0e675141d334a25c4128a80e59f578a7f14cd7c00df5c20c37bf6fd64d687491958a61f3b2f86632fad41abdc15989c5afc905151fd19218cf1bfcfb2dedf87c98bfc126f94b18c0e4f6de7c7f9890f147aa66831af921d5ecb350e7548610cff4b0b0b951e24095d3a91874bde7e314fb05730cc9e472446283dc1f25d30450723a1728d4a648d420cadfdbe6b3bca77a07c7eaf83925eb2d82694c26b4f0a32bcd10fe0c8d51e1703dca9a0f81ad5666ad733124c26be960133c524556d33cd6d39dd9e9f80ffb4024a5e51357091e3f5edd91c50ee0e582286c7cada409e45e7a07e31a5b5b770b9d18b049afe92db64d20289ca7e5e67cdc725b21ab528608547651ac13cf4c4e30025d2e3aabdac92dcf5031c81a3c0b077a9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL磁盘空间压缩</title>
    <url>//posts/3756147499.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>由于 WSL 的系统是作为文件存储在 Windows 系统中的，所以对 WSL
的一些操作会影响到 Windows 系统的磁盘空间使用情况。WSL
的磁盘空间使用情况可以通过<code>wsl --list --verbose</code>命令查看。</p>
<p>但是 WSL
不会自动去释放已经占有但是标记为空的磁盘空间，所以需要手动去释放这些空间。</p>
<h2 id="方式一">方式一</h2>
<p>导出 WSL 的文件系统，然后删除原来的 WSL 文件系统，最后再导入新的 WSL
文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> &lt;distribution name&gt; &lt;file name&gt;</span><br><span class="line">wsl --unregister &lt;distribution name&gt;</span><br><span class="line">wsl --import &lt;distribution name&gt; &lt;install location&gt; &lt;file name&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;distribution name&gt;</code>是 WSL
的发行版名称，<code>&lt;file name&gt;</code>是导出的文件名，<code>&lt;install location&gt;</code>是
WSL 的安装位置。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> Ubuntu ubuntu.tar</span><br><span class="line">wsl --unregister Ubuntu</span><br><span class="line">wsl --import Ubuntu C:\WSL\Ubuntu ubuntu.tar</span><br></pre></td></tr></table></figure>
<h2 id="方式二">方式二</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Optimize-VHD</span> <span class="literal">-Path</span> <span class="string">&quot;C:\完整路径\ext4.vhdx&quot;</span> <span class="literal">-Mode</span> Full</span><br></pre></td></tr></table></figure>
<p>其中<code>C:\完整路径\ext4.vhdx</code>是 WSL
的文件系统的路径，可以通过<code>wsl --list --verbose</code>命令查看。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>WSL</tag>
        <tag>磁盘空间</tag>
      </tags>
  </entry>
</search>
